<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/main.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/header.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/print.css" media="print"><link rel="icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="shortcut icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="alternate" type="application/rss+xml" title="Новости сайта skipy.ru" href="http://www.skipy.ru/rss2.xml"><title>skipy.ru: Записки трезвого практика -&gt;
                Техника -&gt;
                Сравнение объектов: практика</title></head><body><script type="text/javascript">
            new Image().src = "//counter.yadro.ru/hit?r"+
            escape(document.referrer)+((typeof(screen)=="undefined")?"":
            ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
            ";"+Math.random();</script><div id="counter"><a href="http://www.liveinternet.ru/click" target="_blank"><img class="pcfykmqlcrtplekulgcu" src="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/logo.gif" title="LiveInternet" alt="" height="31" width="31" border="0"></a></div><table class="formatting" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div id="header"><table class="head" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/head_left.jpg" alt="Заголовок страницы"></td><td align="right"><img src="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/head_right.jpg" alt="Заголовок страницы"></td></tr></tbody></table><div id="headDelim"><span></span></div><div id="rootlink"><a href="http://www.skipy.ru/index.html" style="border: none;"><img src="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/dot.gif" alt="" height="130" width="120"></a></div><div id="menu"><table bgcolor="#264A84"><tbody><tr><td><a href="http://www.skipy.ru/index.html">Главная</a></td><td><a href="http://www.skipy.ru/philosophy.html">Философия</a></td><td class="current"><a href="http://www.skipy.ru/technics.html">Техника</a></td><td><a href="http://www.skipy.ru/architecture.html">Архитектура</a></td><td><a href="http://www.skipy.ru/useful.html">Полезное</a></td></tr></tbody></table></div><div id="submenu"><table bgcolor="#F49B2E"><tbody><tr><td><a href="http://www.skipy.ru/technics.html#general">Общее</a></td><td><a href="http://www.skipy.ru/technics.html#gui">GUI</a></td><td class="current"><a href="http://www.skipy.ru/technics.html#lang">java.lang</a></td><td><a href="http://www.skipy.ru/technics.html#io">java.io</a></td><td><a href="http://www.skipy.ru/technics.html#dyk">Знаете ли вы?..</a></td></tr></tbody></table></div></div></td></tr><tr><td><div id="content"><br>
        <p class="lastChange">Последнее изменение: 1 сентября 2007г.</p>

<h2 id="top">Сравнение объектов: практика</h2>

<p>Это вторая из статей, посвященных сравнению объектов. В <a href="http://www.skipy.ru/technics/objCompTh.html">первой</a> из них речь шла о
теоретическом базисе сравнения – как это делается, почему и где используется. В этой же статье речь пойдет непосредственно
о сравнении чисел, объектов, о частных случаях, тонкостях и неочевидных моментах. А если точнее, мы поговорим вот о чем:</p>

<ul>
    <li><a href="#str_equals_vs_eqeq">Сравнение строк: <code>'=='</code> и <code>equals</code></a></li>
    <li><a href="#str_intern">Метод <code>String.intern</code></a></li>
    <li><a href="#real_comp">Сравнение вещественных примитивов</a></li>
    <li><a href="#plusZero_vs_minusZero"><code>+0.0</code> и <code>-0.0</code></a></li>
    <li><a href="#nan">Значение <code>NaN</code></a></li>
    <li><a href="#productionMethod">Java 5.0. Производящие методы и сравнение через <code>'=='</code></a></li>
    <li><a href="#unboxing">Java 5.0. Autoboxing/Unboxing: <code>'=='</code>, <code>'&gt;='</code> и <code>'&lt;='</code>
    для объектных оболочек.</a></li>
    <li><a href="#enums_comp">Java 5.0. сравнение элементов перечислений (тип <code>enum</code>)</a></li>
</ul>

<p>Итак, приступим!</p>

<h4 id="str_equals_vs_eqeq">Сравнение строк: <code>'=='</code> и <code>equals</code></h4>

<p>Ах, эти строки... Один из наиболее часто используемых типов, вызывающих при этом немало проблем. В принципе, о них
есть <a href="http://www.skipy.ru/technics/strings.html">отдельная статья</a>. А здесь я коснусь вопросов сравнения.</p>

<p>Разумеется, строки можно сравнивать с помощью <code>equals</code>. Более того, их НУЖНО сравнивать через <code>
equals</code>. Однако, есть тонкости, которые стоит знать.</p>

<p>Прежде всего, одинаковые строки на самом деле являются единственным объектом. В чем легко убедиться, выполнив следующий
код:</p>

<pre>String str1 = <span class="blue">"string"</span>;
String str2 = <span class="blue">"string"</span>;
System.out.println(str1==str2 ? <span class="blue">"the same"</span> : <span class="blue">"not the same"</span>);</pre>

<p>Результатом будет <em>"the same"</em>. Что означает, что <em>ссылки</em> на строки равны. Это сделано на уровне
компилятора, очевидно, для экономии памяти. Компилятор создает ОДИН экземпляр строки, и присваивает <code>str1</code> и
<code>str2</code> ссылку на этот экземпляр<sup><a href="#thanks1">1</a></sup>.</p>

<p>Однако, это относится только к строкам, объявленным как литералы, в коде. Если скомпоновать строку из кусков, ссылка на
нее будет другой. Подтверждение – данный пример:</p>

<pre>String str1 = <span class="blue">"string"</span>;
String str2 = <span class="blue">"str"</span>;
String str3 = <span class="blue">"ing"</span>;
System.out.println(str1==(str2+str3) ? <span class="blue">"the same"</span> : <span class="blue">"not the same"</span>);</pre>

<p>Результатом будет <em>"not the same"</em>. Также можно создать новый объект с помощью копирующего конструктора:</p>

<pre>String str1 = <span class="blue">"string"</span>;
String str2 = <b>new</b> String(<span class="blue">"string"</span>);
System.out.println(str1==str2 ? <span class="blue">"the same"</span> : <span class="blue">"not the same"</span>);</pre>

<p>Результатом также будет <em>"not the same"</em>.</p>

<p>Таким образом, иногда строки можно сравнивать и через сравнение ссылок. Но на это лучше не полагаться.</p>

<p>Я хотел бы затронуть один весьма любопытный метод, который позволяет получить так называемое каноническое представление
строки – <code>String.intern</code>. Поговорим о нем поподробнее.</p>

<h4 id="str_intern">Метод <code>String.intern</code></h4>

<p>Начнем с того, что класс String поддерживает пул строк. В этот пул добавляются все строковые литералы, определенные в
классах, и не только они. Так вот, метод <code>intern</code> позволяет получить из этого пула строку, которая равна имеющейся
(той, у которой вызывается метод <code>intern</code>) с точки зрения <code>equals</code>. Если такой строки в пуле не
существует, то туда помещается имеющаяся, и возвращается ссылка на нее. Таким образом, если даже ссылки на две равных
строки разные (как в двух примерах выше), то вызовы у этих строк <code>intern</code> вернут ссылку на один и тот же объект:
</p>

<pre>String str1 = <span class="blue">"string"</span>;
String str2 = new String(<span class="blue">"string"</span>);
System.out.println(str1.intern()==str2.intern() ? <span class="blue">"the same"</span> : <span class="blue">"not the same"</span>);</pre>

<p>Результатом выполнения этого фрагмента кода будет <em>"the same"</em>.</p>

<p>Я не могу сказать точно, зачем это сделано так. Метод <code>intern</code> – native, а в дебри С-кода мне, честно сказать,
не хочется. Скорее всего это сделано для оптимизации потребления памяти и производительности. В любом случае, стоит знать
об этой особенности реализации.</p>

<p>Переходим к следующей части.</p>

<h4 id="real_comp">Сравнение вещественных примитивов</h4>

<p>Для начала я хочу задать вопрос. Очень простой. Чему равна следующая сумма – <code>0.3f + 0.4f</code>? Чему?
<code>0.7f</code>? Проверим:</p>

<pre><b>float</b> f1 = 0.7f;
<b>float</b> f2 = 0.3f + 0.4f;
System.out.println("f1==f2: "+(f1==f2));</pre>

<p>Как результат? Нравится? Мне тоже. Для тех, кто не выполнил этот фрагмент, скажу – результат будет...</p>

<pre>f1==f2: <span class="red_b">false</span></pre>

<p>Почему это происходит?.. Выполним еще один тест:</p>

<pre><b>float</b> f1 = 0.3f;
<b>float</b> f2 = 0.4f;
<b>float</b> f3 = f1 + f2;
<b>float</b> f4 = 0.7f;
System.out.println("f1="+(<b>double</b>)f1);
System.out.println("f2="+(<b>double</b>)f2);
System.out.println("f3="+(<b>double</b>)f3);
System.out.println("f4="+(<b>double</b>)f4);</pre>

<p>Обратите внимание на приведение к <code>double</code>. Это сделано для того, чтобы вывести побольше знаков после запятой.
Результат:</p>

<pre>f1=0.30000001192092896
f2=0.4000000059604645
f3=0.7000000476837158
f4=0.699999988079071</pre>

<p>Собственно говоря, результат прогнозируемый. Представление дробной части осуществляется с помощью <em>конечного</em> ряда
2<sup>-n</sup>, а потому о точном представлении произвольно взятого числа говорить не приходится. Как видно из примера,
точность представления <code>float</code> – 7 знаков после запятой.</p>

<p class="off">Строго говоря, в представлении <code>float</code> на мантиссу отведено 24 бита. Таким образом минимальное по
модулю число, которое можно представить с помощью <code>float</code> (без учета степени, ибо мы говорим о точности) – это
2<sup>-24</sup>≈6*10<sup>-8</sup>. Именно с таким шагом реально идут значения в представлении <code>float</code>.
А поскольку есть квантование – есть и погрешность.</p>

<p>Отсюда вывод: числа в представлении <code>float</code> можно сравнивать только с определенной точностью. Я бы
рекомендовал округлять их до 6-го знака после запятой (10<sup>-6</sup>), либо, что предпочтительнее, проверял бы
<b>абсолютное значение</b><sup><a href="#thanks2">2</a></sup> разности между ними:</p>

<pre><b>float</b> f1 = 0.3f;
<b>float</b> f2 = 0.4f;
<b>float</b> f3 = f1 + f2;
<b>float</b> f4 = 0.7f;
System.out.println("|f3-f4|&lt;1e-6: "+( Math.abs(f3-f4) &lt; 1e-6 ));</pre>

<p>В этом случае результат вселяет надежду:</p>

<pre>|f3-f4|&lt;1e-6: <span class="green_b">true</span></pre>

<p>Разумеется, точно та же картина и с типом <code>double</code>. С единственной разницей, что там на мантиссу отведено 53
бита, следовательно, точность представления – 2<sup>-53</sup>≈10<sup>-16</sup>. Да, величина квантования куда
меньше, но она есть. И может сыграть злую шутку. </p>

<p class="off">Кстати, в тестовой библиотеке <a href="http://www.junit.org/" target="_blank">JUnit</a> в методах сравнения
вещественных чисел точность указывается в явном виде. Т.е. метод сравнения содержит три параметра – число, чему оно должно
быть равно и точность сравнения. </p>

<p class="off">Еще кстати, хочу упомянуть о тонкости, связаной с записью чисел в научном формате, с указанием степени.
Вопрос. Как записать 10<sup>-6</sup>? Практика показывает, что более 80% отвечают – <code>10e-6</code>. Между тем, правильный
ответ – <code>1e-6</code>! А <code>10e-6</code> – это 10<sup>-5</sup>! Мы наступили на эти грабли в одном из проектов,
довольно неожиданно. Ошибку искали очень долго, на константы смотрели раз 20. И ни у кого не возникло ни тени сомнения в их
правильности, пока однажды, в большой степени случайно, константу <code>10e-3</code> не вывели на печать и не обнаружили
у нее после запятой <em>два</em> знака вместо ожидавшихся трех. А потому – будьте бдительны!</p>

<p>Движемся дальше.</p>

<h4 id="plusZero_vs_minusZero"><code>+0.0</code> и <code>-0.0</code></h4>

<p>В представлении вещественных чисел старший бит является знаковым. А что будет, если все остальные биты равны <code>
0</code>? В отличие от целых, где в такой ситуации получается отрицательное число, находящееся на нижней границе диапазона
представления, вещественное число только со старшим битом, выставленным в <code>1</code>, тоже обозначает <code>0</code>,
только со знаком минус. Таким образом, у нас есть <b>два</b> нуля – <code>+0.0</code> и <code>-0.0</code>.</p>

<p>Возникает логичный вопрос – считать ли эти числа равными? Виртуальная машина считает именно так. Однако, это два <b>
разных</b> числа, ибо в результате операций с ними получаются разные значения:</p>

<pre><b>float</b> f1 = 0.0f/1.0f;
<b>float</b> f2 = 0.0f/-1.0f;
System.out.println("f1="+f1);
System.out.println("f2="+f2);
System.out.println("f1==f2: "+(f1==f2));
<b>float</b> f3 = 1.0f / f1;
<b>float</b> f4 = 1.0f / f2;
System.out.println("f3="+f3);
System.out.println("f4="+f4);</pre>

<p>... и результат:</p>

<pre>f1=0.0
f2=-0.0
f1==f2: <span class="green_b">true</span>
f3=Infinity
f4=-Infinity</pre>

<p>Таким образом, в некоторых случаях есть смысл расценивать <code>+0.0</code> и <code>-0.0</code> как два разных числа.
А если у нас есть два объекта, в одном из которых поле равно <code>+0.0</code>, а в другом <code>-0.0</code> – эти объекты
точно так же можно расценивать как неравные. Возникает вопрос – а как понять, что числа неравны, если их прямое сравнение
виртуальной машиной дает <code>true</code>?</p>

<p>Ответ таков. Несмотря на то, что виртуальнай машина считает эти числа равными, представления у них все-таки отличаются.
Поэтому – единственное, что можно сделать, это сравнить представления. А для того, чтобы его получить, существуют методы
<code>int Float.floatToIntBits(float)</code> и <code>long Double.doubleToLongBits(double)</code>, которые возвращают
битовое представление в виде <code>int</code> и <code>long</code> соответственно (продолжение предыдущего примера):</p>

<pre><b>int</b> i1 = Float.floatToIntBits(f1);
<b>int</b> i2 = Float.floatToIntBits(f2);
System.out.println("i1 (+0.0):"+ Integer.toBinaryString(i1));
System.out.println("i2 (-0.0):"+ Integer.toBinaryString(i2));
System.out.println("i1==i2: "+(i1 == i2));</pre>

<p>Результатом будет</p>

<pre>i1 (+0.0):0
i2 (-0.0):10000000000000000000000000000000
i1==i2: <span class="red_b">false</span></pre>

<p>Таким образом, если у вас <code>+0.0</code> и <code>-0.0</code> – разные числа, то сравнивать вещественные переменные
следует через их битовое представление.</p>

<p>С <code>+0.0</code> и <code>-0.0</code> вроде как разобрались. <code>-0.0</code>, однако, является не единственным
сюрпризом. Есть еще такое явление как...</p>

<h4 id="nan">Значение <code>NaN</code></h4>

<p><code>NaN</code> расшифровывается как <code>Not-a-Number</code>. Это значение появляется в результате некорректных
математических операций, скажем, деления 0.0 на 0.0, бесконечности на бесконечность и т.п.</p>

<p>Особенностью этого значения является то, что оно не равно самому себе. Т.е.:</p>

<pre><b>float</b> x = 0.0f/0.0f;
System.out.println("x="+x);
System.out.println("x==x: "+(x==x));</pre>

<p>... даст в результате...</p>

<pre>x=NaN
x==x: <span class="red_b">false</span></pre>

<p>Чем это может обернуться при сравнении объектов? Если поле объекта будет равно <code>NaN</code>, то сравнение даст <code>
false</code>, т.е. объекты гарантированно будут считаться неравными. Хотя по логике вещей мы можем хотеть как раз обратного.
</p>

<p>Добиться нужного результата можно, используя метод <code>Float.isNaN(float)</code>. Он возвращает <code>true</code>, если
аргумент – <code>NaN</code>. На сравнение битовых представлений я бы в этом случае не полагался, т.к. оно не стандартизовано.
</p>

<p>Пожалуй, о примитивах хватит. Перейдем теперь к тонкостям, появившимся в Java с версии 5.0. И первый момент, которого
я бы хотел коснуться – </p>

<h4 id="productionMethod">Java 5.0. Производящие методы и сравнение через <code>'=='</code></h4>

<p>В проектировании есть шаблон, называемый <em>производящий метод</em>. Иногда его использование гораздо более выгодно,
нежели использование конструктора. Приведу пример. Думаю, все хорошо знаю объектную оболочку <code>Boolean</code>. Этот
класс неизменяемый, способен содержать всего два значения. Т.е., фактически, для любых нужд хватит всего-навсего двух
экземпляров. И если их создать заранее, а потом просто возвращать, то это будет намного быстрее, чем использование
конструктора. Такой метод у <code>Boolean</code> есть: <code>valueOf(boolean)</code>. Появился он в версии 1.4.</p>

<p>Подобные же производящие методы были введены с версии 5.0 и в классах <code>Byte</code>, <code>Character</code>,
<code>Short</code>, <code>Integer</code> и <code>Long</code>. При загрузке этих классов создаются массивы их экземпляров,
соответствующие определенным диапазонам значений примитивов. <span id="ranges">Диапазоны</span> эти следующие:</p>

<table style="condensed" border="1" cellpadding="0" cellspacing="0">
<tbody><tr class="ranges"><td>Byte:</td><td align="right">-128..127</td><td>(фактически – все значения)</td></tr>
<tr class="ranges"><td>Character:</td><td align="right">0..127</td><td></td></tr>
<tr class="ranges"><td>Short:</td><td align="right">-128..127</td><td></td></tr>
<tr class="ranges"><td>Integer:</td><td align="right">-128..127</td><td></td></tr>
<tr class="ranges"><td>Long:</td><td align="right">-128..127</td><td></td></tr>
</tbody></table>

<p>Означает это, что при использовании метода <code>valueOf(...)</code> при попадании аргумента в указанный диапазон всегда
будет возвращаться один и тот же объект. Возможно, это и дает какое-то увеличение скорости. Но при этом появляются проблемы
такого характера, что докопаться до сути бывает довольно сложно. Читайте об этом дальше.</p>

<p class="off">Теоретически производящий метод <code>valueOf</code> добавлен и в классы <code>Float</code> и <code>
Double</code>. В их описании сказано, что если не нужен новый экземпляр, то лучше пользоваться этим методом, т.к. он может
дать прибавку в скорости и т.д. и т.п. Однако в текущей (Java 5.0) реализации в этом методе создается новый экземпляр, т.е.
прибавки в скорости его использование не даст гарантированно. Более того, мне сложно представить, как можно ускорить этот
метод, ибо ввиду непрерывности значений кеш там не организуешь. Разве что для целых чисел. В смысле, без дробной части.</p>

<h4 id="unboxing">Java 5.0. Autoboxing/Unboxing: <code>'=='</code>, <code>'&gt;='</code> и <code>'&lt;='</code> для
объектных оболочек.</h4>

<p>Подозреваю, что производящие методы и кеш экземпляров были добавлены в оболочки для целочисленных примитивов ради
оптимизации операций autoboxing/unboxing. Напомню, что это такое. Если в операции должен участвовать объект, а участвует
примитив, то этот примитив автоматически оборачивается в объектную оболочку. Это autoboxing. И наоборот – если в операции
должен участвовать примитив, то можно подставить туда объектную оболочку, и значение будет автоматически из нее развернуто.
Это unboxing.</p>

<p class="off">Естественно, за такое удобство надо платить. Операции автоматического преобразования несколько
замедляют скорость работы приложения. Однако к текущей теме это не относится, потому оставим этот вопрос.</p>

<p>Все хорошо до тех пор, пока мы имеем дело с операциями, однозначно относящимися к примитивам либо к оболочкам. А что будет
с операцией <code>'=='</code>? Допустим, у нас есть два объекта <code>Integer</code>, с одинаковым значением внутри. Как они
будут сравниваться?</p>

<pre>Integer i1 = <b>new</b> Integer(1);
Integer i2 = <b>new</b> Integer(1);
System.out.println("i1==i2: "+(i1==i2));</pre>

<p>Результат:</p>

<pre>i1==i2: <span class="red_b">false</span></pre>

<p>Кто бы сомневался... Сравниваются они как объекты. А если так:</p>

<pre>Integer i1 = 1;
Integer i2 = 1;
System.out.println("i1==i2: "+(i1==i2));</pre>

<p>Результат:</p>

<pre>i1==i2: <span class="green_b">true</span></pre>

<p>Вот это уже интереснее! При autoboxing-е возвращаются одинаковые объекты!</p>

<p>Вот тут и находится ловушка. Однажды обнаружив, что возвращаются одинаковые объекты, мы начнем экспериментировать, чтобы
проверить, всегда ли это так. И сколько мы проверим значений? Одно? Десять? Сто? Скорее всего ограничимся сотней в каждую
сторону вокруг нуля. И везде получим равенство. Казалось бы, все хорошо. Однако, посмотрите чуть назад, вот
<a href="#ranges">сюда</a>. Догадались, в чем подвох?..</p>

<p>Да, экземпляры объектных оболочек при autoboxing-е создаются с помощью производящих методов. Что хорошо иллюстрируется
следующим тестом:</p>

<pre><b>public class</b> AutoboxingTest {

    <b>private static final int</b> numbers[] = <b>new int</b>[]{-129,-128,127,128};

    <b>public static void</b> main(String[] args) {
        <b>for</b> (<b>int</b> number : numbers) {
            Integer i1 = number;
            Integer i2 = number;
            System.out.println("number=" + number + ": " + (i1 == i2));
        }
    }
}</pre>

<p>Результат будет таков:</p>

<pre>number=-129: <span class="red_b">false</span>
number=-128: <span class="green_b">true</span>
number=127: <span class="green_b">true</span>
number=128: <span class="red_b">false</span></pre>

<p>Для попадающих в <a href="#ranges">диапазон кеширования</a> значений возвращаются одинаковые объекты, для находящихся
вне него – разные. А следовательно, если где-то в приложении будут сравниваться оболочки вместо примитивов – есть шанс
получить самую страшную ошибку: плавающую. Потому как тестировать код, скорее всего, тоже будут на ограниченом диапазоне
значений, в котором эта ошибка не проявится. А в реальной работе она то будет проявляться, то исчезать, в зависимости от
результатов каких-то вычислений. Проще сойти с ума, чем найти такую ошибку. А потому – я бы советовал избегать autoboxing-а
где только можно.</p>

<p>И это не всё. Вспомним математику, не далее чем 5-го класса. Пусть выполняются неравенства <code>A&gt;=B</code> и
<code>А&lt;=B</code>. Что можно сказать об отношении <code>A</code> и <code>B</code>? Только одно – они равны. Согласны?
Думаю, да. Запускаем тест:</p>

<pre>Integer i1 = <b>new</b> Integer(1);
Integer i2 = <b>new</b> Integer(1);
System.out.println("i1&gt;=i2: "+(i1&gt;=i2));
System.out.println("i1&lt;=i2: "+(i1&lt;=i2));
System.out.println("i1==i2: "+(i1==i2));</pre>

<p>Результат:</p>

<pre>i1&gt;=i2: <span class="green_b">true</span>
i1&lt;=i2: <span class="green_b">true</span>
i1==i2: <span class="red_b">false</span></pre>

<p>И вот это для меня – самая большая странность. Я вообще не понимаю, зачем было вводить в язык эту возможность, если она
вносит такие противоречия. В общем, повторю еще раз – если есть возможность обойтись без autoboxing/unboxing, то стоит эту
возможность использовать на полную катушку.</p>

<p>Последняя тема, которой я хотел бы коснуться, это...</p>

<h4 id="enums_comp">Java 5.0. сравнение элементов перечислений (тип <code>enum</code>)</h4>

<p>Как известно, с версии 5.0 в Java появился такой тип как <code>enum</code> – перечисление. Его экземпляры по умолчанию
содержат имя и порядковый номер в объявлении экземпляра в классе. Соответственно, при изменении порядка объявления номера
меняются. Однако, как я уже <a href="http://www.skipy.ru/technics/serialization.html#enum_ser">говорил</a> в статье
<a href="http://www.skipy.ru/technics/serialization.html">'Сериализация как она есть'</a>, это не вызывает проблем. Все элементы перечисления существуют
в единственном экземпляре, это контролируется на уровне виртуальной машины. Поэтому их можно сравнивать напрямую, по ссылкам.
</p>

<p class="delim">* * *</p>

<p>Пожалуй, это всё на сегодня о практической стороне реализации сравнения объектов. Возможно, я что-то упустил. Как обычно,
жду комментариев! А пока позвольте откланяться. Всем спасибо за внимание!</p>

<hr style="margin-right:10pt">
<p class="footnote" id="thanks1">
<sup>1.</sup> Спасибо за комментарий участнику конференции с ником <b>Pabel</b><br>
</p>
<p class="footnote" id="thanks2"><sup>2.</sup> Спасибо за внимательность участнику конференции <b>Виталию Самоловских</b>!</p>
    <br><p class="top_link"><a href="#top">В начало</a></p></div></td></tr><tr><td><div id="copyright">
                    Copyright © 2004-2013 Евгений Матюшкин aka Skipy
                    (e-mail: skiрy<img src="skipy.ru:%20%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2:%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0_files/at_sm.gif" alt="@">skipy.ru)<br><a href="http://www.skipy.ru/about_copying.html">Копирование и воспроизведение материалов</a> этого сайта возможно
                    только с согласия автора!
                </div></td></tr></tbody></table></body></html>