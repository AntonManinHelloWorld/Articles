<!DOCTYPE html>
<html dir="ltr" class="client-nojs" lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>Глава 17 Thinking in Java 4th edition — WikiJava: Wiki of Java: викифицированные книги и статьи по Java</title>
<meta name="generator" content="MediaWiki 1.22.2">
<link rel="shortcut icon" href="http://wikijava.it-cache.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wikijava.it-cache.net/opensearch_desc.php" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://wikijava.it-cache.net/api.php@action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java&nbsp;— Atom-лента" href="http://wikijava.it-cache.net/index.php@title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F%253A%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="stylesheet" href="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/style3.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wjava2-wj_:resourceloader:filter:minify-css:7:32e7e505403c81fe0a24e297ef166436 */</style>

<script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/style1.css"></script><script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/load.html"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Глава_17_Thinking_in_Java_4th_edition","wgTitle":"Глава 17 Thinking in Java 4th edition","wgCurRevisionId":41,"wgRevisionId":41,"wgArticleId":31,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Книги","Java"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Глава_17_Thinking_in_Java_4th_edition","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"simplesearch":true,"experiments":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"ru","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"ru"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wjava2-wj_:resourceloader:filter:minify-js:7:07bb1f4d2452379e70abca47c4cde6d9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java5.source-java5 .de1, .java5.source-java5 .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java5.source-java5  {font-family:monospace;}
.java5.source-java5 .imp {font-weight: bold; color: red;}
.java5.source-java5 li, .java5.source-java5 .li1 {font-weight: normal; vertical-align:top;}
.java5.source-java5 .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java5.source-java5 .li2 {font-weight: bold; vertical-align:top;}
.java5.source-java5 .kw1 {color: #000000;  font-weight: bold;}
.java5.source-java5 .kw2 {color: #000000; font-weight: bold;}
.java5.source-java5 .kw3 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw4 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw5 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw6 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw7 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw8 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw9 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw10 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw11 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw12 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw13 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw14 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw15 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw16 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw17 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw18 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw19 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw20 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw21 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw22 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw23 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw24 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw25 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw26 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw27 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw28 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw29 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw30 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw31 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw32 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw33 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw34 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw35 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw36 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw37 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw38 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw39 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw40 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw41 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw42 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw43 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw44 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw45 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw46 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw47 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw48 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw49 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw50 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw51 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw52 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw53 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw54 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw55 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw56 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw57 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw58 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw59 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw60 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw61 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw62 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw63 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw64 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw65 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw66 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw67 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw68 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw69 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw70 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw71 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw72 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw73 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw74 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw75 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw76 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw77 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw78 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw79 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw80 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw81 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw82 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw83 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw84 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw85 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw86 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw87 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw88 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw89 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw90 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw91 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw92 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw93 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw94 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw95 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw96 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw97 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw98 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw99 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw100 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw101 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw102 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw103 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw104 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw105 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw106 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw107 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw108 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw109 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw110 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw111 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw112 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw113 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw114 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw115 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw116 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw117 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw118 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw119 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw120 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw121 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw122 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw123 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw124 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw125 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw126 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw127 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw128 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw129 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw130 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw131 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw132 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw133 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw134 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw135 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw136 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw137 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw138 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw139 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw140 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw141 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw142 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw143 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw144 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw145 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw146 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw147 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw148 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw149 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw150 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw151 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw152 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw153 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw154 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw155 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw156 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw157 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw158 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw159 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw160 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw161 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw162 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw163 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw164 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw165 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw166 {color: #003399; font-weight: bold;}
.java5.source-java5 .co1 {color: #666666; font-style: italic;}
.java5.source-java5 .co2 {color: #006699;}
.java5.source-java5 .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java5.source-java5 .coMULTI {color: #666666; font-style: italic;}
.java5.source-java5 .es0 {color: #000099; font-weight: bold;}
.java5.source-java5 .br0 {color: #009900;}
.java5.source-java5 .sy0 {color: #339933;}
.java5.source-java5 .st0 {color: #0000ff;}
.java5.source-java5 .nu0 {color: #cc66cc;}
.java5.source-java5 .me1 {color: #006633;}
.java5.source-java5 .me2 {color: #006633;}
.java5.source-java5 .ln-xtra, .java5.source-java5 li.ln-xtra, .java5.source-java5 div.ln-xtra {background-color: #ffc;}
.java5.source-java5 span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Глава_17_Thinking_in_Java_4th_edition skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="ru"><span dir="auto">Глава 17 Thinking in Java 4th edition</span></h1>
			<div id="bodyContent">
								<div id="siteSub">Материал из WikiJava: Wiki of Java: викифицированные книги и статьи по Java</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#mw-navigation">навигация</a>, 					<a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#p-search">поиск</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="ru"><table style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;" cellpadding="0" cellspacing="0">
<tbody><tr>
<td> <div id="toc" class="toc"><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9F.D0.90.D0.A0.D0.90.D0.9B.D0.9B.D0.95.D0.9B.D0.AC.D0.9D.D0.9E.D0.95_.D0.92.D0.AB.D0.9F.D0.9E.D0.9B.D0.9D.D0.95.D0.9D.D0.98.D0.95"><span class="tocnumber">1</span> <span class="toctext"><b>ПАРАЛЛЕЛЬНОЕ ВЫПОЛНЕНИЕ</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B8"><span class="tocnumber">1.1</span> <span class="toctext">Задачи</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D0.B0.D1.81.D1.81_Thread"><span class="tocnumber">1.2</span> <span class="toctext">Класс Thread</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D0.BD.D0.B8.D1.82.D0.B5.D0.BB.D0.B8"><span class="tocnumber">1.3</span> <span class="toctext">Исполнители</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.92.D0.BE.D0.B7.D0.B2.D1.80.D0.B0.D1.82_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D0.B9_.D0.B8.D0.B7_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87"><span class="tocnumber">1.4</span> <span class="toctext">Возврат значений из задач</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B6.D0.B8.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.5</span> <span class="toctext">Ожидание</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B8.D0.BE.D1.80.D0.B8.D1.82.D0.B5.D1.82"><span class="tocnumber">1.6</span> <span class="toctext">Приоритет</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.B4.D0.B0.D1.87.D0.B0_.D1.83.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.7</span> <span class="toctext">Передача управления</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D1.82.D0.BE.D0.BA.D0.B8-.D0.B4.D0.B5.D0.BC.D0.BE.D0.BD.D1.8B"><span class="tocnumber">1.8</span> <span class="toctext">Потоки-демоны</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.92.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82.D1.8B_.D0.BA.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.9</span> <span class="toctext">Варианты кодирования</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B8.D1.81.D0.BE.D0.B5.D0.B4.D0.B8.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D1.83"><span class="tocnumber">1.10</span> <span class="toctext">Присоединение к потоку</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.BD.D0.BE.D0.B5_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.80.D0.B5.D1.81.D1.83.D1.80.D1.81.D0.BE.D0.B2"><span class="tocnumber">1.11</span> <span class="toctext">Совместное использование ресурсов</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.BA.D0.BE.D1.80.D1.80.D0.B5.D0.BA.D1.82.D0.BD.D1.8B.D0.B9_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF_.D0.BA_.D1.80.D0.B5.D1.81.D1.83.D1.80.D1.81.D0.B0.D0.BC"><span class="tocnumber">1.11.1</span> <span class="toctext">Некорректный доступ к ресурсам</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B0.D0.B7.D1.80.D0.B5.D1.88.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.BD.D1.84.D0.BB.D0.B8.D0.BA.D1.82.D0.BE.D0.B2_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.B0"><span class="tocnumber">1.11.2</span> <span class="toctext">Разрешение конфликтов доступа</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B4.D0.BB.D1.8F_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D0.B0_EvenGenerator"><span class="tocnumber">1.11.3</span> <span class="toctext">Синхронизация для примера EvenGenerator</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D1.8B_Lock"><span class="tocnumber">1.11.4</span> <span class="toctext">Объекты Lock</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-17"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.90.D1.82.D0.BE.D0.BC.D0.B0.D1.80.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_volatile"><span class="tocnumber">1.12</span> <span class="toctext">Атомарные операции и ключевое слово volatile</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.90.D1.82.D0.BE.D0.BC.D0.B0.D1.80.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B"><span class="tocnumber">1.13</span> <span class="toctext">Атомарные классы</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9A.D1.80.D0.B8.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D1.81.D0.B5.D0.BA.D1.86.D0.B8.D0.B8"><span class="tocnumber">1.14</span> <span class="toctext">Критические секции</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.BE_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D0.BC_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.B0.D0.BC"><span class="tocnumber">1.15</span> <span class="toctext">Синхронизация по другим объектам</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9B.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D1.8C_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0"><span class="tocnumber">1.16</span> <span class="toctext">Локальная память потока</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.92.D0.B7.D0.B0.D0.B8.D0.BC.D0.BE.D0.B4.D0.B5.D0.B9.D1.81.D1.82.D0.B2.D0.B8.D0.B5_.D0.BC.D0.B5.D0.B6.D0.B4.D1.83_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0.D0.BC.D0.B8"><span class="tocnumber">1.17</span> <span class="toctext">Взаимодействие между потоками</span></a>
<ul>
<li class="toclevel-3 tocsection-23"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B_wait.28.29_.D0.B8_notifyAII.28.29"><span class="tocnumber">1.17.1</span> <span class="toctext">Методы wait() и notifyAII()</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.B0.D0.BD.D0.B0.D0.BB.D0.BE.D0.B2_.D0.B4.D0.BB.D1.8F_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0_.D0.BC.D0.B5.D0.B6.D0.B4.D1.83_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0.D0.BC.D0.B8"><span class="tocnumber">1.17.2</span> <span class="toctext">Использование каналов для ввода/вывода между потоками</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.92.D0.B7.D0.B0.D0.B8.D0.BC.D0.BD.D0.B0.D1.8F_.D0.B1.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0"><span class="tocnumber">1.17.3</span> <span class="toctext">Взаимная блокировка</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9D.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B1.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D1.87.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.BD.D0.B5.D0.BD.D1.82.D1.8B"><span class="tocnumber">1.18</span> <span class="toctext">Новые библиотечные компоненты</span></a>
<ul>
<li class="toclevel-3 tocsection-27"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#CountDownLatch"><span class="tocnumber">1.18.1</span> <span class="toctext">CountDownLatch</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#CyclicBarrier"><span class="tocnumber">1.18.2</span> <span class="toctext">CyclicBarrier</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#DelayQueue"><span class="tocnumber">1.18.3</span> <span class="toctext">DelayQueue</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#PriorityBlockingQueue"><span class="tocnumber">1.18.4</span> <span class="toctext">PriorityBlockingQueue</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BE.D1.80.D0.B0.D0.BD.D0.B6.D0.B5.D1.80.D0.B5.D0.B5.D0.B9_.D0.BD.D0.B0_.D0.B1.D0.B0.D0.B7.D0.B5_ScheduledExecutor"><span class="tocnumber">1.19</span> <span class="toctext">Управление оранжереей на базе ScheduledExecutor</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B5.D0.BC.D0.B0.D1.84.D0.BE.D1.80.D1.8B"><span class="tocnumber">1.20</span> <span class="toctext">Семафоры</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#Exchanger"><span class="tocnumber">1.21</span> <span class="toctext">Exchanger</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9C.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.22</span> <span class="toctext">Моделирование</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.9C.D0.BE.D0.B4.D0.B5.D0.BB.D1.8C_.D0.BA.D0.B0.D1.81.D1.81.D0.B8.D1.80.D0.B0"><span class="tocnumber">1.22.1</span> <span class="toctext">Модель кассира</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-36"><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><span class="tocnumber">1.23</span> <span class="toctext">Резюме</span></a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>
<h1><span class="mw-headline" id=".D0.9F.D0.90.D0.A0.D0.90.D0.9B.D0.9B.D0.95.D0.9B.D0.AC.D0.9D.D0.9E.D0.95_.D0.92.D0.AB.D0.9F.D0.9E.D0.9B.D0.9D.D0.95.D0.9D.D0.98.D0.95"><b>ПАРАЛЛЕЛЬНОЕ ВЫПОЛНЕНИЕ</b></span></h1>
<p>До настоящего момента мы имели дело исключительно с последовательным 
программированием. Все действия, выполняемые программой, выполнялись 
друг за другом, то есть последовательно.
</p><p>Последовательное программирование способно решить многие задачи. 
Однако для некоторых задач бывает удобно (и даже необходимо) 
организовать параллельное выполнение нескольких частей программы, чтобы 
создать у пользователя впечатление одновременного выполнения этих 
частей, или — если на компьютере установлено несколько процессоров — 
чтобы они действительно выполнялись одновременно.
</p><p>Каждая из этих самостоятельных подзадач называется потоком (<i>thread</i>).
 Программа пишется так, словно каждый поток запускается сам по себе и 
использует процессор в монопольном режиме. На самом деле существует 
некоторый системный механизм, который обеспечивает совместное 
использованием процессора, но в основном думать об этом вам не придется.
 Модель потоков (и ее поддержка в языке <i>Java</i>) является программным механизмом, упрощающим одновременное выполнение нескольких операций в одной и той же программе. 
</p><p>Процессор периодически вмешивается в происходящие события, 
выделяя каждому потоку некоторой отрезок времени. Для каждого потока все
 выглядит так, словно процессор используется в монопольном режиме, но на
 самом деле время процессора разделяется между всеми существующими в 
программе потоками (исключение составляет ситуация, когда программа 
действительно выполняется на многопроцессорном компьютере). Однако при 
использовании потоков вам не нужно задумываться об этих тонкостях — код 
не зависит от того, на скольких процессорах вам придется работать. Таким
 образом, потоки предоставляют механизм масштабирования 
производительности — если программа работает слишком медленно, вы в 
силах легко ускорить ее, установив на компьютер дополнительные 
процессоры. Многозадачность и многопоточность являются, похоже, наиболее
 вескими причинами использования многопроцессорных систем.
</p>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D0.B4.D0.B0.D1.87.D0.B8">Задачи</span></h2>
<p>Программный поток представляет некоторую задачу или операцию, поэтому
 нам понадобятся средства для описания этой задачи. Их предоставляет 
интерфейс <i><b>Runnable</b></i>. Чтобы определить задачу, реализуйте <i><b>Runnable</b></i> и напишите метод <i><b>run()</b></i>, содержащий код выполнения нужных действий.
</p><p>Например, задача <i><b>LiftOff</b></i> выводит обратный отсчет перед стартом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/LiftOff.java</span>
<span class="co1">// Реализация интерфейса Runnable.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> LiftOff <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">protected</span> <span class="kw3">int</span> countDown = <span class="nu0">10</span><span class="sy0">;</span> <span class="co1">// Значение по умолчанию</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> taskCount = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = taskCount++<span class="sy0">;</span>
  <span class="kw2">public</span> LiftOff<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> LiftOff<span class="br0">(</span><span class="kw3">int</span> countDown<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">countDown</span> = countDown<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> status<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"#"</span> + id + <span class="st0">"("</span> +
      <span class="br0">(</span>countDown <span class="sy0">&gt;</span> <span class="nu0">0</span> <span class="sy0">?</span> countDown&nbsp;: <span class="st0">"Liftoff!"</span><span class="br0">)</span> + <span class="st0">"), "</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>countDown-- <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>status<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>По идентификатору <i><b>id</b></i> различаются экземпляры задачи. Поле объявлено с ключевым словом <i><b>final</b></i>, поскольку оно не будет изменяться после инициализации.
</p><p>Метод <i><b>run()</b></i> обычно содержит некоторый цикл, который
 продолжает выполняться до тех пор, пока не будет достигнуто некоторое 
завершающее условие. Следовательно, вы должны задать условие выхода из 
цикла (например, просто вернуть управление командой <i><b>return</b></i>). Часто <i><b>run()</b></i>
 выполняется в виде бесконечного цикла, а это означает, что при 
отсутствии завершающего условия выполнение будет продолжаться бесконечно
 (позднее в этой главе вы узнаете, как организовать безопасное 
завершение задач).
</p><p>Вызов статического метода <i><b>Thread.yield()</b></i> в <i><b>run</b></i>() обращен к планировщику потоков (часть потокового механизма <i>Java</i>,
 обеспечивающая переключение процессора между потоками). Фактически он 
означает, что очередная важная часть цикла была выполнена и теперь можно
 на время переключиться на другую задачу. Вызов <i><b>yield()</b></i> не
 обязателен, но в данном примере он обеспечивает более интересные 
результаты: вы с большей вероятностью увидите, что программный поток 
прерывает и возобновляет свою работу.
</p><p>В следующем примере метод <i><b>run()</b></i> не выделяется в отдельный программный поток, а просто вызывается напрямую в <i><b>main()</b></i> (впрочем, поток все же используется — тот, который всегда создается для <i><b>main()</b></i>):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/MainThread.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> MainThread <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    LiftOff launch = <span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    launch.<span class="me1">run</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
Класс, реализующий <i><b>Runnable</b></i>, должен содержать метод <i><b>run()</b></i>,
 но ничего особенного в этом методе нет — он не обладает никакими 
особыми потоковыми возможностями. Чтобы использовать многопоточное 
выполнение, необходимо явно связать задачу с потоком.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D0.B0.D1.81.D1.81_Thread">Класс Thread</span></h2>
<p>Традиционный способ преобразования объекта <i><b>Runnable</b></i> в задачу заключается в передаче его конструктору <i><b>Thread</b></i>. Следующий пример показывает, как организовать выполнение <i><b>LiftOff</b></i> с использованием <i><b>Thread</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/BasicThreads.java</span>
<span class="co1">// Простейший вариант использования класса Thread..</span>
<span class="kw2">public</span> <span class="kw2">class</span> BasicThreads <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">Thread</span> t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Waiting for LiftOff"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (90% match)
</p>
<pre>Waiting for LiftOff
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
Конструктору <i><b>Thread</b></i> передается только объект <i><b>Runnable</b></i>. Метод <i><b>start()</b></i> выполняет необходимую инициализацию потока, после чего вызов метода <i><b>run()</b></i> интерфейса <i><b>Runnable</b></i> запускает задачу на выполнение в новом потоке.
</p><p>Из выходных данных видно, что вызов <i><b>start()</b></i> быстро возвращает управление (сообщение «Waiting for LiftOff» появляется до завершения отсчета). В сущности, мы вызываем <i><b>LiftOff.run()</b></i>, а этот метод еще не завершил свое выполнение; но, поскольку <i><b>LiftOff.run()</b></i> выполняется в другом потоке, в потоке <i><b>main()</b></i> в это время можно выполнять другие операции. (Данная возможность не ограничивается потоком <i><b>main()</b></i> — любой поток может запустить другой поток.) Получается, что программа выполняет два метода сразу — <i><b>main()</b></i> и <i><b>LiftOff.run()</b></i>.
</p><p>В программе можно легко породить дополнительные потоки для выполнения дополнительных задач:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/MoreBasicThreads.java</span>
<span class="co1">// Добавление новых потоков.</span>
<span class="kw2">public</span> <span class="kw2">class</span> MoreBasicThreads <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Waiting for LiftOff"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>Waiting for LiftOff
#0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7), #1(7),
#2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5), #2(5), #3(5),
#4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2),
#1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), 
#1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!)
</pre>
<p>&lt;/spoiler&gt;
Из выходных данных видно, что задачи выполняются одновременно друг с 
другом, с поочередной активизацией и выгрузкой потоков. Переключение 
осуществляется автоматически планировщиком потоков. Если на компьютере 
установлено несколько процессоров, планировщик потоков автоматически 
распределяет потоки между разными процессорами.
</p><p>При разных запусках программы будут получены разные результаты, 
поскольку работа планировщика потоков недетерминирована. Более того, вы 
наверняка увидите значительные различия в результатах работы данной 
программы-примера, запуская ее на различных версиях пакета <i>JDK</i>. К примеру, предыдущие версии <i>JVM</i>
 не слишком часто выполняли квантование времени, соответственно, поток 1
 мог первым закончить свой цикл, затем все свои итерации произвел бы 
поток 2, и т. д. Фактически то же самое получилось бы, если бы 
вызывалась процедура, выполняющая все циклы одновременно, за тем 
исключением, что запуск совокупности потоков требует больших издержек. 
Более поздние версии <i>JDK</i> обеспечивают более качественное 
квантование, и каждый поток регулярно получает свою долю внимания. Как 
правило, Sun не упоминает о подобных изменениях, так что рассчитывать на
 определенные «правила поведения» потоков не стоит. Лучше всего при 
написании кода с потоками занять максимально консервативную позицию.
</p><p>Когда метод <i><b>main()</b></i> создает объекты-потоки <i><b>Thread</b></i>,
 он не сохраняет на них ссылки. Обычный объект, «забытый» таким образом,
 стал бы легкой добычей сборщика мусора, но только не объект-поток <i><b>Thread</b></i>. Каждый поток (<i><b>Thread</b></i>)
 са­мостоятельно «регистрирует» себя, то есть на самом деле ссылка на 
него где-то существует, и сборщик мусора не вправе удалить его объект.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D1.81.D0.BF.D0.BE.D0.BB.D0.BD.D0.B8.D1.82.D0.B5.D0.BB.D0.B8">Исполнители</span></h2>
<p>Исполнители (<i><b>executors</b></i>), появившиеся в библиотеке <i><b>java.util.concurrent</b></i> в <i>Java</i> <i>SE5</i>, упрощают многозадачное программирование за счет автоматизации управления объектами <i><b>Thread</b></i>.
 Они создают дополнительную логическую прослойку между клиентом и 
выполнением задачи; задача выполняется не напрямую клиентом, а 
промежуточным объектом. Исполнители позволяют управлять выполнением 
асинхронных задач без явного управления жизненным циклом потоков. Именно
 такой способ запуска задач рекомендуется использовать в <i>Java</i> <i>SE5/6</i>.
</p><p>Вместо явного создания объектов <i><b>Thread</b></i> в <i><b>MoreBasicThreads.java</b></i> мы можем воспользоваться исполнителем. Объект <i><b>LiftOff</b></i> умеет выполнять определенную операцию и предоставляет единственный метод для выполнения. Объект <i><b>ExecutorService</b></i> умеет создавать необходимый контекст для выполнения объектов <i><b>Runnable</b></i>. В следующем примере класс <i><b>CachedThreadPool</b></i> создает один поток для каждой задачи. Обратите внимание: объект <i><b>ExecutorService</b></i> создается статическим методом класса <i><b>Executors</b></i>, определяющим разновидность исполнителя:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/CachedThreadPool.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CachedThreadPool <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>#0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #3(8), #4(8),
#0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #3(6), #4(6), #0(4),
#1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #3(4), #4(4), #0(2), #1(3),
#2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #3(2), #4(2), #0(Liftoff!), #1(1),
#2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
Очень часто для создания и управления всеми задачами в системе достаточно одного исполнителя.
</p><p>Вызов <i><b>shutdown()</b></i> предотвращает передачу <i><b>Executor</b></i> новых задач. Текущий поток (в данном случае тот, в котором выполняется <i><b>main()</b></i>) продолжает выполняться со всеми задачами, переданными до вызова <i><b>shutdown()</b></i>. Работа программы прекращается после завершения всех задач в <i><b>Executor</b></i>.
</p><p><i><b>CachedThreadPool</b></i> в этом примере легко заменяется другим типом <i><b>Executor</b></i>. Например, в потоковом пуле фиксированного размера (<i><b>FixedThreadPool</b></i>) используется ограниченный набор потоков для выполнения переданных задач:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/FixedThreadPool.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FixedThreadPool <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// В аргументе конструктора передается количество потоков:</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newFixedThreadPool</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>#0(9), #0(8), #1(9), #2(9), #3(9), #4(9), #0(7), #1(8), #2(8), #3(8), #4(8),
#0(6), #1(7), #2(7), #3(7), #4(7), #0(5), #1(6), #2(6), #3(6), #4(6), #0(4),
#1(5), #2(5), #3(5), #4(5), #0(3), #1(4), #2(4), #3(4), #4(4), #0(2), #1(3),
#2(3), #3(3), #4(3), #0(1), #1(2), #2(2), #3(2), #4(2), #0(Liftoff!), #1(1),
#2(1), #3(1), #4(1), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
С <i><b>FixedThreadPool</b></i> дорогостоящая операция создания потоков 
выполняется только один раз, в самом начале, поэтому количество потоков 
остается фиксированным. Это способствует экономии времени, поскольку вам
 не приходится нести затраты, связанные с созданием потока, для каждой 
отдельной задачи. В системах, управляемых событиями, обеспечивается 
максимальная скорость выполнения обработчиков событий, так как они могут
 просто получить поток из пула. Перерасход ресурсов в такой схеме 
исключен, так как <i><b>FixedThreadPool</b></i> использует ограниченное количество объектов Thread.
</p><p>Исполнитель <i><b>SingleThreadExecutor</b></i> представляет собой аналог <i><b>FixedThreadPool</b></i>
 с одним потоком. Например, он может быть полезен для выполнения 
долгосрочных операций (скажем, прослушивания входящих подключений по 
сокету) и для коротких операций, выполняемых в отдельных потоках, — 
скажем, обновления локальных или удаленных журналов.
</p><p>Если <i><b>SingleThreadExecutor</b></i> передается более одной 
задачи, эти задачи ставятся в очередь, и каждая из них отрабатывает до 
завершения перед началом следующей задачи, причем все они используют 
один и тот же поток. В следующем примере мы видим, что задачи 
последовательно завершаются в порядке их поступления. Таким образом, <i><b>SingleThreadExecutor</b></i> организует последовательное выполнение поступающих задач и поддерживает свою (внутреннюю) очередь незавершенных задач.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SingleThreadExecutor.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SingleThreadExecutor <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec =
      <span class="kw47">Executors</span>.<span class="me1">newSingleThreadExecutor</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> LiftOff<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
#1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(Liftoff!),
#2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(Liftoff!),
#3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(Liftoff!),
#4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
Другой пример: допустим, имеется группа потоков, выполняющих операции с 
использованием файловой системы. Вы можете запустить эти задачи под 
управлением <i><b>SingleThreadExecutor</b></i>, чтобы в любой момент 
гарантированно вы­полнялось не более одной задачи. При таком подходе вам
 не придется возиться с синхронизацией доступа к общим ресурсам (без 
риска для целостности файловой системы). Возможно, в окончательной 
версии кода будет правильнее синхронизировать доступ к ресурсу (см. 
далее в этой главе), но <i><b>SingleThreadExecutor</b></i> позволит быстро организовать координацию доступа при построении рабочего прототипа.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D0.BE.D0.B7.D0.B2.D1.80.D0.B0.D1.82_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D0.B9_.D0.B8.D0.B7_.D0.B7.D0.B0.D0.B4.D0.B0.D1.87">Возврат значений из задач</span></h2>
<p>Интерфейс <i><b>Runnable</b></i> представляет отдельную задачу, 
которая выполняет некоторую работу, но не возвращает значения. Если вы 
хотите, чтобы задача возвращала значение, реализуйте интерфейс <i><b>Callable</b></i> вместо интерфейса <i><b>Runnable</b></i>. Пара­метризованный интерфейс <i><b>Callable</b></i>, появившийся в <i>Java</i> <i>SE5</i>, имеет параметр типа, представляющий возвращаемое значение метода <i><b>call()</b></i> (вместо <i><b>run()</b></i>), а для его вызова должен использоваться метод <i><b>ExecutorService.submit()</b></i>. Простой пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/CallableDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> TaskWithResult <span class="kw2">implements</span> <span class="kw47">Callable</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> id<span class="sy0">;</span>
  <span class="kw2">public</span> TaskWithResult<span class="br0">(</span><span class="kw3">int</span> id<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">id</span> = id<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> call<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"result of TaskWithResult "</span> + id<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CallableDemo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw47">Future</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span> results =
      <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw47">Future</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      results.<span class="me1">add</span><span class="br0">(</span>exec.<span class="me1">submit</span><span class="br0">(</span><span class="kw2">new</span> TaskWithResult<span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw47">Future</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> fs&nbsp;: results<span class="br0">)</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="co1">// Вызов get() блокируется до завершения;:</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>fs.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw2">return</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw47">ExecutionException</span> e<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
        exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>result of TaskWithResult 0
result of TaskWithResult 1
result of TaskWithResult 2
result of TaskWithResult 3
result of TaskWithResult 4
result of TaskWithResult 5
result of TaskWithResult 6
result of TaskWithResult 7
result of TaskWithResult 8
result of TaskWithResult 9
</pre>
<p>&lt;/spoiler&gt;
Метод <i><b>submit()</b></i> создает объект <i><b>Future</b></i>, параметризованный по типу результата, возвращаемому <i><b>Callable</b></i>. Вы можете обратиться к <i><b>Future</b></i> с запросом <i><b>isDone()</b></i>, чтобы узнать, завершена ли операция. После завершения задачи и появления ре­зультата производится его выборка методом <i><b>get()</b></i>. Если <i><b>get()</b></i> вызывается без предварительной проверки <i><b>isDone()</b></i>, вызов блокируется до появления результата. Также можно вызвать <i><b>get()</b></i> с интервалом тайм-аута.
</p><p>Перегруженный метод <i><b>Executors.callable()</b></i> получает <i><b>Runnable</b></i> и выдает <i><b>Callable. ExecutorService</b></i> содержит методы для выполнения коллекций объектов <i><b>Callable</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9E.D0.B6.D0.B8.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5">Ожидание</span></h2>
<p>Другим способом управления вашими потоками является вызов метода <i><b>sleep()</b></i>, который переводит поток в состояние ожидания на заданное количество миллисекунд. Если в классе <i><b>LiftOff</b></i> заменить вызов <i><b>yield()</b></i> на вызов метода <i><b>sleep()</b></i>, будет получен следующий результат:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SleepingTask.java</span>
<span class="co1">// Вызов sleep() для приостановки потока.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SleepingTask <span class="kw2">extends</span> LiftOff <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span>countDown-- <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>status<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Старый стиль.</span>
        <span class="co1">// Thread.sleep(l00);</span>
        <span class="co1">// Стиль Java SE5/6:</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> SleepingTask<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>#0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7),
#1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5),
#2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3),
#3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1),
#4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!),
</pre>
<p>&lt;/spoiler&gt;
Вызов метода <i><b>sleep()</b></i> может привести к исключению <i><b>InterruptedException</b></i>; перехват этого исключения продемонстрирован в <i><b>run()</b></i>. Поскольку исключения не распространяются по потокам обратно в <i><b>main()</b></i>, вы должны локально обработать любые исключения, возникающие внутри задачи.
</p><p>В <i>Java</i> <i>SE5</i> появилась новая версия <i><b>sleep()</b></i>, оформленная в виде метода класса <i><b>TimeUnit</b></i>;
 она продемонстрирована в приведенном примере. Она делает программу 
более наглядной, поскольку вы можете указать единицы измерения 
продолжительности задержки. Класс <i><b>TimeUnit</b></i> также может использоваться для выполнения преобразований, как будет показано далее в этой главе.
</p><p>На некоторых платформах задачи выполняются в порядке «идеального 
распределения» — от 0 до 4, затем снова от 4 до 0. Это вполне логично, 
поскольку после каждой команды вывода задача переходит в состояние 
ожидания, что позволяет планировщику потоков переключиться на другой 
поток. Тем не менее такое поведение зависит от базовой реализации 
потокового механизма, поэтому полагаться на него нельзя. Если вам 
потребуется управлять порядком выполнения задач, используйте средства 
синхронизации (см. далее) или же вообще откажитесь от использования 
потоков и напишите собственные функции синхронизации, которые передают 
управление друг другу в нужном порядке.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.BE.D1.80.D0.B8.D1.82.D0.B5.D1.82">Приоритет</span></h2>
<p>Приоритет (<i><b>priority</b></i>) потока сообщает планировщику 
информацию об относительной важности потока. Хотя порядок обращения 
процессора к существующему набору потоков и не детерминирован, если 
существует несколько приос­тановленных потоков, одновременно ожидающих 
запуска, планировщик сначала запустит поток с большим приоритетом. 
Впрочем, это не значит, что потоки с младшими приоритетами не 
выполняются вовсе (то есть тупиковых ситуаций из-за приоритетов не 
возникает). Потоки с более низкими приоритетами просто запускаются чуть 
реже.
</p><p>В подавляющем большинстве случаев все потоки должны выполняться 
со стандартным приоритетом. Любые попытки манипуляций с приоритетами 
обычно являются ошибкой.
</p><p>Следующий пример демонстрирует использование приоритетов. Приоритет существующего потока читается методом <i><b>getPriority()</b></i> и задается методом <i><b>setPriority()</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SimplePriorities.java</span>
<span class="co1">// Использование приоритетов потоков.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimplePriorities <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">double</span> d<span class="sy0">;</span> <span class="co1">// Без оптимизации </span>
  <span class="kw2">private</span> <span class="kw3">int</span> priority<span class="sy0">;</span>
  <span class="kw2">public</span> SimplePriorities<span class="br0">(</span><span class="kw3">int</span> priority<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">priority</span> = priority<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span> + countDown<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">setPriority</span><span class="br0">(</span>priority<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Высокозатратная, прерываемая операция:</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">100000</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
        d += <span class="br0">(</span><span class="kw21">Math</span>.<span class="me1">PI</span> + <span class="kw21">Math</span>.<span class="me1">E</span><span class="br0">)</span> / <span class="br0">(</span><span class="kw3">double</span><span class="br0">)</span>i<span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">%</span> <span class="nu0">1000</span> == <span class="nu0">0</span><span class="br0">)</span>
          <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span>
        <span class="kw2">new</span> SimplePriorities<span class="br0">(</span><span class="kw21">Thread</span>.<span class="me1">MIN_PRIORITY</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>
        <span class="kw2">new</span> SimplePriorities<span class="br0">(</span><span class="kw21">Thread</span>.<span class="me1">MAX_PRIORITY</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (70% match)
</p>
<pre>Thread[pool-1-thread-6,10,main]: 5
Thread[pool-1-thread-6,10,main]: 4
Thread[pool-1-thread-6,10,main]: 3
Thread[pool-1-thread-6,10,main]: 2
Thread[pool-1-thread-6,10,main]: 1
Thread[pool-1-thread-3,1,main]: 5
Thread[pool-1-thread-2,1,main]: 5
Thread[pool-1-thread-1,1,main]: 5
Thread[pool-1-thread-5,1,main]: 5
Thread[pool-1-thread-4,1,main]: 5
</pre>
<p>&lt;/spoiler&gt;
В этой версии метод <i><b>toString()</b></i> переопределяется и использует метод <i><b>Thread. toString()</b></i>, который выводит имя потока (его можно задать в конструкторе, но здесь имена автоматически генерируются в виде <i><b>pool-1-thread-1, pool-1-thread-2</b></i> и т. д.), приоритет и группу, к которой принадлежит поток. Переопределенная версия <i><b>toString()</b></i> также выводит обратный отсчет, выполняемый задачей. Обратите внимание: для получения ссылки на объект <i><b>Thread</b></i>, управляющий задачей, внутри самой задачи, следует вызвать метод <i><b>Thread.currentThread()</b></i>.
</p><p>Мы видим, что приоритет последнего потока имеет наивысший 
уровень, а все остальные потоки находятся на низшем уровне. Учтите, что 
приоритет задается в начале выполнения <i><b>run()</b></i>; задавать его в конструкторе бессмысленно, потому что <i><b>Executor</b></i> в этот момент еще не начал выполнять задачу.
</p><p>В метод <i><b>run()</b></i> были добавлены 100 000 достаточно 
затратных операций с плавающей запятой, включая суммирование и деление с
 числом двойной точности <i><b>double</b></i>. Переменная <i><b>d</b></i> была отмечена как <i><b>volatile</b></i>,
 чтобы компилятор не применял оптимизацию. Без этих вычислений вы не 
увидите эффекта установки различных приоритетов (попробуйте 
закомментировать цикл <i><b>for</b></i> с вычислениями). В процессе вычислений мы видим, что планировщик уделяет больше внимания потоку с приоритетом <i><b>MAX_PRIORITY</b></i>
 (по крайней мере, таково было поведение программы на машине под 
управлением Windows ХР). Несмотря даже на то, что вывод на консоль также
 является «дорогостоящей» операцией, с ним вы не увидите влияние уровней
 приоритетов, поскольку вывод на консоль не прерывается (иначе экран был
 бы заполнен несуразицей), в то время как математические вычисления, 
приведенные выше, прерывать допустимо. Вычисления выполняются достаточно
 долго, соответственно, механизм планирования потоков вмешивается в 
процесс и чередует потоки, проявляя при этом внимание к более 
приоритетным. Тем не менее для обеспечения переключения контекста в 
программе периодически выполняются команды <i><b>yield()</b></i>.
</p><p>В пакете <i>JDK</i> предусмотрено 10 уровней приоритетов, однако 
это не слишком хорошо согласуется с большинством операционных систем. К 
примеру, в Windows имеется 7 классов приоритетов, таким образом, их 
соотношение неочевидно (хотя в операционной системе Sun Solaris имеется 
231 уровней). Переносимость обеспечивается только использованием 
универсальных констант <i><b>МАХ_РRIORITY, NORM_PRIORITY и MIN_PRI0RITY</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.B4.D0.B0.D1.87.D0.B0_.D1.83.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F">Передача управления</span></h2>
<p>Если вы знаете, что в текущей итерации <i><b>run()</b></i> сделано 
все необходимое, вы можете подсказать механизму планирования потоков, 
что процессором теперь может воспользоваться другой поток. Эта подсказка
 (не более чем рекомендация; нет никакой гарантии, что планировщик 
потоков «прислушается» к ней) воплощается в форме вызова метода <i><b>yield()</b></i>. Вызывая <i><b>yield()</b></i>, вы сообщаете системе, что в ней могут выполняться другие потоки того же приоритета.
</p><p>В примере <i><b>LiftOff</b></i> метод <i><b>yield()</b></i> обеспечивает равномерное распределение вычислительных ресурсов между задачами <i><b>LiftOff</b></i>. Попробуйте закомментировать вызов <i><b>Thread.yield()</b></i> в <i><b>Lift0ff.run()</b></i> и проследите за различиями. И все же, в общем случае не стоит полагаться на <i><b>yield()</b></i> как на серьезное средство настройки вашего приложения.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D1.82.D0.BE.D0.BA.D0.B8-.D0.B4.D0.B5.D0.BC.D0.BE.D0.BD.D1.8B">Потоки-демоны</span></h2>
<p>Демоном называется поток, предоставляющий некоторый сервис, работая в
 фоновом режиме во время выполнения программы, но при этом не является 
ее неотъемлемой частью. Таким образом, когда все потоки не-демоны 
заканчивают свою деятельность, программа завершается. И наоборот, если 
существуют работающие потоки не-демоны, программа продолжает выполнение.
 Существует, например, поток не-демон, выполняющий метод <i><b>main()</b></i>.
</p>
 <div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SimpleDaemons.java</span>
<span class="co1">// Потоки-демоны не препятствуют завершению работы программы.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimpleDaemons <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
        print<span class="br0">(</span><span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span> + <span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"sleep() interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">Thread</span> daemon = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> SimpleDaemons<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      daemon.<span class="me1">setDaemon</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Необходимо вызвать перед start()</span>
      daemon.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"All daemons started"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">175</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>All daemons started
Thread[Thread-0,5,main] SimpleDaemons@530daa
Thread[Thread-1,5,main] SimpleDaemons@a62fc3
Thread[Thread-2,5,main] SimpleDaemons@89ae9e
Thread[Thread-3,5,main] SimpleDaemons@1270b73
Thread[Thread-4,5,main] SimpleDaemons@60aeb0
Thread[Thread-5,5,main] SimpleDaemons@16caf43
Thread[Thread-6,5,main] SimpleDaemons@66848c
Thread[Thread-7,5,main] SimpleDaemons@8813f2
Thread[Thread-8,5,main] SimpleDaemons@1d58aae
Thread[Thread-9,5,main] SimpleDaemons@83cc67
...
</pre>
<p>&lt;/spoiler&gt;
Чтобы назначить поток демоном, следует перед его запуском вызвать метод <i><b>setDaemon()</b></i>.
</p><p>После того как <i><b>main()</b></i> завершит свою работу, ничто 
не препятствует завершению программы, поскольку в процессе не работают 
другие потоки, кроме демонов. Чтобы результаты запуска всех 
потоков-демонов были более наглядными, поток <i><b>main()</b></i> на 
некоторое время погружается в «сон». Без этого вы увидели бы только 
часть результатов при создании демонов. (Поэкспериментируйте с вызовом <i><b>sleep()</b></i> для интервалов разной продолжительности.)
</p><p>В примере <i><b>SimpleDaemons.java</b></i> используется явное создание объектов <i><b>Thread</b></i>
 для установки их «демонского» флага. Вы также можете настроить атрибуты
 (демон, приоритет, имя) потоков, созданных исполнителем; для этого 
следует написать пользовательскую реализацию <i><b>ThreadFactory</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/DaemonThreadFactory.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DaemonThreadFactory <span class="kw2">implements</span> <span class="kw47">ThreadFactory</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw21">Thread</span> newThread<span class="br0">(</span><span class="kw21">Runnable</span> r<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">Thread</span> t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span>r<span class="br0">)</span><span class="sy0">;</span>
    t.<span class="me1">setDaemon</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> t<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Единственное отличие от обычной реализации <i><b>ThreadFactory</b></i> заключается в том, что в данном случае атрибут демона задается равным <i><b>true</b></i>. Теперь новый объект <i><b>DaemonThreadFactory</b></i> передается в аргументе <i><b>Executors.newCachedThreadPool()</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/DaemonFromFactory.java</span>
<span class="co1">// Использование ThreadFactory для создания демонов.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DaemonFromFactory <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
        print<span class="br0">(</span><span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span> + <span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span>
      <span class="kw2">new</span> DaemonThreadFactory<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> DaemonFromFactory<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"All daemons started"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Задержка</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Каждый статический метод создания <i><b>ExecutorService</b></i> перегружается для получения объекта <i><b>ThreadFactory</b></i>, который будет использоваться для создания новых потоков.
</p><p>Сделаем еще один шаг — создадим вспомогательный класс <i><b>DaemonThreadPoolExecutor</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/DaemonThreadPoolExecutor.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DaemonThreadPoolExecutor
<span class="kw2">extends</span> <span class="kw47">ThreadPoolExecutor</span> <span class="br0">{</span>
  <span class="kw2">public</span> DaemonThreadPoolExecutor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span><span class="nu0">0</span>, <span class="kw21">Integer</span>.<span class="me1">MAX_VALUE</span>, 60L, <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>,
      <span class="kw2">new</span> <span class="kw47">SynchronousQueue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>,
      <span class="kw2">new</span> DaemonThreadFactory<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Чтобы узнать, какие значения должны передаваться при вызове конструктора базового класса, я просто заглянул в исходный код <i><b>Executors.java</b></i>.
</p><p>Чтобы узнать, является ли поток демоном, вызовите метод <i><b>isDaemon()</b></i>.
 Если поток является демоном, то все потоки, которые он производит, 
также будут демонами, что и демонстрируется следующим примером:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Daemons.java</span>
<span class="co1">// Потоки, порождаемые демонами, также являются демонами</span>
<span class="co1">// Daemon threads spawn other daemon threads.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Daemon <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">Thread</span><span class="br0">[</span><span class="br0">]</span> t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> t.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      t<span class="br0">[</span>i<span class="br0">]</span> = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> DaemonSpawn<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      t<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      printnb<span class="br0">(</span><span class="st0">"DaemonSpawn "</span> + i + <span class="st0">" started, "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> t.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span>
      printnb<span class="br0">(</span><span class="st0">"t["</span> + i + <span class="st0">"].isDaemon() = "</span> +
        t<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">isDaemon</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> DaemonSpawn <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Daemons <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw21">Thread</span> d = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> Daemon<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    d.<span class="me1">setDaemon</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    d.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"d.isDaemon() = "</span> + d.<span class="me1">isDaemon</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Даем потокам-демонам завершить процесс запуска:</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>d.isDaemon() = true, DaemonSpawn 0 started, DaemonSpawn 1 started, DaemonSpawn 2 started,
DaemonSpawn 3 started, DaemonSpawn 4 started, DaemonSpawn 5 started, DaemonSpawn 6 started,
DaemonSpawn 7 started, DaemonSpawn 8 started, DaemonSpawn 9 started, t[0].isDaemon() = true,
t[1].isDaemon() = true, t[2].isDaemon() = true, t[3].isDaemon() = true, t[4].isDaemon() = true,
t[5].isDaemon() = true, t[6].isDaemon() = true, t[7].isDaemon() = true, t[8].isDaemon() = true,
t[9].isDaemon() = true,
</pre>
<p>&lt;/spoiler&gt;
Поток <i><b>Daemon</b></i> переводится в режим демона, а затем порождает
 группу новых потоков, которые явно не назначаются демонами, но при этом
 все равно оказываются ими. Затем <i><b>Daemon</b></i> входит в бесконечный цикл, на каждом шаге которого вызывается метод <i><b>yield()</b></i>, передающий управление другими процессам.
</p><p>Учтите, что потоки-демоны завершают свои методы <i><b>run()</b></i> без выполнения секций <i><b>finally</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/DaemonsDontRunFinally.java</span>
<span class="co1">// Потоки-демоны не выполняют секцию finally.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> ADaemon <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Starting ADaemon"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Exiting via InterruptedException"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"This should always run?"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DaemonsDontRunFinally <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw21">Thread</span> t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> ADaemon<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    t.<span class="me1">setDaemon</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Starting ADaemon
</pre>
<p>&lt;/spoiler&gt;
Запуск программы наглядно показывает, что секция <i><b>finally</b></i> не выполняется. С другой стороны, если закомментировать вызов <i><b>setDaemon()</b></i>, вы увидите, что секция <i><b>finally</b></i> была выполнена.
</p><p>Такое поведение верно, даже если из предыдущих описаний <i><b>finally</b></i>
 у вас сложилось обратное впечатление. Демоны завершаются «внезапно», 
при завершении последнего не-демона. Таким образом, сразу же при выходе 
из <i><b>main()</b></i> <i>JVM</i> немедленно прерывает работу всех 
демонов, не соблюдая никакие формальности. Невозможность корректного 
завершения демонов ограничивает возможности их применения. Обычно 
объекты <i><b>Executor</b></i> оказываются более удачным решением, потому что все задачи, находящиеся под управлением <i><b>Executor</b></i>, могут быть завершены одновременно.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82.D1.8B_.D0.BA.D0.BE.D0.B4.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F">Варианты кодирования</span></h2>
<p>Во всех предшествующих примерах все классы задач реализовали интерфейс <i><b>Runnable</b></i>. В очень простых случаях можно использовать альтернативное решение с прямым наследованием от <i><b>Thread</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SimpleThread.java</span>
<span class="co1">// Прямое наследование от класса Thread..</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimpleThread <span class="kw2">extends</span> <span class="kw21">Thread</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> threadCount = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> SimpleThread<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Store the thread name:</span>
    <span class="kw2">super</span><span class="br0">(</span><span class="kw21">Integer</span>.<span class="me1">toString</span><span class="br0">(</span>++threadCount<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    start<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"#"</span> + getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">"("</span> + countDown + <span class="st0">"), "</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw2">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw2">new</span> SimpleThread<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>#1(5), #1(4), #1(3), #1(2), #1(1), #2(5), #2(4), #2(3), #2(2), #2(1), #3(5),
#3(4), #3(3), #3(2), #3(1), #4(5), #4(4), #4(3), #4(2), #4(1), #5(5), #5(4),
#5(3), #5(2), #5(1),
</pre>
<p>&lt;/spoiler&gt;
Чтобы задать объектам <i><b>Thread</b></i> имена, вы вызываете соответствующий конструктор <i><b>Thread</b></i>. Имя читается в методе <i><b>toString()</b></i> при помощи <i><b>getName()</b></i>.
</p><p>Также иногда встречается идиома самоуправляемой реализации <i><b>Runnable</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SelfManaged.java</span>
<span class="co1">// Реализация Runnable. содержащая собственный объект Thread.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SelfManaged <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">Thread</span> t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> SelfManaged<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"("</span> + countDown + <span class="st0">"), "</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span>
        <span class="kw2">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw2">new</span> SelfManaged<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Thread-0(5), Thread-0(4), Thread-0(3), Thread-0(2), Thread-0(1), Thread-1(5), Thread-1(4),
Thread-1(3), Thread-1(2), Thread-1(1), Thread-2(5), Thread-2(4), Thread-2(3), Thread-2(2),
Thread-2(1), Thread-3(5), Thread-3(4), Thread-3(3), Thread-3(2), Thread-3(1), Thread-4(5),
Thread-4(4), Thread-4(3), Thread-4(2), Thread-4(1),
</pre>
<p>&lt;/spoiler&gt;
В целом происходящее не так уж сильно отличается от наследования от <i><b>Thread</b></i>,
 разве что синтаксис получается чуть более громоздким. Однако реализация
 интерфейса позволяет наследовать от другого класса, тогда как в 
варианте с <i><b>Thread</b></i> это невозможно.
</p><p>Обратите внимание на вызов <i><b>start()</b></i> в конструкторе. 
Приведенный пример очень прост, поэтому, скорее всего, в нем такое 
решение безопасно, но вы должны знать, что запуск потоков в конструкторе
 может создать изрядные проблемы — до завершения конструктора может быть
 запущена на выполнение другая задача, которая обратится к объекту в 
нестабильном состоянии. Это еще одна причина, по которой использование <i><b>Executor</b></i> предпочтительнее явного создания объектов <i><b>Thread</b></i>.
</p><p>Иногда бывает разумно спрятать потоковый код внутри класса с помощью внутреннего класса, как показано здесь:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/ThreadVariations.java</span>
<span class="co1">// Создание потоков с использованием внутренних классов..</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Using a named inner class:</span>
<span class="kw2">class</span> InnerThread1 <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> Inner inner<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">class</span> Inner <span class="kw2">extends</span> <span class="kw21">Thread</span> <span class="br0">{</span>
    Inner<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">super</span><span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
      start<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
          sleep<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
        print<span class="br0">(</span><span class="st0">"interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span> + countDown<span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> InnerThread1<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    inner = <span class="kw2">new</span> Inner<span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Используем безымянный внутренний класс::</span>
<span class="kw2">class</span> InnerThread2 <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">Thread</span> t<span class="sy0">;</span>
  <span class="kw2">public</span> InnerThread2<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span>name<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">try</span> <span class="br0">{</span>
          <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
            print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
            sleep<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
        <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="st0">"sleep() interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">return</span> getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span> + countDown<span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
    t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Используем именованную реализацию Runnable:</span>
<span class="kw2">class</span> InnerRunnable1 <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> Inner inner<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">class</span> Inner <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw21">Thread</span> t<span class="sy0">;</span>
    Inner<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
      t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">this</span>, name<span class="br0">)</span><span class="sy0">;</span>
      t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
          <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
        print<span class="br0">(</span><span class="st0">"sleep() interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> t.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span> + countDown<span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> InnerRunnable1<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    inner = <span class="kw2">new</span> Inner<span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Используем анонимную реализацию Runnable:</span>
<span class="kw2">class</span> InnerRunnable2 <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">Thread</span> t<span class="sy0">;</span>
  <span class="kw2">public</span> InnerRunnable2<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw21">Runnable</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">try</span> <span class="br0">{</span>
          <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
            print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
            <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
        <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="st0">"sleep() interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">return</span> <span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span> +
          <span class="st0">": "</span> + countDown<span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>, name<span class="br0">)</span><span class="sy0">;</span>
    t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Отдельный метод для выполнения кода в потоке:</span>
<span class="kw2">class</span> ThreadMethod <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> countDown = <span class="nu0">5</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">Thread</span> t<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
  <span class="kw2">public</span> ThreadMethod<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">name</span> = name<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> runTask<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>t == <span class="kw4">null</span><span class="br0">)</span> <span class="br0">{</span>
      t = <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span>name<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          <span class="kw2">try</span> <span class="br0">{</span>
            <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
              print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
              <span class="kw1">if</span><span class="br0">(</span>--countDown == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
              sleep<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="br0">}</span>
          <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
            print<span class="br0">(</span><span class="st0">"sleep() interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="br0">}</span>
        <span class="br0">}</span>
        <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          <span class="kw2">return</span> getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span> + countDown<span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span><span class="sy0">;</span>
      t.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ThreadVariations <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">new</span> InnerThread1<span class="br0">(</span><span class="st0">"InnerThread1"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> InnerThread2<span class="br0">(</span><span class="st0">"InnerThread2"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> InnerRunnable1<span class="br0">(</span><span class="st0">"InnerRunnable1"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> InnerRunnable2<span class="br0">(</span><span class="st0">"InnerRunnable2"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> ThreadMethod<span class="br0">(</span><span class="st0">"ThreadMethod"</span><span class="br0">)</span>.<span class="me1">runTask</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p><i><b>InnerThread1</b></i> определяет именованный внутренний класс, производный от <i><b>Thread</b></i>,
 и создает экземпляр этого класса в конструкторе. Поступать так стоит в 
том случае, когда у внутреннего класса есть особые возможности (новые 
методы), которые могут понадобиться в других методах. Однако в 
большинстве случаев причина создания потока — использование 
функциональности класса <i><b>Thread</b></i>, поэтому в именованном внутреннем классе особой нужды нет. <i><b>InnerThread2</b></i> показывает другое решение. В конструкторе создается безымянный внутренний субкласс <i><b>Thread</b></i>, преобразуемый восходящим преобразованием к ссылке на <i><b>Thread.t</b></i>. Если другим методам класса понадобится обратиться к <i><b>t</b></i>, они смогут сделать это через интерфейс <i><b>Thread</b></i>, и им не нужно будет знать точный тип объекта.
</p><p>Третий и четвертый классы примера повторяют первые два, только вместо класса <i><b>Thread</b></i> они используют интерфейс <i><b>Runnable</b></i>.
</p><p>Класс <i><b>ThreadMethod</b></i> демонстрирует создание потока в 
методе. Вы вызываете метод, когда программа готова к запуску потока, а 
метод возвращает управление после запуска потока. Если поток выполняет 
только вспомогательные операции и не является фундаментальной частью 
класса, то этот способ, вероятно, удобнее и практичнее запуска потока из
 конструктора класса.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D1.81.D0.BE.D0.B5.D0.B4.D0.B8.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D1.83">Присоединение к потоку</span></h2>
<p>Любой поток может вызвать метод <i><b>join()</b></i>, чтобы дождаться завершения другого потока перед своим продолжением. Если поток вызывает <i><b>t.join()</b></i> для другого потока t, то вызывающий поток приостанавливается до тех пор, пока целевой поток <i><b>t</b></i> не завершит свою работу (когда метод <i><b>t.isAlive()</b></i> вернет значение <i><b>false</b></i>).
</p><p>Вызвать метод <i><b>join()</b></i> можно также и с аргументом, 
указывающим продолжительность ожидания (в миллисекундах или в 
миллисекундах с наносекундами). Если целевой поток не закончит работу за
 означенный период времени, метод <i><b>join()</b></i> все равно вернет управление инициатору.
</p><p>Вызов <i><b>join()</b></i> может быть прерван вызовом метода <i><b>interrupt()</b></i> для потока-инициатора, поэтому потребуется блок <i><b>try-catch</b></i>.
</p><p>Все эти операции продемонстрированы в следующем примере:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Joining.java</span>
<span class="co1">// Демонстрация join().</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Sleeper <span class="kw2">extends</span> <span class="kw21">Thread</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> duration<span class="sy0">;</span>
  <span class="kw2">public</span> Sleeper<span class="br0">(</span><span class="kw21">String</span> name, <span class="kw3">int</span> sleepTime<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
    duration = sleepTime<span class="sy0">;</span>
    start<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      sleep<span class="br0">(</span>duration<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span>getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">" was interrupted. "</span> +
        <span class="st0">"isInterrupted(): "</span> + isInterrupted<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    print<span class="br0">(</span>getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">" has awakened"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Joiner <span class="kw2">extends</span> <span class="kw21">Thread</span> <span class="br0">{</span>
  <span class="kw2">private</span> Sleeper sleeper<span class="sy0">;</span>
  <span class="kw2">public</span> Joiner<span class="br0">(</span><span class="kw21">String</span> name, Sleeper sleeper<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">sleeper</span> = sleeper<span class="sy0">;</span>
    start<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="kw2">try</span> <span class="br0">{</span>
      sleeper.<span class="me1">join</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    print<span class="br0">(</span>getName<span class="br0">(</span><span class="br0">)</span> + <span class="st0">" join completed"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Joining <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Sleeper
      sleepy = <span class="kw2">new</span> Sleeper<span class="br0">(</span><span class="st0">"Sleepy"</span>, <span class="nu0">1500</span><span class="br0">)</span>,
      grumpy = <span class="kw2">new</span> Sleeper<span class="br0">(</span><span class="st0">"Grumpy"</span>, <span class="nu0">1500</span><span class="br0">)</span><span class="sy0">;</span>
    Joiner
      dopey = <span class="kw2">new</span> Joiner<span class="br0">(</span><span class="st0">"Dopey"</span>, sleepy<span class="br0">)</span>,
      doc = <span class="kw2">new</span> Joiner<span class="br0">(</span><span class="st0">"Doc"</span>, grumpy<span class="br0">)</span><span class="sy0">;</span>
    grumpy.<span class="me1">interrupt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Grumpy was interrupted. isInterrupted(): false
Doc join completed
Sleepy has awakened
Dopey join completed
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Sleeper</b></i> — это тип потока, который приостанавливается на время, указанное в его конструкторе. В методе <i><b>run()</b></i> вызов метода <i><b>sleep()</b></i> может закончиться по истечении времени задержки, но может и прерваться. В секции <i><b>catch</b></i> выводится сообщение о прерывании, вместе со значением, возвращаемым методом <i><b>isInterrupted()</b></i>. Когда другой поток вызывает <i><b>interrupt()</b></i>
 для данного потока, устанавливается флаг, показывающий, что поток был 
прерван. Однако этот флаг сбрасывается при обработке исключения, поэтому
 внутри секции <i><b>catch</b></i> результатом всегда будет <i><b>false</b></i>. Флаг используется в других ситуациях, где поток может исследовать свое прерванное состояние в стороне от исключения.
</p><p><i><b>Joiner</b></i> — поток, который ожидает пробуждения потока <i><b>Sleeper</b></i>, вызывая для последнего метод <i><b>join()</b></i>. В методе <i><b>main()</b></i> каждому объекту <i><b>Joiner</b></i> сопоставляется <i><b>Sleeper</b></i>, и вы можете видеть в результатах работы программы, что, если <i><b>Sleeper</b></i> был прерван или завершился нормально, <i><b>Joiner</b></i> прекращает работу вместе с потоком <i><b>Sleeper</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.BD.D0.BE.D0.B5_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.80.D0.B5.D1.81.D1.83.D1.80.D1.81.D0.BE.D0.B2">Совместное использование ресурсов</span></h2>
<p>Однопоточную программу можно представить в виде одинокого работника, 
передвигающегося по своему пространству задачи и выполняющего по одной 
операции за один раз. Раз работник один, вам не приходится принимать во 
внимание проблему двух сущностей, пытающихся оспорить право на один и 
тот же ресурс, подобно двум людям, которые хотят одновременно поставить 
машину в одном месте, вдвоем пройти в одну дверь или даже говорить 
одновременно.
</p><p>В условиях многозадачности ситуация меняется: у вас есть сразу 
два или три потока, которые стремятся получить доступ к одному и тому же
 ограниченному ресурсу. Если не предотвратить подобные конфликты, два 
потока могут попытаться получить доступ к одному счету в банке, 
одновременно распечатать два документа на одном принтере, изменить одно и
 то же значение, и т. п.
</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.BA.D0.BE.D1.80.D1.80.D0.B5.D0.BA.D1.82.D0.BD.D1.8B.D0.B9_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF_.D0.BA_.D1.80.D0.B5.D1.81.D1.83.D1.80.D1.81.D0.B0.D0.BC">Некорректный доступ к ресурсам</span></h3>
<p>Рассмотрим следующий пример, в котором одна задача генерирует четные 
числа, а другие задачи эти числа потребляют. Единственной задачей 
задач-потребителей является проверка четности этих чисел.
</p><p>Начнем с определения <i><b>EvenChecker</b></i>, задачи-потребителя, поскольку она будет использоваться во всех последующих примерах. Чтобы отделить <i><b>EvenChecker</b></i> от различных генераторов, с которыми мы будем экспериментировать, мы опре­делим абстрактный класс <i><b>IntGenerator</b></i>, содержащий минимум необходимых методов для <i><b>EvenChecker</b></i>: метод для получения следующего значения <i><b>next()</b></i> и методы отмены. Класс не реализует интерфейс <i><b>Generator</b></i>, потому что он должен выдавать <i><b>int</b></i>, а параметризация не поддерживает примитивные параметры.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/IntGenerator.java</span>
<span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw2">class</span> IntGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">boolean</span> canceled = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw3">int</span> next<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// Allow this to be canceled:</span>
  <span class="kw2">public</span> <span class="kw3">void</span> cancel<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> canceled = <span class="kw4">true</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">boolean</span> isCanceled<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> canceled<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><i><b>IntGenerator</b></i> содержит метод <i><b>cancel()</b></i>, изменяющий состояние флага <i><b>canceled</b></i>, и метод <i><b>isCanceled()</b></i>, проверяющий, был ли объект отменен. Поскольку флаг <i><b>canceled</b></i> относится к типу <i><b>boolean</b></i>,
 простые операции вроде присваивания и возврата значения выполняются 
атомарно, то есть без возможности прерывания, и вы не увидите поле в 
промежуточном состоянии между этими простыми операциями. Смысл ключевого
 слова <i><b>volatile</b></i> будет объяснен позже в этой главе.
</p><p>Для тестирования <i><b>IntGenerator</b></i> можно воспользоваться следующим классом <i><b>EvenChecker</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/EvenChecker.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> EvenChecker <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> IntGenerator generator<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id<span class="sy0">;</span>
  <span class="kw2">public</span> EvenChecker<span class="br0">(</span>IntGenerator g, <span class="kw3">int</span> ident<span class="br0">)</span> <span class="br0">{</span>
    generator = g<span class="sy0">;</span>
    id = ident<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span>generator.<span class="me1">isCanceled</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">int</span> val = generator.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>val + <span class="st0">" not even!"</span><span class="br0">)</span><span class="sy0">;</span>
        generator.<span class="me1">cancel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Отмена всех EvenChecker</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// Тестирование произвольного типа IntGenerator:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> test<span class="br0">(</span>IntGenerator gp, <span class="kw3">int</span> count<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Press Control-C to exit"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> count<span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> EvenChecker<span class="br0">(</span>gp, i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Значение по умолчанию для count:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> test<span class="br0">(</span>IntGenerator gp<span class="br0">)</span> <span class="br0">{</span>
    test<span class="br0">(</span>gp, <span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Как видно из run(), все задачи <i><b>EvenChecker</b></i>, зависящие от объекта <i><b>IntGenerator</b></i>, проверяют, не были ли они отменены. При таком подходе задачи, совместно использующие общий ресурс (<i><b>IntGenerator</b></i>),
 наблюдают за ресурсом, ожидая от него сигнала завершения. Тем самым 
устраняется так называемая «ситуация гонки», когда две и более задачи 
торопятся отреагировать на некоторое условие; это приводит к 
возникновению конфликтов или получению других некорректных результатов. 
Будьте внимательны, постарайтесь продумать все возможные сбои в системах
 с параллельным выполнением и защититься от них. Например, задача не 
может зависеть от другой задачи, потому что порядок завершения задач не 
гарантирован. Зависимость задач от объекта, не являющегося задачей, 
устраняет потенциальную «ситуацию гонки».
</p><p>Метод <i><b>test()</b></i> настраивает и тестирует произвольный тип <i><b>IntGenerator</b></i>, запуская несколько задач <i><b>EvenChecker</b></i> с общим <i><b>IntGenerator</b></i>. Если <i><b>IntGenerator</b></i> приводит к сбою, <i><b>test()</b></i> сообщает о происходящем и возвращает управление. В противном случае его следует завершить вручную клавишами Ctrl+C.
</p><p>Задачи <i><b>EvenChecker</b></i> постоянно читают и проверяют значения, полученные от <i><b>IntGenerator</b></i>. Если <i><b>generator.isCanceled()</b></i> равен <i><b>true, run()</b></i> возвращает управление; это сообщает <i><b>Executor</b></i> в <i><b>EvenChecker.test()</b></i> о том, что задача завершена. Любая задача <i><b>EvenChecker</b></i> может вызвать <i><b>cancel()</b></i> для связанного с ней <i><b>IntGenerator</b></i>, в результате чего все остальные <i><b>EvenChecker</b></i>, использующие <i><b>IntGenerator</b></i>, будут корректно завершены. Как будет показано далее в этой главе, в <i>Java</i> существуют и более общие механизмы завершения потоков.
</p><p>В первом варианте IntGenerator, который мы рассмотрим, next() выдает серию четных значений:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/EvenGenerator.java</span>
<span class="co1">// Конфликт потоков.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> EvenGenerator <span class="kw2">extends</span> IntGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> currentEvenValue = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">int</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    ++currentEvenValue<span class="sy0">;</span>  <span class="co1">// Опасная точка!</span>
    ++currentEvenValue<span class="sy0">;</span>
    <span class="kw2">return</span> currentEvenValue<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    EvenChecker.<span class="me1">test</span><span class="br0">(</span><span class="kw2">new</span> EvenGenerator<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
Нажмите Control-С, чтобы завершить программу
</p>
<pre>89476993 not even!
89476993 not even!
</pre>
<p>&lt;/spoiler&gt;
Одна задача может вызвать <i><b>next()</b></i> после того, как другая задача выполнит первый инкремент <i><b>currentEvenValue</b></i>,
 но до второго инкремента (в позиции, помеченной комментарием «Опасная 
точка!»). При этом значение оказывается в «некорректном» состоянии. 
Чтобы доказать, что такое возможно, <i><b>EvenChecker. test()</b></i> создает группу объектов <i><b>EvenChecker</b></i>, которые непрерывно читают результаты <i><b>EvenGenerator</b></i> и проверяют их на четность. При обнаружении нечетного числа выводится сообщение об ошибке, и программа завершается.
</p><p>Сбой рано или поздно произойдет, потому что задачи <i><b>EvenChecker</b></i> могут обратиться к информации <i><b>EvenGenerator</b></i> в «некорректном» состоянии. Впрочем, проблема может проявиться лишь после многих циклов отработки <i><b>EvenGenerator</b></i>;
 все зависит от особенностей операционной системы и других подробностей 
реализации. Чтобы ускорить наступление сбоя, попробуйте разместить вызов
 <i><b>yield()</b></i> между инкрементами. В этом и состоит одна из 
проблем многопоточного про­граммирования: программа, содержащая ошибку, 
на первый взгляд работает вполне нормально — а все потому, что 
вероятность сбоя очень мала.
</p><p>Также стоит учитывать, что сама операция инкремента состоит из 
нескольких шагов и может быть прервана планировщиком потоков в ходе 
выполнения — другими словами, инкремент в <i>Java</i> не является 
атомарной операцией. Даже простое приращение переменной может оказаться 
небезопасным, если не организовать защиту задачи.
</p>
<h3><span class="mw-headline" id=".D0.A0.D0.B0.D0.B7.D1.80.D0.B5.D1.88.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.BD.D1.84.D0.BB.D0.B8.D0.BA.D1.82.D0.BE.D0.B2_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.B0">Разрешение конфликтов доступа</span></h3>
<p>Предыдущий пример показательно иллюстрирует основную проблему 
потоков: вы никогда не знаете, когда поток будет выполняться. 
Вообразите, что вы сидите за столом с вилкой в руках, собираетесь съесть
 последний, самый лакомый кусочек, который лежит на тарелке прямо перед 
вами. Но, как только вы тянетесь к еде вилкой, она исчезает (как ваш 
поток был внезапно приостановлен, и другой поток не постеснялся 
«стянуть» у вас еду). Вот такую проблему нам приходится решать при 
написании выполняемых одновременно и использующих общие ресурсы 
программ. Чтобы многопоточность работала, необходим механизм, 
предотвращающий возможность состязания двух потоков за один ресурс (по 
крайней мере, во время критичных операций).
</p><p>Предотвратить такое столкновение интересов несложно — надо 
блокировать ресурс для других потоков, пока он находится в ведении 
одного потока. Первый поток, получивший доступ к ресурсу, вешает на него
 «замок», и тогда все остальные потоки не смогут получить этот ресурс до
 тех пор, пока «замок» не будет снят, и только после этого другой поток 
овладеет ресурсом и заблокирует его, и т. д. Если переднее сиденье 
машины является для детей ограниченным ресурсом, то ребенок, первым 
крикнувший «Чур, я спереди!», отстоял свое право на «блокировку».
</p><p>Для решения проблемы соперничества потоков фактически все 
многопоточные схемы синхронизируют доступ к разделяемым ресурсам. Это 
означает, что доступ к разделяемому ресурсу в один момент времени может 
получить только один поток. Чаще всего это выполняется помещением 
фрагмента кода в секцию блокировки так, что одновременно пройти по этому
 фрагменту кода может только один поток. Поскольку такое предложение 
блокировки дает эффект взаимного исключения, этот механизм часто 
называют мьютексом (MUTual Exclusion).
</p><p>Вспомните свою ванную комнату — несколько людей (потоки) могут 
захотеть эксклюзивно владеть ей (разделяемым ресурсом). Чтобы получить 
доступ в ванную, человек стучится в дверь, желая проверить, не занята ли
 она. Если ванная свободна, он входит в нее и запирает дверь. Любой 
другой поток, желающий оказаться внутри, «блокируется» в этом действии, и
 ему приходится ждать у двери, пока ванная не освободится.
</p><p>Аналогия немного нарушается, когда дверь в ванную комнату снова 
открывается, и приходит время передать доступ другому потоку. Как люди 
на самом деле не становятся в очередь, так и здесь мы точно не знаем, 
кто «зайдет в ванную» следующим, потому что поведение планировщика 
потоков недетерминировано. Существует гипотетическая группа 
блокированных потоков, толкущихся у двери, и, когда поток, который 
занимал «ванную», разблокирует ее и уйдет, тот поток, что окажется ближе
 всех к двери, «войдет» в нее. Как уже было замечено, планировщику можно
 давать подсказки методами <i><b>yield()</b></i> и <i><b>setPriority()</b></i>, но эти подсказки необязательно будут иметь эффект, в зависимости от вашей платформы и реализации виртуальной машины <i>JVM</i>.
</p><p>В <i>Java</i> есть встроенная поддержка для предотвращения конфликтов в виде ключевого слова <i><b>synchronized</b></i>. Когда поток желает выполнить фрагмент кода, охраняемый словом <i><b>synchronized</b></i>, он проверяет, доступен ли семафор, получает доступ к семафору, выполняет код и освобождает семафор.
</p><p>Разделяемый ресурс чаще всего является блоком памяти, 
представляющим объект, но это также может быть файл, порт ввода/вывода 
или устройство (скажем, принтер). Для управления доступом к разделяемому
 ресурсу вы сначала помещаете его внутрь объекта. После этого любой 
метод, получающий доступ к ресурсу, может быть объявлен как <i><b>synchronized</b></i>. Это означает, что, если задача выполняется внутри одного из объявленных как <i><b>synchronized</b></i> методов, все ос­тальные потоки не сумеют зайти ни в какой <i><b>synchronized</b></i>-метод до тех пор, пока первый поток не вернется из своего вызова.
</p><p>Как известно, в окончательной версии кода поля класса обычно объявляются закрытыми (<i><b>private</b></i>),
 а доступ к их памяти осуществляется только посредством методов. Чтобы 
предотвратить конфликты, объявите такие методы синхро­низированными (с 
помощью ключевого слова <i><b>synchronized</b></i>):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">synchronized</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* .. */</span> <span class="br0">}</span>
 <span class="kw2">synchronized</span> <span class="kw3">void</span> g<span class="br0">(</span><span class="br0">)</span><span class="br0">{</span> <span class="coMULTI">/*.. */</span> <span class="br0">}</span></pre></div></div>
<p>Каждый объект содержит объект простой блокировки (также называемый монитором). При вызове любого синхронизированного (<i><b>synchronized</b></i>)
 метода объект переходит в состояние блокировки, и пока этот метод не 
закончит свою работу и не снимет блокировку, другие синхронизированные 
методы для объекта не могут быть вызваны. В только что рассмотренном 
примере, если для объекта вызывается метод <i><b>f()</b></i>, метод <i><b>g()</b></i> не будет вызван до тех пор, пока метод <i><b>f()</b></i>
 не завершит свою работу и не сбросит блокировку. Таким образом, монитор
 совместно используется всеми синхронизированными методами определенного
 объекта и предотвращает использование общей памяти несколькими потоками
 одновременно.
</p><p>Один поток может блокировать объект многократно. Это происходит, 
когда метод вызывает другой метод того же объекта, который, в свою 
очередь, вызывает еще один метод того же объекта, и т. д. Виртуальная 
машина <i>JVM</i> следит за тем, сколько раз объект был заблокирован. 
Если объект не блокировался, его счетчик равен нулю. Когда задача 
захватывает объект в первый раз, счетчик увеличивается до единицы. 
Каждый раз, когда задача снова овладевает объектом блокировки того же 
объекта, счетчик увеличивается. Естественно, что все это разрешается 
только той задаче, которая инициировала первичную блокировку. При выходе
 задачи из синхронизированного метода счетчик уменьшается на единицу до 
тех пор, пока не делается равным нулю, после чего объект блокировки 
данного объекта становится доступен другим потокам.
</p><p>Также существует отдельный монитор для класса (часть объекта <i><b>Class</b></i>), который следит за тем, чтобы статические (<i><b>static</b></i>) синхронизированные (<i><b>synchronized</b></i>) методы не использовали одновременно общие статические данные класса.
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B4.D0.BB.D1.8F_.D0.BF.D1.80.D0.B8.D0.BC.D0.B5.D1.80.D0.B0_EvenGenerator">Синхронизация для примера EvenGenerator</span></h3>
<p>Включив в программу <i><b>EvenGenerator.java</b></i> поддержку <i><b>synchronized</b></i>, мы можем предотвратить нежелательный доступ со стороны потоков:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SynchronizedEvenGenerator.java</span>
<span class="co1">// Упрощение работы с мьютексами с использованием</span>
<span class="co1">// ключевого слова synchronized.</span>
<span class="co1">// {RunByHand}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span>
SynchronizedEvenGenerator <span class="kw2">extends</span> IntGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> currentEvenValue = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">int</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    ++currentEvenValue<span class="sy0">;</span>
    <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Ускоряем сбой</span>
    ++currentEvenValue<span class="sy0">;</span>
    <span class="kw2">return</span> currentEvenValue<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    EvenChecker.<span class="me1">test</span><span class="br0">(</span><span class="kw2">new</span> SynchronizedEvenGenerator<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Вызов <i><b>Thread.yield()</b></i> между двумя инкрементами повышает вероятность переключения контекста при нахождении <i><b>currentEvenValue</b></i> в нечетном состоянии. Так как мьютекс позволяет выполнять критическую секцию не более чем одной задаче, сбоев не будет.
</p><p>Первая задача, входящая в <i><b>next()</b></i>, устанавливает 
блокировку, а все остальные задачи, пытающиеся ее установить, 
блокируются до момента снятия блокировки первой задачей. В этой точке 
механизм планирования выбирает другую задачу, ожидающую блокировки. 
Таким образом, в любой момент времени только одна задача может проходить
 по коду, защищенному мьютексом.
</p>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D1.8B_Lock">Объекты Lock</span></h3>
<p>Библиотека <i>Java</i> <i>SE5</i> <i><b>java.utiLconcurrent</b></i> также содержит явный механизм управления мьютексами, определенный в <i><b>java.util.concurrent.locks</b></i>. Объект <i><b>Lock</b></i>
 можно явно создать в программе, установить или снять блокировку; 
правда, полученный код будет менее элегантным, чем при использовании 
встроенной формы. С другой стороны, он обладает большей гибкостью при 
решении некоторых типов задач. Вот как выглядит пример <i><b>SynchronizedEvenGenerator.java</b></i> с явным использо­ванием объектов <i><b>Lock</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/MutexEvenGenerator.java</span>
<span class="co1">// Предотвращение потоковых конфликтов с использованием мьютексов.</span>
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.locks.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> MutexEvenGenerator <span class="kw2">extends</span> IntGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> currentEvenValue = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw49">Lock</span> lock = <span class="kw2">new</span> <span class="kw49">ReentrantLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">int</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    lock.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      ++currentEvenValue<span class="sy0">;</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Ускоряем сбой</span>
      ++currentEvenValue<span class="sy0">;</span>
      <span class="kw2">return</span> currentEvenValue<span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      lock.<span class="me1">unlock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    EvenChecker.<span class="me1">test</span><span class="br0">(</span><span class="kw2">new</span> MutexEvenGenerator<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><i><b>MutexEvenGenerator</b></i> добавляет мьютекс с именем <i><b>lock</b></i> и использует методы <i><b>lock()</b></i> и <i><b>unlock()</b></i> для создания критической секции в <i><b>next()</b></i>. При использовании объектов <i><b>Lock</b></i> следует применять идиому, показанную в примере: сразу же за вызовом <i><b>lock()</b></i> необходимо разместить конструкцию <i><b>try-finally</b></i>, при этом в секцию <i><b>finally</b></i> включается вызов <i><b>unlock()</b></i> — только так можно гарантировать снятие блокировки.
</p><p>Хотя <i><b>try-finally</b></i> требует большего объема кода, чем ключевое слово <i><b>synchronized</b></i>, явное использование объектов <i><b>Lock</b></i> обладает своими преимуществами. При возникновении проблем с ключевым словом <i><b>synchronized</b></i>
 происходит ис­ключение, но вы не получите возможность выполнить 
завершающие действия, чтобы сохранить корректное состояние системы. При 
работе с объектами <i><b>Lock</b></i> можно сделать все необходимое в секции <i><b>finally</b></i>.
</p><p>В общем случае использование <i><b>synchronized</b></i> уменьшает
 объем кода, а также радикально снижает вероятность ошибки со стороны 
программиста, поэтому явные операции с объектами <i><b>Lock</b></i> обычно выполняются только при решении особых задач. Например, с ключевым словом <i><b>synchronized</b></i>
 нельзя попытаться получить блокировку с неудачным исходом или 
попытаться получить блокировку в течение некоторого промежутка времени с
 последующим отказом — в подобных случаях приходится использовать 
библиотеку <i><b>concurrent</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/AttemptLocking.java</span>
<span class="co1">// Объекты Lock из библиотеки concurrent делают возможными</span>
<span class="co1">// попытки установить блокировку в течение некоторого времени</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.locks.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> AttemptLocking <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw49">ReentrantLock</span> lock = <span class="kw2">new</span> <span class="kw49">ReentrantLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> untimed<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">boolean</span> captured = lock.<span class="me1">tryLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"tryLock(): "</span> + captured<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>captured<span class="br0">)</span>
        lock.<span class="me1">unlock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> timed<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">boolean</span> captured = <span class="kw4">false</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      captured = lock.<span class="me1">tryLock</span><span class="br0">(</span><span class="nu0">2</span>, <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"tryLock(2, TimeUnit.SECONDS): "</span> +
        captured<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>captured<span class="br0">)</span>
        lock.<span class="me1">unlock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">final</span> AttemptLocking al = <span class="kw2">new</span> AttemptLocking<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    al.<span class="me1">untimed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// True -- блокировка доступна </span>
    al.<span class="me1">timed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>   <span class="co1">// True -- блокировка доступна </span>
    <span class="co1">// Теперь создаем отдельную задачу для установления блокировки:</span>
    <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="br0">{</span> setDaemon<span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        al.<span class="me1">lock</span>.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"acquired"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Даем возможность 2-й задаче</span>
    al.<span class="me1">untimed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// False -- блокировка захвачена задачей </span>
    al.<span class="me1">timed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>   <span class="co1">// False -- блокировка захвачена задачей </span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>tryLock(): true
tryLock(2, TimeUnit.SECONDS): true
acquired
tryLock(): false
tryLock(2, TimeUnit.SECONDS): false
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>ReentrantLock</b></i> делает возможной попытку получения 
блокировки с последующим отказом от нее. Таким образом, если кто-то уже 
захватил блокировку, вы можете отказаться от своих намерений (вместо 
того, чтобы дожидаться ее освобождения). В методе <i><b>timed()</b></i> 
делается попытка установления блокировки, которая может завершиться 
неудачей через 2 секунды (обратите внимание на использование класса <i>Java</i> <i>SE5</i> <i><b>TimeUnit</b></i> для определения единиц времени). В <i><b>main()</b></i> отдельный объект <i><b>Thread</b></i> создается в виде безымянного класса и устанавливает блокировку, чтобы методы <i><b>untimed()</b></i> и <i><b>timed()</b></i> могли с чем-то конкурировать.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.90.D1.82.D0.BE.D0.BC.D0.B0.D1.80.D0.BD.D1.8B.D0.B5_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_volatile">Атомарные операции и ключевое слово volatile</span></h2>
<p>В дискуссиях, посвященных механизму потоков в <i>Java</i>, часто 
можно услышать такое утверждение: «Атомарные операции не требуют 
синхронизации». Атомарная операция — это операция, которую не может 
прервать планировщик потоков — если она начинается, то продолжается до 
завершения, без возможности переключения контекста (переключения 
выполнения на другой поток). Не полагайтесь на атомарность, она 
ненадежна и опасна — используйте ее вместо синхронизации только в том 
случае, если вы являетесь экспертом в области синхронизации или, по 
крайней мере, можете получить помощь от такого эксперта.
</p><p>Атомарные операции, упоминаемые в таких дискуссиях, включают в себя «простые операции» с примитивными типами, за исключением <i><b>long</b></i> и <i><b>double</b></i>.
</p><p>Чтение и запись примитивных переменных гарантированно выполняются как атомарные (неделимые) операции. С другой стороны, <i>JVM</i> разрешается выполнять чтение и запись 64-разрядных величин (<i><b>long</b></i> и <i><b>double</b></i>)
 в виде двух раздельных 32-разрядных операций, с ненулевой вероятностью 
переключения контекста в ходе чтения или записи. Для достижения 
атомарности (при простом присваивании и возврате значений) можно 
определить типы <i><b>long</b></i> и <i><b>double</b></i> с модификатором <i><b>volatile</b></i> (учтите, что до выхода <i>Java</i> <i>SE5</i> ключевое слово <i><b>volatile</b></i> не всегда работало корректно). Некоторые реализации <i>JVM</i> могут предоставлять более сильные гарантии, но вы не должны полагаться на платформенно-специфические возможности.
</p><p>В многопроцессорных системах (которые в наши дни представлены 
многоядерными процессорами, то есть несколькими процесорами на одном 
чипе) видимость (<i>visibility</i>) играет гораздо более важную роль, 
чем в однопроцессорных системах. Изменения, вносимые одной задачей, — 
даже атомарные в смысле невозможности прерывания — могут оставаться 
невидимыми для других задач (например, если изменения временно хранятся в
 локальном кэше процессора). Таким образом, разные задачи будут 
по-разному воспринимать состояние приложения. Механизм синхронизации 
обеспечивает распространение видимости изменений, вносимых одной задачей
 в многопроцессорной системе, по всему приложению. Без синхронизации 
невозможно заранее предсказать, когда именно изменения станут видимыми.
</p><p>Ключевое слово <i><b>volatile</b></i> обеспечивает видимость в рамках приложения. Если поле объявлено как <i><b>volatile</b></i>,
 это означает, что сразу же после записи в поле изменение будет отражено
 во всех последующих операциях чтения. Утверждение истинно даже при 
участии локальных кэшей — поля <i><b>volatile</b></i> немедленно записываются в основную память, и дальнейшее чтение происходит из основной памяти.
</p><p>Если слепо следовать концепции атомарности, можно заметить, что метод <i><b>getValue()</b></i> в следующем примере вроде бы отвечает этому описанию:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/AtomicityTest.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> AtomicityTest <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getValue<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> i<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> evenIncrement<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> i++<span class="sy0">;</span> i++<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
      evenIncrement<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    AtomicityTest at = <span class="kw2">new</span> AtomicityTest<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>at<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">int</span> val = at.<span class="me1">getValue</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>val<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>191583767
</pre>
<p>&lt;/spoiler&gt;
Однако программа находит нечетные значения и завершается. Хотя <i><b>return і</b></i> и является атомарной операцией, отсутствие <i><b>synchronized</b></i> позволит читать значение объекта, когда он находится в нестабильном промежуточном состоянии. Вдобавок переменная <i><b>і</b></i> не объявлена как <i><b>volatile</b></i>, а это приведет к проблемам с видимостью. Оба метода, <i><b>getValue()</b></i> и <i><b>evenIncrement()</b></i>,
 должны быть объявлены синхронизируемыми. Только эксперты в области 
параллельных вычислений могут пытаться применять оптимизацию в подобных 
случаях.
</p><p>В качестве второго примера рассмотрим кое-что еще более простое: 
класс, производящий серийные номера. Каждый раз при вызове метода <i><b>nextSerialNumber()</b></i> он должен возвращать уникальное значение:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SerialNumberGenerator.java</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SerialNumberGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">volatile</span> <span class="kw3">int</span> serialNumber = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">int</span> nextSerialNumber<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> serialNumber++<span class="sy0">;</span> <span class="co1">// Операция не является потоково-безопасной</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Представить себе класс тривиальнее <i><b>SerialNumberGenerator</b></i> вряд ли можно, и если вы ранее работали с языком <i>C++</i>
 или имеете другие низкоуровневые навыки, то, видимо, ожидаете, что 
операция инкремента будет атомарной, так как инкремент обычно 
реализуется в виде одной инструкции микропроцессора. Однако в 
виртуальной машине <i>Java</i> инкремент не является атомарным и состоит
 из чтения и записи, соответственно, ниша для проблем с потоками 
найдется даже в такой простой программе.
</p><p>Поле <i><b>serialNumber</b></i> объявлено как <i><b>volatile</b></i>
 потому, что каждый поток обладает локальным стеком и поддерживает в нем
 копии некоторых локальных переменных. Если вы объявляете переменную как
 <i><b>volatile</b></i>, то тем самым указываете компилятору не 
проводить оптимизацию, а это приведет к удалению чтения и записи, 
удерживающих поле в соответствии с локальными данными потока. Операции 
чтения и записи осуществляются непосредственно с памятью без 
кэширования. Кроме того, <i><b>volatile</b></i> не позволяет компилятору изменять порядок обращений с целью оптимизации. И все же присутствие <i><b>volatile</b></i> не влияет на тот факт, что инкремент не является атомарной операцией.
</p><p>Для тестирования нам понадобится множество, которое не потребует 
переизбытка памяти в том случае, если обнаружение проблемы отнимет много
 времени. Приведенный далее класс <i><b>CircularSet</b></i> многократно использует память, в которой хранятся целые числа (<i><b>int</b></i>); предполагается, что к тому моменту, когда запись в множество начинается по новому кругу, вероятность конфликта
</p><p>с перезаписанными значениями минимальна. Методы <i><b>add()</b></i> и <i><b>contains()</b></i> объявлены как <i><b>synchronized</b></i>, чтобы избежать коллизий:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SerialNumberChecker.java</span>
<span class="co1">// Кажущиеся безопасными операции с появлением потоков </span>
<span class="co1">// перестают быть таковыми...</span>
<span class="co1">// {Args: 4}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Reuses storage so we don't run out of memory:</span>
<span class="kw2">class</span> CircularSet <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> array<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> len<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> index = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> CircularSet<span class="br0">(</span><span class="kw3">int</span> size<span class="br0">)</span> <span class="br0">{</span>
    array = <span class="kw2">new</span> <span class="kw3">int</span><span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
    len = size<span class="sy0">;</span>
    <span class="co1">// Инициализируем значением, которое не производится </span>
    <span class="co1">// классом SerialNumberGenerator:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i++<span class="br0">)</span>
      array<span class="br0">[</span>i<span class="br0">]</span> = -<span class="nu0">1</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> add<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    array<span class="br0">[</span>index<span class="br0">]</span> = i<span class="sy0">;</span>
    <span class="co1">// Возврат индекса к началу с записью поверх старых значений:</span>
    index = ++index <span class="sy0">%</span> len<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">boolean</span> contains<span class="br0">(</span><span class="kw3">int</span> val<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> len<span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw1">if</span><span class="br0">(</span>array<span class="br0">[</span>i<span class="br0">]</span> == val<span class="br0">)</span> <span class="kw2">return</span> <span class="kw4">true</span><span class="sy0">;</span>
    <span class="kw2">return</span> <span class="kw4">false</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SerialNumberChecker <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> SIZE = <span class="nu0">10</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> CircularSet serials =
    <span class="kw2">new</span> CircularSet<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw47">ExecutorService</span> exec =
    <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw2">class</span> SerialChecker <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw3">int</span> serial =
          SerialNumberGenerator.<span class="me1">nextSerialNumber</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>serials.<span class="me1">contains</span><span class="br0">(</span>serial<span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
          <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Duplicate: "</span> + serial<span class="br0">)</span><span class="sy0">;</span>
          <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
        serials.<span class="me1">add</span><span class="br0">(</span>serial<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> SIZE<span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> SerialChecker<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Остановиться после n секунд при наличии аргумента:</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"No duplicates detected"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>Duplicate: 8468656
</pre>
<p>&lt;/spoiler&gt;
В классе <i><b>SerialNumberChecker</b></i> содержится статическое поле <i><b>CircuLarSet</b></i>, хранящее все серийные номера, и вложенный поток <i><b>Thread</b></i>,
 который получает эти номера и удостоверяется в их уникальности. Создав 
несколько потоков, претендующих на серийные номера, вы обнаружите, что 
какой-нибудь из них довольно быстро получит уже имеющийся номер 
(заметьте, что на вашей машине программа может и не обнаружить конфликт,
 но на многопроцессорной системе она успешно их нашла). Для решения 
проблемы добавьте к методу <i><b>nextSerialNumber()</b></i> слово <i><b>synchronized</b></i>.
</p><p>Предполагается, что безопасными атомарными операциями являются 
чтение и присвоение примитивов. Однако, как мы увидели в программе <i><b>AtomicityTest.java</b></i>,
 все так же просто использовать атомарную операцию для объекта, который 
находится в нестабильном промежуточном состоянии, так что ожидать, что 
какие-то предположения оправдаются, опасно и ненадежно.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.90.D1.82.D0.BE.D0.BC.D0.B0.D1.80.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B">Атомарные классы</span></h2>
<p>В <i>Java</i> <i>SE5</i> появились специальные классы для выполнения атомарных операций с переменными — <i><b>Atomiclnteger, AtomicLong, AtomicReference</b></i> и т. д. Эти классы содержат атомарную операцию условного обновления в форме
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">boolean</span> compareAndSer<span class="br0">(</span>expectedValue, updateValue<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Эти классы предназначены для оптимизации с целью использования 
атомарности на машинном уровне на некоторых 
современных процессорах, поэтому в общем случае вам они не понадобятся. 
Иногда они применяются и в повседневном программировании, но только при 
оптимизации производительности. Например, версия <i><b>AtomicityTest.java</b></i>, переписанная для использования <i><b>AtomicInteger</b></i>, выглядит так:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/AtomicIntegerTest.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.atomic.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> AtomicIntegerTest <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw48">AtomicInteger</span> i = <span class="kw2">new</span> <span class="kw48">AtomicInteger</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getValue<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> i.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">void</span> evenIncrement<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> i.<span class="me1">addAndGet</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
      evenIncrement<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">new</span> <span class="kw166">Timer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">schedule</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw46">TimerTask</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Aborting"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>, <span class="nu0">5000</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Завершение через 5 секунд</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    AtomicIntegerTest ait = <span class="kw2">new</span> AtomicIntegerTest<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>ait<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">int</span> val = ait.<span class="me1">getValue</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>val <span class="sy0">%</span> <span class="nu0">2</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>val<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Здесь вместо ключевого слова <i><b>synchronized</b></i> используется <i><b>AtomicInteger</b></i>. Так как сбой в программе не происходит, в программу включается таймер, автоматически завершающий ее через 5 секунд.
</p><p>Вот как выглядит пример <i><b>MutexEvenGenerator.java</b></i>, переписанный для использования класса <i><b>Atomiclnteger</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/AtomicEvenGenerator.java</span>
<span class="co1">// Атомарные классы иногда используются в обычном коде.</span>
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.atomic.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> AtomicEvenGenerator <span class="kw2">extends</span> IntGenerator <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw48">AtomicInteger</span> currentEvenValue =
    <span class="kw2">new</span> <span class="kw48">AtomicInteger</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">int</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> currentEvenValue.<span class="me1">addAndGet</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    EvenChecker.<span class="me1">test</span><span class="br0">(</span><span class="kw2">new</span> AtomicEvenGenerator<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Стоит еще раз подчеркнуть, что классы <i><b>Atomic</b></i> проектировались для построения классов из <i><b>java.util.concurrent</b></i>.
 Используйте их в своих программах только в особых случаях и только 
тогда, когда вы твердо уверены, что это не создаст новых проблем. В 
общем случае безопаснее использовать блокировки (с ключевым словом <i><b>synchronized</b></i> или явным созданием объектов <i><b>Lock</b></i>).
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D1.80.D0.B8.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B5_.D1.81.D0.B5.D0.BA.D1.86.D0.B8.D0.B8">Критические секции</span></h2>
<p>Иногда необходимо предотвратить доступ нескольких потоков только к 
части кода, а не к методу в целом. Фрагмент кода, который изолируется 
таким способом, называется критической секцией (<i>critical section</i>), для его создания также приме­няется ключевое слово <i><b>synchronized</b></i>. На этот раз слово <i><b>synchronized</b></i> определяет объект, блокировка которого должна использоваться для синхронизации последующего фрагмента кода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">synchronized</span><span class="br0">(</span>синхронизируемыйОбьект<span class="br0">)</span> <span class="br0">{</span>
     <span class="co1">// К такому коду доступ может получить </span>
     <span class="co1">// одновременно только один поток</span>
   <span class="br0">}</span></pre></div></div>
<p>Такая конструкция иначе называется синхронизированной блокировкой (<i>synchronized block</i>); перед входом в нее необходимо получить блокировку для <i><b>syncObject</b></i>.
 Если блокировка уже предоставлена другому потоку, вход в последующий 
фрагмент кода запрещается до тех пор, пока блокировка не будет снята.
</p><p>Следующий пример сравнивает два подхода к синхронизации, 
показывая, насколько увеличивается время, предоставляемое потокам для 
доступа к объекту при использовании синхронизированной блокировки вместо
 синхронизации методов. Вдобавок он демонстрирует, как незащищенный 
класс может «выжить» в многозадачной среде, если он управляется и 
защищается другим классом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/CriticalSection.java</span>
<span class="co1">// Синхронизация блоков вместо целых методов. Также демонстрирует защиту</span>
<span class="co1">// неприспособленного к многопоточности класса другим классом</span>
<span class="co1">// with a thread-safe one.</span>
<span class="kw2">package</span> <span class="co2">concurrency</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.atomic.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Pair <span class="br0">{</span> <span class="co1">// Not thread-safe</span>
  <span class="kw2">private</span> <span class="kw3">int</span> x, y<span class="sy0">;</span>
  <span class="kw2">public</span> Pair<span class="br0">(</span><span class="kw3">int</span> x, <span class="kw3">int</span> y<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">x</span> = x<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">y</span> = y<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> Pair<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span><span class="br0">(</span><span class="nu0">0</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getX<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> y<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> incrementX<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> x++<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> incrementY<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> y++<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"x: "</span> + x + <span class="st0">", y: "</span> + y<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">class</span> PairValuesNotEqualException
  <span class="kw2">extends</span> <span class="kw21">RuntimeException</span> <span class="br0">{</span>
    <span class="kw2">public</span> PairValuesNotEqualException<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">super</span><span class="br0">(</span><span class="st0">"Pair values not equal: "</span> + Pair.<span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// Произвольный инвариант - обе переменные должны быть:</span>
  <span class="kw2">public</span> <span class="kw3">void</span> checkState<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>x <span class="sy0">!</span>= y<span class="br0">)</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> PairValuesNotEqualException<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Защита класса Pair внутри приспособленного к потокам класса:</span>
<span class="kw2">abstract</span> <span class="kw2">class</span> PairManager <span class="br0">{</span>
  <span class="kw48">AtomicInteger</span> checkCounter = <span class="kw2">new</span> <span class="kw48">AtomicInteger</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">protected</span> Pair p = <span class="kw2">new</span> Pair<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>Pair<span class="sy0">&gt;</span> storage =
    <span class="kw46">Collections</span>.<span class="me1">synchronizedList</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Pair<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> Pair getPair<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Создаем копию, чтобы сохранить оригинал в безопасности:</span>
    <span class="kw2">return</span> <span class="kw2">new</span> Pair<span class="br0">(</span>p.<span class="me1">getX</span><span class="br0">(</span><span class="br0">)</span>, p.<span class="me1">getY</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Предполагается, что операция занимает некоторое время</span>
  <span class="kw2">protected</span> <span class="kw3">void</span> store<span class="br0">(</span>Pair p<span class="br0">)</span> <span class="br0">{</span>
    storage.<span class="me1">add</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">50</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> ignore<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Синхронизация всего метода:</span>
<span class="kw2">class</span> PairManager1 <span class="kw2">extends</span> PairManager <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    p.<span class="me1">incrementX</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">incrementY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    store<span class="br0">(</span>getPair<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Использование критической секции:</span>
<span class="kw2">class</span> PairManager2 <span class="kw2">extends</span> PairManager <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    Pair temp<span class="sy0">;</span>
    <span class="kw2">synchronized</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span> <span class="br0">{</span>
      p.<span class="me1">incrementX</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      p.<span class="me1">incrementY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      temp = getPair<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    store<span class="br0">(</span>temp<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> PairManipulator <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> PairManager pm<span class="sy0">;</span>
  <span class="kw2">public</span> PairManipulator<span class="br0">(</span>PairManager pm<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">pm</span> = pm<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
      pm.<span class="me1">increment</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"Pair: "</span> + pm.<span class="me1">getPair</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">" checkCounter = "</span> + pm.<span class="me1">checkCounter</span>.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> PairChecker <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> PairManager pm<span class="sy0">;</span>
  <span class="kw2">public</span> PairChecker<span class="br0">(</span>PairManager pm<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">pm</span> = pm<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
      pm.<span class="me1">checkCounter</span>.<span class="me1">incrementAndGet</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      pm.<span class="me1">getPair</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">checkState</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CriticalSection <span class="br0">{</span>
  <span class="co1">// Сравнение двух подходов:</span>
  <span class="kw2">static</span> <span class="kw3">void</span>
  testApproaches<span class="br0">(</span>PairManager pman1, PairManager pman2<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    PairManipulator
      pm1 = <span class="kw2">new</span> PairManipulator<span class="br0">(</span>pman1<span class="br0">)</span>,
      pm2 = <span class="kw2">new</span> PairManipulator<span class="br0">(</span>pman2<span class="br0">)</span><span class="sy0">;</span>
    PairChecker
      pcheck1 = <span class="kw2">new</span> PairChecker<span class="br0">(</span>pman1<span class="br0">)</span>,
      pcheck2 = <span class="kw2">new</span> PairChecker<span class="br0">(</span>pman2<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>pm1<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>pm2<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>pcheck1<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>pcheck2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Sleep interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"pm1: "</span> + pm1 + <span class="st0">"<span class="es0">\n</span>pm2: "</span> + pm2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    PairManager
      pman1 = <span class="kw2">new</span> PairManager1<span class="br0">(</span><span class="br0">)</span>,
      pman2 = <span class="kw2">new</span> PairManager2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    testApproaches<span class="br0">(</span>pman1, pman2<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>pm1: Pair: x: 15, y: 15 checkCounter = 272565
pm2: Pair: x: 16, y: 16 checkCounter = 3956974
</pre>
<p>&lt;/spoiler&gt;
Как было отмечено, класс <i><b>Pair</b></i> не приспособлен к работе с 
потоками, поскольку его инвариант (предположительно произвольный) 
требует равенства обоих переменных. Вдобавок, как мы уже видели в этой 
главе, операции инкремента небезопасны в отношении к потокам, и, так как
 ни один из методов не был объявлен как <i><b>synchronized</b></i>, мы не можем считать, что объект <i><b>Pair</b></i> останется неповрежденным в многопоточной программе.
Представьте, что вы получили готовый класс <i><b>Pair</b></i>, который должен работать в многопоточных условиях. Класс <i><b>PairManager</b></i> хранит объекты <i><b>Pair</b></i> и управляет любым доступом к ним. Заметьте, что единственными открытыми (<i><b>public</b></i>) методами являются <i><b>getPair()</b></i>, объявленный как <i><b>synchronized</b></i>, и абстрактный метод <i><b>doTask()</b></i>. Синхронизация этого метода будет осуществлена при его реализации.
</p><p>Структура класса <i><b>PairManager</b></i>, в котором часть 
функциональности базового класса реализуется одним или несколькими 
абстрактными методами, определенными производными классами, называется 
на языке паттернов проектирования «шаблонным методом». Паттерны 
проектирования позволяют инкапсулировать изменения в коде — здесь 
изменяющаяся часть представлена методом <i><b>increment()</b></i>. В классе <i><b>PairManager1</b></i> метод <i><b>increment()</b></i> полностью синхронизирован, в то время как в классе <i><b>PairManager2</b></i> только часть его была синхронизирована посредством синхронизируемой блокировки. Обратите внимание еще раз, что ключевые слова <i><b>synchronized</b></i> не являются частью сигнатуры метода и могут быть добавлены во время переопределения.
</p><p>Метод <i><b>store()</b></i> добавляет объект <i><b>Pair</b></i> в синхронизированный контейнер <i><b>ArrayList</b></i>,
 поэтому операция является потоково-безопасной. Следовательно, в защите 
он не нуждается, поэтому его вызов размещен за пределами 
синхронизируемого блока.
</p><p>Класс <i><b>PairManipulator</b></i> создается для тестирования двух разновидностей <i><b>PairManager</b></i>: метод <i><b>increment()</b></i> вызывается в задаче в то время, как в другой задаче работает <i><b>PairChecker</b></i>. Метод <i><b>main()</b></i> создает два объекта <i><b>PairManipulator</b></i> и дает им поработать в течение некоторого времени, после чего выводятся результаты по каждому <i><b>PairManipulator</b></i>.
</p><p>Для создания критических секций также можно воспользоваться явно созданными объектами <i><b>Lock</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/ExplicitCriticalSection.java</span>
<span class="co1">// Использование объектов Lock для создания критических секций..</span>
<span class="kw2">package</span> <span class="co2">concurrency</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.locks.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Синхронизация целого метода:</span>
<span class="kw2">class</span> ExplicitPairManager1 <span class="kw2">extends</span> PairManager <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw49">Lock</span> lock = <span class="kw2">new</span> <span class="kw49">ReentrantLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    lock.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      p.<span class="me1">incrementX</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      p.<span class="me1">incrementY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      store<span class="br0">(</span>getPair<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      lock.<span class="me1">unlock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Использование критической секции:</span>
<span class="kw2">class</span> ExplicitPairManager2 <span class="kw2">extends</span> PairManager <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw49">Lock</span> lock = <span class="kw2">new</span> <span class="kw49">ReentrantLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    Pair temp<span class="sy0">;</span>
    lock.<span class="me1">lock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      p.<span class="me1">incrementX</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      p.<span class="me1">incrementY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      temp = getPair<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      lock.<span class="me1">unlock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    store<span class="br0">(</span>temp<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ExplicitCriticalSection <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    PairManager
      pman1 = <span class="kw2">new</span> ExplicitPairManager1<span class="br0">(</span><span class="br0">)</span>,
      pman2 = <span class="kw2">new</span> ExplicitPairManager2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    CriticalSection.<span class="me1">testApproaches</span><span class="br0">(</span>pman1, pman2<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>pm1: Pair: x: 15, y: 15 checkCounter = 174035
pm2: Pair: x: 16, y: 16 checkCounter = 2608588
</pre>
<p>&lt;/spoiler&gt;
В программе создаются новые типы <i><b>PairManager</b></i> с явным использованием объектов <i><b>Lock</b></i>. <i><b>ExplicitPairManager2</b></i> демонстрирует создание критической секции с использованием объекта <i><b>Lock</b></i>; вызов <i><b>store()</b></i> находится вне критической секции.
</p><p><br>
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.BE_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D0.BC_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.B0.D0.BC">Синхронизация по другим объектам</span></h2>
<p>Блоку <i><b>synchronized</b></i> необходимо передать объект, который 
будет использоваться для синхронизации. Чаще всего наиболее естественно 
передавать текущий объект, для которого был вызван метод <i><b>synchronized(this)</b></i>, и именно такой подход применен в классе <i><b>PairManager2</b></i>.
 Таким образом, при входе в синхронизируемый блок другие 
синхронизированные методы объекта вызвать будет нельзя. Действие 
синхронизации по <i><b>this</b></i> фактически заключается в сужении области синхро­низации.
</p><p>Иногда вам нужно что-то иное, и в таких ситуациях вы создаете 
отдельный объект и выполняете синхронизацию, привлекая его. В таких 
случаях необходимо позаботиться о том, чтобы все операции 
синхронизировались по одному и тому же объекту. Следующий пример 
показывает, как два потока входят в объект, когда методы этого объекта 
синхронизированы различными блокировками:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SyncObject.java</span>
<span class="co1">// Синхронизация по другому объекту.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> DualSynch <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">Object</span> syncObject = <span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"f()"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">synchronized</span><span class="br0">(</span>syncObject<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
        print<span class="br0">(</span><span class="st0">"g()"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SyncObject <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">final</span> DualSynch ds = <span class="kw2">new</span> DualSynch<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        ds.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    ds.<span class="me1">g</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>g()
f()
g()
f()
g()
f()
g()
f()
g()
f()
</pre>
<p>&lt;/spoiler&gt;
Метод <i><b>f()</b></i> класса <i><b>DualSync</b></i> синхронизируется по объекту <i><b>this</b></i> (синхронизируя метод целиком), а метод <i><b>g()</b></i> использует синхронизацию посредством объекта <i><b>syncObject</b></i>. Таким образом, два варианта синхронизации независимы. Демонст­рируется этот факт методом <i><b>main()</b></i>, в котором создается поток <i><b>Thread</b></i>с вызовом метода <i><b>f()</b></i>. Поток <i><b>main()</b></i> после этого вызывает метод <i><b>g()</b></i>. Из результата работы программы видно, что оба метода работают одновременно и ни один из них не блокируется соседом.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9B.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D0.B0.D1.8F_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D1.8C_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0">Локальная память потока</span></h2>
<p>Второй механизм предотвращения конфликтов доступа к общим ресурсам 
основан на исключении их совместного использования. Локальная память 
потока представляет собой механизм автоматического выделения разных 
областей памяти для одной переменной во всех потоках, использующих 
объект. Следовательно, если пять потоков используют объект с переменной <i><b>х</b></i>, для <i><b>х </b></i>будет сгенерировано пять разных областей памяти. Фактически поток связывается с некоторым состоянием.
</p><p>За выделение локальной памяти потоков и управление ею отвечает класс <i><b>java.lang.ThreadLocal</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/ThreadLocalVariableHolder.java</span>
<span class="co1">// Автоматическое выделение собственной памяти каждому потоку.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Accessor <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id<span class="sy0">;</span>
  <span class="kw2">public</span> Accessor<span class="br0">(</span><span class="kw3">int</span> idn<span class="br0">)</span> <span class="br0">{</span> id = idn<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">currentThread</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">isInterrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      ThreadLocalVariableHolder.<span class="me1">increment</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"#"</span> + id + <span class="st0">": "</span> +
      ThreadLocalVariableHolder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ThreadLocalVariableHolder <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw21">ThreadLocal</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> value =
    <span class="kw2">new</span> <span class="kw21">ThreadLocal</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">protected</span> <span class="kw2">synchronized</span> <span class="kw21">Integer</span> initialValue<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">return</span> rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">10000</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    value.<span class="me1">set</span><span class="br0">(</span>value.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">int</span> get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> value.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> Accessor<span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>   <span class="co1">// Небольшая задержка</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>          <span class="co1">// Выход из всех объектов Accessor</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>#0: 9259
#1: 556
#2: 6694
#3: 1862
#4: 962
#0: 9260
#1: 557
#2: 6695
#3: 1863
#4: 963
...
</pre>
<p>&lt;/spoiler&gt;
Объекты <i><b>ThreadLocal</b></i> обычно хранятся в статических полях. Если вы создаете объект <i><b>ThreadLocal</b></i>, для обращения к содержимому объекта можно использовать только методы <i><b>get()</b></i> и <i><b>set()</b></i>. Метод <i><b>get()</b></i> возвращает копию объекта, ассоцииро­ванного с потоком, a <i><b>set()</b></i> сохраняет свой аргумент в объекте потока, возвращая ранее хранившийся объект. Их использование продемонстрировано в методах <i><b>increment()</b></i> и <i><b>get()</b></i> класса <i><b>ThreadLocalVariableHolder</b></i>. Обратите внимание: методы <i><b>increment()</b></i> и <i><b>get()</b></i> не синхронизированы, потому что <i><b>ThreadLocal</b></i> не гарантирует отсутствия «ситуации гонки».
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D0.B7.D0.B0.D0.B8.D0.BC.D0.BE.D0.B4.D0.B5.D0.B9.D1.81.D1.82.D0.B2.D0.B8.D0.B5_.D0.BC.D0.B5.D0.B6.D0.B4.D1.83_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0.D0.BC.D0.B8">Взаимодействие между потоками</span></h2>
<p>Итак, мы выяснили, что потоки способны конфликтовать друг с другом, и
 разобрались с тем, как предотвратить такие конфликты. Следующим шагом 
должно стать изучение возможностей взаимодействия между потоками. 
Ключевым моментом в этом процессе является подтверждение связи, 
безопасно реализуемое методами <i><b>wait()</b></i> и <i><b>notify()</b></i> класса Object. В многопоточной библиотеке <i>Java</i> <i>SE5</i> также присутствуют объекты <i><b>Condition</b></i> с методами <i><b>await()</b></i> и <i><b>signal()</b></i>. Мы рассмотрим некоторые возникающие проблемы и их решения.
</p>
<h3><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D1.8B_wait.28.29_.D0.B8_notifyAII.28.29">Методы wait() и notifyAII()</span></h3>
<p>Метод <i><b>wait()</b></i> ожидает изменения некоторого условия, 
неподконтрольного для текущего метода. Довольно часто это условие 
изменяется в результате выполнения другой задачи. Активное ожидание, то 
есть проверка условия в цикле, не­желательно из-за неэффективного 
расходования вычислительных ресурсов. Таким образом, метод <i><b>wait()</b></i> обеспечивает механизм синхронизации действий между задачами.
</p><p>Важно понять, что метод <i><b>sleep()</b></i> не освобождает объект блокировки. С другой стороны, метод <i><b>wait()</b></i>
 снимает блокировку с объекта, тем самым позволяя остальным потокам 
вызывать другие синхронизированные методы объекта во время выполнения <i><b>wait()</b></i>. Это очень важно, потому что обычно именно «другие» методы приводят к изменению условия и активизации приостановленной задачи.
</p><p>Существует две формы метода <i><b>wait()</b></i>. У первой формы аргумент имеет такой же смысл, как и аргумент метода <i><b>sleep()</b></i>:
 это продолжительность интервала в миллисекундах, на который 
приостанавливается выполнение потока. Разница между методами состоит в 
следующем:
</p>
<hr>
<ul>
<li><span style="color:#800000">При выполнении метода <i><b>wait()</b></i> блокируемый объект освобождается.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Выйти из состояния ожидания, установленного <i><b>wait()</b></i>, можно двумя способами: с помощью уведомления <i><b>notify()</b></i> или <i><b>notifyAll()</b></i> либо по истечении срока ожидания.</span>
</li>
</ul>
<hr>
<p>Вторая, более распространенная форма вызывается без аргументов. Эта версия метода <i><b>wait()</b></i> заставит поток простаивать, пока не придет уведомление <i><b>notify()</b></i> или <i><b>notifyAll()</b></i>.
</p><p>Пожалуй, самое интересное в методах <i><b>wait(), notify()</b></i> и <i><b>notifyAll()</b></i> — их принадлежность к общему классу <i><b>Object</b></i>, а не к классу потоков <i><b>Thread</b></i>.
 Хотя это и кажется немного нелогичным — размещение чего-то, 
относящегося исключительно к механизму потоков, в общем базовом классе —
 на самом деле это решение совершенно оправдано, поскольку означенные 
методы манипулируют блокировками, которые являются частью любого 
объекта. В результате ожидание (<i><b>wait()</b></i>) может использоваться в любом синхронизированном методе, независимо от того, наследует ли класс от <i><b>Thread</b></i> или реализует <i><b>Runnable</b></i>. Вообще говоря, единственное место, где допустимо вызывать метод <i><b>wait()</b></i>, — это синхронизированный метод или блок (метод <i><b>sleep()</b></i> можно вызывать в любом месте, так как он не манипулирует блокировкой). Если вызвать метод <i><b>wait()</b></i> или <i><b>notify()</b></i> в обычном методе, программа скомпилируется, однако при ее выполнении возникнет исключение <i><b>IllegalMonitorStateException</b></i> с несколько туманным сообщением «текущий поток не является владельцем» (<i>«current thread not owner»</i>). Это сообщение означает, что поток, востребовавший методы <i><b>wait(), notify()</b></i> или <i><b>notifyAll()</b></i>, должен быть «хозяином» блокируемого объекта (овладеть объектом блокировки) перед вызовом любого из данных методов.
</p><p>Вы можете «попросить» объект провести операции с помощью его 
собственного объекта блокировки. Для этого необходимо сначала захватить 
блокировку для данного объекта. Например, если вы хотите вызвать <i><b>notifyAll()</b></i> для объекта <i><b>х</b></i>, то должны сделать это в синхронизируемом блоке, устанавливающем блокировку для <i><b>х</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">synchronized</span><span class="br0">(</span>x<span class="br0">)</span> <span class="br0">{</span> х.<span class="me1">notifyAll</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span><span class="br0">}</span></pre></div></div>
<p>Рассмотрим простой пример. В программе <i><b>WaxOMatic.java</b></i> задействованы два процесса: один наносит восковую пасту на автомашину (<i><b>Саr</b></i>),
 а другой полирует ее. Задача полировки не может приступить к работе до 
того, как задача нанесения пасты завершит свою операцию, а задача 
нанесения пасты должна ждать завершения полировки, чтобы наложить 
следующий слой пасты. Оба класса, <i><b>WaxOn</b></i> и <i><b>WaxOff</b></i>, используют объект <i><b>Саr</b></i>, который приостанавливает и возобновляет задачи в ожидании изменения условия:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/waxomatic/WaxOMatic.java</span>
<span class="co1">// Простейшее взаимодействие задач.</span>
<span class="kw2">package</span> <span class="co2">concurrency.waxomatic</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Car <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">boolean</span> waxOn = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> waxed<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    waxOn = <span class="kw4">true</span><span class="sy0">;</span> <span class="co1">// Готово к обработке</span>
    notifyAll<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> buffed<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    waxOn = <span class="kw4">false</span><span class="sy0">;</span> <span class="co1">// Готово к нанесению очередного слоя</span>
    notifyAll<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> waitForWaxing<span class="br0">(</span><span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>waxOn == <span class="kw4">false</span><span class="br0">)</span>
      wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> waitForBuffing<span class="br0">(</span><span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>waxOn == <span class="kw4">true</span><span class="br0">)</span>
      wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> WaxOn <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> Car car<span class="sy0">;</span>
  <span class="kw2">public</span> WaxOn<span class="br0">(</span>Car c<span class="br0">)</span> <span class="br0">{</span> car = c<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        printnb<span class="br0">(</span><span class="st0">"Wax On! "</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">200</span><span class="br0">)</span><span class="sy0">;</span>
        car.<span class="me1">waxed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        car.<span class="me1">waitForBuffing</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Exiting via interrupt"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"Ending Wax On task"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> WaxOff <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> Car car<span class="sy0">;</span>
  <span class="kw2">public</span> WaxOff<span class="br0">(</span>Car c<span class="br0">)</span> <span class="br0">{</span> car = c<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        car.<span class="me1">waitForWaxing</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        printnb<span class="br0">(</span><span class="st0">"Wax Off! "</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">200</span><span class="br0">)</span><span class="sy0">;</span>
        car.<span class="me1">buffed</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Exiting via interrupt"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"Ending Wax Off task"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> WaxOMatic <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    Car car = <span class="kw2">new</span> Car<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> WaxOff<span class="br0">(</span>car<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> WaxOn<span class="br0">(</span>car<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Небольшая задержка...</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Прерывание всех задач</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (95% match)
</p>
<pre>Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On!
Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off!
Wax On! Wax Off! Wax On! Wax Off! Wax On! Wax Off! Wax On! Exiting via interrupt
Ending Wax On task
Exiting via interrupt
Ending Wax Off task
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Саr</b></i> содержит одну логическую переменную <i><b>waxOn</b></i>, которая описывает текущее состояние процесса полировки.
Метод <i><b>waitForWaxing()</b></i> проверяет флаг <i><b>waxOn</b></i>, и, если он равен <i><b>false</b></i>, вызывающая задача приостанавливается вызовом <i><b>wait()</b></i>. Очень важно, что это происходит в синхронизированном методе. При вызове <i><b>wait()</b></i>
 поток приостанавливается, а блокировка снимается. Последнее 
принципиально, потому что для безопасного изменения состояния объекта 
(например, для присваивания <i><b>waxOn</b></i> значения <i><b>true</b></i>,
 без чего приостановленная задача не сможет продолжить работу) 
блокировка должна быть доступна для другой задачи. В нашем примере при 
вызове другой задачей метода <i><b>waxed()</b></i>, указывающего, что пришло время что-то сделать, для задания истинного значения <i><b>waxOn</b></i> необходимо установить блокировку. Затем <i><b>waxed()</b></i> вызывает <i><b>notifyAll()</b></i>; задача, приостановленная вызовом <i><b>wait()</b></i>, активизируется. Для этого нужно сначала заново получить блокировку, освобожденную при входе в <i><b>wait()</b></i>. Задача не активизируется, пока блокировка не станет доступной.
</p>
<h3><span class="mw-headline" id=".D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.B0.D0.BD.D0.B0.D0.BB.D0.BE.D0.B2_.D0.B4.D0.BB.D1.8F_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0_.D0.BC.D0.B5.D0.B6.D0.B4.D1.83_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0.D0.BC.D0.B8">Использование каналов для ввода/вывода между потоками</span></h3>
<p>Часто бывает полезно организовать взаимодействие потоков посредством 
механизмов ввода/вывода. Библиотеки потоков могут предоставлять 
поддержку ввода/вывода между потоками в форме каналов (<i>pipes</i>). Последние представлены в стандартной библиотеке ввода/вывода <i>Java</i> классами <i><b>PipedWriter</b></i> (позволяет потоку записывать в канал) и <i><b>PipedReader</b></i> (предоставляет возможность другому потоку считывать из того же канала).
</p><p>Простой пример взаимодействия двух потоков через канал:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/PipedIO.java</span>
<span class="co1">// Использование каналов для ввода/вывода между потоками</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Sender <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw20">PipedWriter</span> out = <span class="kw2">new</span> <span class="kw20">PipedWriter</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw20">PipedWriter</span> getPipedWriter<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> out<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">char</span> c = <span class="st0">'A'</span><span class="sy0">;</span> c <span class="sy0">&lt;</span>= <span class="st0">'z'</span><span class="sy0">;</span> c++<span class="br0">)</span> <span class="br0">{</span>
          out.<span class="me1">write</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
          <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span>e + <span class="st0">" Sender write exception"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span>e + <span class="st0">" Sender sleep interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> <span class="kw97">Receiver</span> <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw20">PipedReader</span> in<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw97">Receiver</span><span class="br0">(</span>Sender sender<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    in = <span class="kw2">new</span> <span class="kw20">PipedReader</span><span class="br0">(</span>sender.<span class="me1">getPipedWriter</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// Блокируется до появления следующего символа:</span>
        printnb<span class="br0">(</span><span class="st0">"Read: "</span> + <span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>in.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span>e + <span class="st0">" Receiver read exception"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PipedIO <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    Sender sender = <span class="kw2">new</span> Sender<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw97">Receiver</span> receiver = <span class="kw2">new</span> <span class="kw97">Receiver</span><span class="br0">(</span>sender<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>sender<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>receiver<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (65% match)
</p>
<pre>Read: A, Read: B, Read: C, Read: D, Read: E, Read: F, Read: G, Read: H, Read: I,
Read: J, Read: K, Read: L,  Read: M, 
java.lang.InterruptedException: sleep interrupted Sender sleep interrupted
java.io.InterruptedIOException Receiver read exception
</pre>
<p>&lt;/spoiler&gt;
Классы <i><b>Sender</b></i> и <i><b>Receiver</b></i> представляют задачи, которые должны взаимодействовать друг с другом. В классе <i><b>Sender</b></i> создается канал <i><b>PipedWriter</b></i>, существующий как автономный объект, однако при создании канала <i><b>PipedReader</b></i> в классе <i><b>Receiver</b></i> конструктору необходимо передать ссылку на <i><b>PipedWriter</b></i>. Sender записывает данные в канал <i><b>Writer</b></i> и бездействует в течение случайно выбранного промежутка времени. Класс <i><b>Receiver</b></i> не содержит вызовов <i><b>sleep()</b></i> или <i><b>wait()</b></i>, но при проведении чтения методом <i><b>read()</b></i> он автоматически блокируется при отсутствии данных.
</p><p>Заметьте, что потоки <i><b>sender</b></i> и <i><b>receiver</b></i> запускаются из <i><b>main()</b></i>
 после того, как объекты были полностью сконструированы. Если запускать 
не полностью сконструированные объекты, каналы на различных платформах 
могут демонстрировать несогласованное поведение.
</p>
<h3><span class="mw-headline" id=".D0.92.D0.B7.D0.B0.D0.B8.D0.BC.D0.BD.D0.B0.D1.8F_.D0.B1.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0">Взаимная блокировка</span></h3>
<p>Итак, потоки способны перейти в блокированное состояние, а объекты 
могут обладать синхронизированными методами, которые запрещают 
использование объекта до тех пор, пока не будет снята блокировка. 
Возможна ситуация, в которой один поток ожидает другой поток, тот, в 
свою очередь, ждет освобождения еще одного потока и т. д., пока эта 
цепочка не замыкается на поток, который ожидает освобождения первого 
потока. Получается замкнутый круг потоков, которые дожидаются 
освобождения друг друга, и никто не может двинуться первым. Такая 
ситуация называется взаимной блокировкой (<i>deadlock</i>) (или «клинчем». — Примеч. ред.).
</p><p>Если вы запускаете программу и в ней незамедлительно возникает 
взаимная блокировка, проблему удается немедленно отследить. 
По-настоящему неприятна ситуация, когда ваша программа по всем признакам
 работает прекрасно, но тем не менее в какой-то момент входит во 
взаимную блокировку. Такая опасность незаметно присутствует в программе,
 пока нежданно-негаданно не проявится у заказчика (и, скорее всего, 
легко воспроизвести эту ситуацию вам не удастся). Таким образом, 
тщательное проектирование программы с целью предотвращения взаимных 
блокировок — важнейшая часть разработки параллельных программ.
</p><p>Классический пример взаимной блокировки, предложенный Эдгаром 
Дейкстрой — задача об обедающих философах. В стандартной формулировке 
говорится о пяти философах, но, как будет показано далее, допустимо 
любое количество. Часть времени философы проводят размышляя, часть 
времени проводят за едой. Когда они размышляют, то не нуждаются в общих 
ресурсах, но во время обеда они сидят за круглым столом с ограниченным 
количеством столовых приборов. В описании оригинальной задачи философы 
пользуются вилками, и, чтобы набрать спагетти из миски в центре стола, 
им требуются две вилки. Наверное, задача будет выглядеть более логично, 
если заменить вилки палочками для еды — очевидно, что каждому философу 
понадобятся две палочки.
</p><p>Философы, как это часто бывает, очень бедны, и они смогли 
позволить себе приобрести лишь пять палочек (или в более общем виде — 
количество палочек совпадает с количеством философов). Последние 
разложены кругом по столу, между философами. Когда философу захочется 
поесть, ему придется взять палочку слева и справа. Если с какой-либо 
стороны желаемая палочка уже в руке другого философа, только что 
оторвавшемуся от размышлений придется подождать ее освобождения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Chopstick.java</span>
<span class="co1">// Палочки для обедающих философов.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Chopstick <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">boolean</span> taken = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span>
  <span class="kw3">void</span> take<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>taken<span class="br0">)</span>
      wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    taken = <span class="kw4">true</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> drop<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    taken = <span class="kw4">false</span><span class="sy0">;</span>
    notifyAll<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Два философа (<i><b>Philosopher</b></i>) ни при каких условиях не смогут успешно взять (<i><b>take()</b></i>) одну и ту же палочку (<i><b>Chopstick</b></i>) одновременно. Если один философ уже взял палочку, другому философу придется подождать (<i><b>wait()</b></i>), пока она не будет освобождена текущим пользователем (<i><b>drop()</b></i>).
</p><p>Когда задача <i><b>Philosopher</b></i> вызывает <i><b>take()</b></i>, она ожидает, пока флаг <i><b>taken</b></i> не перейдет в состояние <i><b>false</b></i> (то есть пока палочка не будет освобождена тем философом, который держит ее в данный момент). Далее задача устанавливает флаг <i><b>taken</b></i> равным <i><b>true</b></i>, показывая тем самым, что палочка занята. Завершив работу с <i><b>Chopstick, Philosopher</b></i> вызывает <i><b>drop()</b></i>, чтобы изменить флаг и оповестить (<i><b>notifyAll()</b></i>) всех остальных философов, ожидающих освобождения палочки:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Philosopher.java</span>
<span class="co1">// Обедающий философ</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Philosopher <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> Chopstick left<span class="sy0">;</span>
  <span class="kw2">private</span> Chopstick right<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> ponderFactor<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">void</span> pause<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>ponderFactor == <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>
      rand.<span class="me1">nextInt</span><span class="br0">(</span>ponderFactor <span class="sy0">*</span> <span class="nu0">250</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> Philosopher<span class="br0">(</span>Chopstick left, Chopstick right,
    <span class="kw3">int</span> ident, <span class="kw3">int</span> ponder<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">left</span> = left<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">right</span> = right<span class="sy0">;</span>
    id = ident<span class="sy0">;</span>
    ponderFactor = ponder<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span> + <span class="st0">"thinking"</span><span class="br0">)</span><span class="sy0">;</span>
        pause<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Философ проголодался</span>
        print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span> + <span class="st0">"grabbing right"</span><span class="br0">)</span><span class="sy0">;</span>
        right.<span class="me1">take</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span> + <span class="st0">"grabbing left"</span><span class="br0">)</span><span class="sy0">;</span>
        left.<span class="me1">take</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span> + <span class="st0">"eating"</span><span class="br0">)</span><span class="sy0">;</span>
        pause<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        right.<span class="me1">drop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        left.<span class="me1">drop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span> + <span class="st0">"exiting via interrupt"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Philosopher "</span> + id<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>В методе <i><b>Philosopher.run()</b></i> все философы непрерывно переходят от размышлений к еде, и наоборот. Метод <i><b>pause()</b></i> делает паузу случайной продолжительности, если значение <i><b>ponderFactor</b></i> отлично от нуля. Итак, <i><b>Philosopher</b></i> думает в течение случайного промежутка времени, затем пытается захватить левую и правую палочки вызовами <i><b>take()</b></i>, ест в течение случайного промежутка времени, а затем все повторяется.
</p><p>В следующей версии программы возникает взаимная блокировка:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/DeadlockingDiningPhilosophers.java</span>
<span class="co1">// Демонстрация скрытой возможности взаимной блокировки.</span>
<span class="co1">// {Args: 0 5 timeout}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DeadlockingDiningPhilosophers <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw3">int</span> ponder = <span class="nu0">5</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
      ponder = <span class="kw21">Integer</span>.<span class="me1">parseInt</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> size = <span class="nu0">5</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span>
      size = <span class="kw21">Integer</span>.<span class="me1">parseInt</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Chopstick<span class="br0">[</span><span class="br0">]</span> sticks = <span class="kw2">new</span> Chopstick<span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i++<span class="br0">)</span>
      sticks<span class="br0">[</span>i<span class="br0">]</span> = <span class="kw2">new</span> Chopstick<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> Philosopher<span class="br0">(</span>
        sticks<span class="br0">[</span>i<span class="br0">]</span>, sticks<span class="br0">[</span><span class="br0">(</span>i+<span class="nu0">1</span><span class="br0">)</span> <span class="sy0">%</span> size<span class="br0">]</span>, i, ponder<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">3</span> <span class="sy0">&amp;&amp;</span> args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">equals</span><span class="br0">(</span><span class="st0">"timeout"</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Press 'Enter' to quit"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">in</span>.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Если философы почти не тратят время на размышления, они будут 
постоянно конкурировать за палочки при попытках поесть, и взаимные 
блокировки возникают гораздо чаще.
</p><p>Первый аргумент командной строки изменяет значение <i><b>ponder</b></i>,
 влияющее на продолжительность размышлений. Если философов очень много 
или они проводят большую часть времени в размышлениях, взаимная 
блокировка может и не возникнуть, хотя ее теоретическая вероятность 
отлична от нуля. С нулевым аргументом взаимная блокировка наступает 
намного быстрее.
</p><p>Объектам <i><b>Chopstick</b></i> не нужны внутренние идентификаторы; они идентифицируются по своей позиции в массиве <i><b>sticks</b></i>. Каждому конструктору <i><b>Philosopher</b></i> передаются ссылки на правую и левую палочки <i><b>Chopstick</b></i>. Последнему <i><b>Philosopher</b></i> в качестве правой палочки передается нулевой объект <i><b>Chopstick</b></i>;
 круг замыкается. Теперь может возникнуть ситуация, когда все философы 
одновременно попытаются есть, и каждый из них будет ожидать, пока сосед 
положит свою палочку. В программе наступает взаимная блокировка.
</p><p>Если философы тратят на размышления больше времени, чем на еду, 
вероятность взаимной блокировки значительно снижается. Даже может 
возникнуть иллюзия, что программа свободна от блокировок (при ненулевом 
значении <i><b>ponder</b></i> или большом количестве объектов <i><b>Philosopher</b></i>),
 хотя на самом деле это не так. Именно этим и интересен настоящий 
пример: программа вроде бы ведет себя верно, тогда как на самом деле 
возможна взаимная блокировка.
</p><p>Для решения проблемы необходимо осознавать, что тупик имеет место при стечении следующих четырех обстоятельств:
</p>
<hr>
<ul>
<li><span style="color:#800000">Взаимное исключение: по крайней мере 
один ресурс, используемый потоками, не должен быть совместно 
используемым. В нашем случае одной палочкой для еды не могут 
одновременно есть  два философа.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">По крайней мере одна задача должна 
удерживать ресурс и ожидать выделения ресурса, в настоящее время 
удерживаемого другой задачей. То есть для возникновения тупика философ 
должен  сохранять при себе одну палочку и ожидать другую.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Ресурс нельзя принудительно отбирать у 
задачи. Все процессы должны освобождать ресурсы  естественным путем. 
Наши философы вежливы и не станут выхватывать палочки друг у друга.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Должно произойти круговое ожидание, 
когда процесс ожидает ресурс, занятый другим процессом, который в свою 
очередь ждет ресурс, удерживаемый еще одним процессом, и т. д., пока 
один из  процессов не будет ожидать ресурса, занятого первым процессом, 
что и приведет к порочному кругу. В нашем примере круговое ожидание 
происходит потому, что каждый философ пытается сначала получить правую 
палочку, а потом левую.</span> 
</li>
</ul>
<hr>
<p>Так как взаимная блокировка возникает лишь при соблюдении всех 
перечисленных условий, для упреждения тупика достаточно нарушить всего 
лишь одно из них. В нашей программе проще всего нарушить четвертое 
условие: оно выполняется, поскольку каждый философ старается брать 
палочки в определенном порядке — сначала левую, потом правую. Из-за 
этого может возникнуть ситуация, когда каждый из них держит свою левую 
палочку и ждет освобождения правой, что и приводит к циклическому 
ожиданию. Если инициализировать последнего философа так, чтобы он 
сначала пытался взять левую палочку, а потом правую, взаимная блокировка
 станет невозможна. Это всего лишь одно решение проблемы, но вы можете 
предотвратить ее, нарушив одно из оставшихся условий (за подробностями 
обращайтесь к специализированной литературе по многозадачному 
программированию):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/FixedDiningPhilosophers.java</span>
<span class="co1">// Обедающие философы без взаимной блокировки.</span>
<span class="co1">// {Args: 5 5 timeout}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FixedDiningPhilosophers <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw3">int</span> ponder = <span class="nu0">5</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
      ponder = <span class="kw21">Integer</span>.<span class="me1">parseInt</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> size = <span class="nu0">5</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span>
      size = <span class="kw21">Integer</span>.<span class="me1">parseInt</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Chopstick<span class="br0">[</span><span class="br0">]</span> sticks = <span class="kw2">new</span> Chopstick<span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i++<span class="br0">)</span>
      sticks<span class="br0">[</span>i<span class="br0">]</span> = <span class="kw2">new</span> Chopstick<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw1">if</span><span class="br0">(</span>i <span class="sy0">&lt;</span> <span class="br0">(</span>size-<span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span>
        exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> Philosopher<span class="br0">(</span>
          sticks<span class="br0">[</span>i<span class="br0">]</span>, sticks<span class="br0">[</span>i+<span class="nu0">1</span><span class="br0">]</span>, i, ponder<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">else</span>
        exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> Philosopher<span class="br0">(</span>
          sticks<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>, sticks<span class="br0">[</span>i<span class="br0">]</span>, i, ponder<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">3</span> <span class="sy0">&amp;&amp;</span> args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me1">equals</span><span class="br0">(</span><span class="st0">"timeout"</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Press 'Enter' to quit"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">in</span>.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Проследив за тем, чтобы последний философ брал и откладывал левую палочку раньше правой, мы устраняем взаимную блокировку.
</p><p>В языке <i>Java</i> нет встроенных средств предупреждения 
взаимных блокировок; все зависит только от вас и аккуратности вашего 
кода. Вряд ли эти слова утешат того, кому придется отлаживать программу с
 взаимной блокировкой.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9D.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B1.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D1.87.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.BD.D0.B5.D0.BD.D1.82.D1.8B">Новые библиотечные компоненты</span></h2>
<p>В библиотеке <i><b>java.util.concurrent</b></i> из <i>Java</i> <i>SE5</i>
 появился целый ряд новых классов, предназначенных для решения проблем 
многозадачности. Научившись пользоваться ими, вы сможете создавать более
 простые и надежные многозадачные программы.
</p><p>В этом разделе приведено немало примеров использования различных 
компонентов. Другие, относительно редко встречающиеся компоненты, здесь 
не рассматриваются.
</p><p>Так как компоненты предназначены для решения разных проблем, 
простого способа их упорядочения не существует, поэтому мы начнем с 
более простых примеров и постепенно перейдем к более сложным.
</p>
<h3><span class="mw-headline" id="CountDownLatch">CountDownLatch</span></h3>
<p>Класс синхронизирует задачи, заставляя их ожидать завершения группы операций, выполняемых другими задачами.
</p><p>Объекту <i><b>CountDownLatch</b></i> присваивается начальное значение счетчика, а все задачи, вызвавшие <i><b>await()</b></i> для этого объекта, блокируются до момента обнуления счетчика. Другие задачи могут уменьшать счетчик, вызывая метод <i><b>countDown()</b></i> для объекта (обычно это делается тогда, когда задача завершает свою работу). Класс <i><b>CountDownLatch</b></i>
 рассчитан на «одноразовое» применение; счетчик не может возвращаться к 
прежнему состоянию. Если вам нужна версия с возможностью сброса 
счетчика, воспользуйтесь классом <i><b>CyclicBarrier</b></i>.
</p><p>Задачи, вызывающие <i><b>countDown()</b></i>, не блокируются на время вызова. Только вызов <i><b>await()</b></i> блокируется до момента обнуления счетчика.
</p><p>Типичный способ применения — разделение задачи на n независимых подзадач и создание объекта <i><b>CountDownLatch</b></i> с начальным значением n. При завершении каждая подзадача вызывает <i><b>countDown()</b></i> для объекта синхронизации. Потоки, ожидающие решения общей задачи, блокируются вызовом <i><b>await()</b></i>. Описанная методика продемонстрирована в следующем примере:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/CountDownLatchDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Часть основной задачи.:</span>
<span class="kw2">class</span> TaskPortion <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw47">CountDownLatch</span> latch<span class="sy0">;</span>
  TaskPortion<span class="br0">(</span><span class="kw47">CountDownLatch</span> latch<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">latch</span> = latch<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      doWork<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      latch.<span class="me1">countDown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> ex<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> doWork<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">2000</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"completed"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">String</span>.<span class="me1">format</span><span class="br0">(</span><span class="st0">"%1$-3d "</span>, id<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Ожидание по объекту CountDownLatch:</span>
<span class="kw2">class</span> WaitingTask <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw47">CountDownLatch</span> latch<span class="sy0">;</span>
  WaitingTask<span class="br0">(</span><span class="kw47">CountDownLatch</span> latch<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">latch</span> = latch<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      latch.<span class="me1">await</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="st0">"Latch barrier passed for "</span> + <span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> ex<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">String</span>.<span class="me1">format</span><span class="br0">(</span><span class="st0">"WaitingTask&nbsp;%1$-3d "</span>, id<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CountDownLatchDemo <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> SIZE = <span class="nu0">100</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Все подзадачи совместно используют один объект CountDownLatch:</span>
    <span class="kw47">CountDownLatch</span> latch = <span class="kw2">new</span> <span class="kw47">CountDownLatch</span><span class="br0">(</span>SIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> WaitingTask<span class="br0">(</span>latch<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> SIZE<span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> TaskPortion<span class="br0">(</span>latch<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Launched all tasks"</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Выход по завершению всех задач</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p><i><b>TaskPortion</b></i> некоторое время ожидает, имитируя выполнение части задачи, а класс <i><b>WaitingTask</b></i>
 представляет некую часть системы, которая обязана дождаться завершения 
всех подзадач. Все задачи используют один и тот же объект <i><b>CountDownLatch</b></i>, определяемый в <i><b>main()</b></i>.
</p>
<h3><span class="mw-headline" id="CyclicBarrier">CyclicBarrier</span></h3>
<p>Класс <i><b>CyclicBarrier</b></i> используется при создании группы 
параллельно выполняемых задач, завершения которых необходимо дождаться 
до перехода к следующей фазе. Все параллельные задачи 
«приостанавливаются» у барьера, чтобы сделать возможным их согласованное
 продвижение вперед. Класс очень похож на <i><b>CountDownLatch</b></i>, за одним важным исключением: <i><b>CountDownLatch</b></i> является «одноразовым», a <i><b>CyclicBarrier</b></i> может использоваться снова и снова.
</p><p>Имитации привлекали меня с первых дней работы с компьютерами, и 
параллельные вычисления играют в них ключевую роль. Даже самая первая 
программа, которую я написал на BASIC, имитировала скачки на ипподроме. 
Вот как выглядит объектно-ориентированная, многопоточная версия этой 
программы с использованием <i><b>CyclicBarrier</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/HorseRace.java</span>
<span class="co1">// Using CyclicBarriers.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Horse <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> strides = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw47">CyclicBarrier</span> barrier<span class="sy0">;</span>
  <span class="kw2">public</span> Horse<span class="br0">(</span><span class="kw47">CyclicBarrier</span> b<span class="br0">)</span> <span class="br0">{</span> barrier = b<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">int</span> getStrides<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> strides<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">synchronized</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span> <span class="br0">{</span>
          strides += rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Produces 0, 1 or 2</span>
        <span class="br0">}</span>
        barrier.<span class="me1">await</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw47">BrokenBarrierException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Исключение, которое нас интересует</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Horse "</span> + id + <span class="st0">" "</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> tracks<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">StringBuilder</span> s = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> getStrides<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> i++<span class="br0">)</span>
      s.<span class="me1">append</span><span class="br0">(</span><span class="st0">"*"</span><span class="br0">)</span><span class="sy0">;</span>
    s.<span class="me1">append</span><span class="br0">(</span>id<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> s.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> HorseRace <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> FINISH_LINE = <span class="nu0">75</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>Horse<span class="sy0">&gt;</span> horses = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Horse<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw47">ExecutorService</span> exec =
    <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw47">CyclicBarrier</span> barrier<span class="sy0">;</span>
  <span class="kw2">public</span> HorseRace<span class="br0">(</span><span class="kw3">int</span> nHorses, <span class="kw2">final</span> <span class="kw3">int</span> pause<span class="br0">)</span> <span class="br0">{</span>
    barrier = <span class="kw2">new</span> <span class="kw47">CyclicBarrier</span><span class="br0">(</span>nHorses, <span class="kw2">new</span> <span class="kw21">Runnable</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">StringBuilder</span> s = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> FINISH_LINE<span class="sy0">;</span> i++<span class="br0">)</span>
          s.<span class="me1">append</span><span class="br0">(</span><span class="st0">"="</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Забор на беговой дорожке</span>
        print<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>Horse horse&nbsp;: horses<span class="br0">)</span>
          print<span class="br0">(</span>horse.<span class="me1">tracks</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>Horse horse&nbsp;: horses<span class="br0">)</span>
          <span class="kw1">if</span><span class="br0">(</span>horse.<span class="me1">getStrides</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span>= FINISH_LINE<span class="br0">)</span> <span class="br0">{</span>
            print<span class="br0">(</span>horse + <span class="st0">"won!"</span><span class="br0">)</span><span class="sy0">;</span>
            exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
            <span class="kw2">return</span><span class="sy0">;</span>
          <span class="br0">}</span>
        <span class="kw2">try</span> <span class="br0">{</span>
          <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>pause<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="st0">"barrier-action sleep interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> nHorses<span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      Horse horse = <span class="kw2">new</span> Horse<span class="br0">(</span>barrier<span class="br0">)</span><span class="sy0">;</span>
      horses.<span class="me1">add</span><span class="br0">(</span>horse<span class="br0">)</span><span class="sy0">;</span>
      exec.<span class="me1">execute</span><span class="br0">(</span>horse<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span> nHorses = <span class="nu0">7</span><span class="sy0">;</span>
    <span class="kw3">int</span> pause = <span class="nu0">200</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// Необязательный аргумент</span>
      <span class="kw3">int</span> n = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      nHorses = n <span class="sy0">&gt;</span> <span class="nu0">0</span> <span class="sy0">?</span> n&nbsp;: nHorses<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// Необязательный аргумент</span>
      <span class="kw3">int</span> p = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      pause = p <span class="sy0">&gt;</span> -<span class="nu0">1</span> <span class="sy0">?</span> p&nbsp;: pause<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">new</span> HorseRace<span class="br0">(</span>nHorses, pause<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Для объекта <i><b>CyclicBarrier</b></i> можно задать «барьерное действие» — объект <i><b>Runnable</b></i>, автоматически запускаемый при обнулении счетчика (еще одно отличие <i><b>CyclicBarrier</b></i> от <i><b>CountdownLatch</b></i>). В нашем примере барьерное действие опре­деляется в виде безымянного класса, передаваемого конструктору <i><b>CyclicBarrier</b></i>.
</p><p>Я попытался сделать так, чтобы каждый объект лошади отображал 
себя, но порядок отображения зависел от диспетчера задач. Благодаря <i><b>CyclicBarrier</b></i>
 каждая лошадь делает то, что ей необходимо для продвижения вперед, а 
затем ожидает у барьера перемещения всех остальных лошадей. Когда все 
лошади переместятся, <i><b>CyclicBarrier</b></i> автоматически вызывает «барьерную» задачу <i><b>Runnable</b></i>,
 чтобы отобразить всех лошадей по порядку вместе с барьером. Как только 
все задачи пройдут барьер, последний автоматически становится готовым 
для следующего захода.
</p>
<h3><span class="mw-headline" id="DelayQueue">DelayQueue</span></h3>
<p>Класс представляет неограниченную блокирующую очередь объектов, реализующих интерфейс <i><b>Delayed</b></i>.
 Объект может быть извлечен из очереди только после истечения задержки. 
Очередь сортируется таким образом, что объект в начале очереди обладает 
наибольшим сроком истечения задержки. Если задержка ни у одного объекта 
не истекла, начального элемента нет, и вызов <i><b>poll()</b></i> возвращает <i><b>null</b></i> (из-за этого в очередь не могут помещаться элементы <i><b>null</b></i>).
</p><p>В следующем примере объекты, реализующие <i><b>Delayed</b></i>, сами являются задачами, a <i><b>DelayedTaskContainer</b></i> берет задачу с наибольшей просроченной задержкой и запускает ее. Таким образом, <i><b>DelayQueue</b></i> является разновидностью при­оритетной очереди.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/DelayQueueDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">java.util.concurrent.TimeUnit.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> DelayedTask <span class="kw2">implements</span> <span class="kw21">Runnable</span>, <span class="kw47">Delayed</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> delta<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">long</span> trigger<span class="sy0">;</span>
  <span class="kw2">protected</span> <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span> sequence =
    <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> DelayedTask<span class="br0">(</span><span class="kw3">int</span> delayInMilliseconds<span class="br0">)</span> <span class="br0">{</span>
    delta = delayInMilliseconds<span class="sy0">;</span>
    trigger = <span class="kw21">System</span>.<span class="me1">nanoTime</span><span class="br0">(</span><span class="br0">)</span> +
      NANOSECONDS.<span class="me1">convert</span><span class="br0">(</span>delta, MILLISECONDS<span class="br0">)</span><span class="sy0">;</span>
    sequence.<span class="me1">add</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">long</span> getDelay<span class="br0">(</span><span class="kw47">TimeUnit</span> unit<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> unit.<span class="me1">convert</span><span class="br0">(</span>
      trigger - <span class="kw21">System</span>.<span class="me1">nanoTime</span><span class="br0">(</span><span class="br0">)</span>, NANOSECONDS<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> compareTo<span class="br0">(</span><span class="kw47">Delayed</span> arg<span class="br0">)</span> <span class="br0">{</span>
    DelayedTask that = <span class="br0">(</span>DelayedTask<span class="br0">)</span>arg<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>trigger <span class="sy0">&lt;</span> that.<span class="me1">trigger</span><span class="br0">)</span> <span class="kw2">return</span> -<span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>trigger <span class="sy0">&gt;</span> that.<span class="me1">trigger</span><span class="br0">)</span> <span class="kw2">return</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw2">return</span> <span class="nu0">0</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">String</span>.<span class="me1">format</span><span class="br0">(</span><span class="st0">"[%1$-4d]"</span>, delta<span class="br0">)</span> +
      <span class="st0">" Task "</span> + id<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> summary<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + id + <span class="st0">":"</span> + delta + <span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">class</span> EndSentinel <span class="kw2">extends</span> DelayedTask <span class="br0">{</span>
    <span class="kw2">private</span> <span class="kw47">ExecutorService</span> exec<span class="sy0">;</span>
    <span class="kw2">public</span> EndSentinel<span class="br0">(</span><span class="kw3">int</span> delay, <span class="kw47">ExecutorService</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">super</span><span class="br0">(</span>delay<span class="br0">)</span><span class="sy0">;</span>
      exec = e<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span>DelayedTask pt&nbsp;: sequence<span class="br0">)</span> <span class="br0">{</span>
        printnb<span class="br0">(</span>pt.<span class="me1">summary</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" Calling shutdownNow()"</span><span class="br0">)</span><span class="sy0">;</span>
      exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> DelayedTaskConsumer <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw47">DelayQueue</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span> q<span class="sy0">;</span>
  <span class="kw2">public</span> DelayedTaskConsumer<span class="br0">(</span><span class="kw47">DelayQueue</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span> q<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">q</span> = q<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
        q.<span class="me1">take</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">run</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Выполнение задачи в текущем потоке</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"Finished DelayedTaskConsumer"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DelayQueueDemo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">DelayQueue</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span> queue =
      <span class="kw2">new</span> <span class="kw47">DelayQueue</span><span class="sy0">&lt;</span>DelayedTask<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Очередь заполняется задачами со случайной задержкой:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">20</span><span class="sy0">;</span> i++<span class="br0">)</span>
      queue.<span class="me1">put</span><span class="br0">(</span><span class="kw2">new</span> DelayedTask<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">5000</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Назначение точки остановки</span>
    queue.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> DelayedTask.<span class="me1">EndSentinel</span><span class="br0">(</span><span class="nu0">5000</span>, exec<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> DelayedTaskConsumer<span class="br0">(</span>queue<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[128 ] Task 11 [200 ] Task 7 [429 ] Task 5 [520 ] Task 18 [555 ] Task 1 [961 ]
Task 4 [998 ] Task 16 [1207] Task 9 [1693] Task 2 [1809] Task 14 [1861]
Task 3 [2278] Task 15 [3288] Task 10 [3551] Task 12 [4258] Task 0 [4258]
Task 19 [4522] Task 8 [4589] Task 13 [4861] Task 17 [4868] Task 6 (0:4258)
(1:555) (2:1693) (3:1861) (4:961) (5:429) (6:4868) (7:200) (8:4522) (9:1207)
(10:3288) (11:128) (12:3551) (13:4589) (14:1809) (15:2278) (16:998) (17:4861)
(18:520) (19:4258) (20:5000)
[5000] Task 20 Calling shutdownNow()
Finished DelayedTaskConsumer
</pre>
<p>&lt;/spoiler&gt;
<i><b>DelayedTask</b></i> содержит контейнер <i><b>List&lt;DelayedTask&gt;</b></i> с именем sequence, в котором сохраняется порядок создания задач, и мы видим, что сортировка действительно выполняется.
</p><p>Интерфейс Delayed содержит единственный метод <i><b>getDelay()</b></i>,
 который сообщает, сколько времени осталось до истечения задержки или 
как давно задержка истекла. Метод заставляет нас использовать класс <i><b>TimeUnit</b></i>,
 потому что его аргумент относится именно к этому типу. Впрочем, этот 
класс очень удобен, поскольку он позволяет легко преобразовывать единицы
 без каких-либо вычислений. Например, значение <i><b>delta</b></i> хранится в миллисекундах, а метод <i>Java</i> <i>SE5</i> <i><b>System.nanoTime()</b></i> выдает значение в наносекундах. Чтобы преобразовать значение <i><b>delta</b></i>, достаточно указать исходные и итоговые единицы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> NANOSECONDS.<span class="me1">convert</span><span class="br0">(</span>delta. <span class="me1">MILL</span> ISECONDS<span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>В <i><b>getDelay()</b></i> желаемые единицы передаются в аргументе <i><b>unit</b></i>. Аргумент используется для преобразования времени задержки во временные единицы, используемые вызывающей стороной.
</p><p>Для выполнения сортировки интерфейс <i><b>Delayed</b></i> также наследует интерфейс <i><b>Comparable</b></i>, поэтому необходимо реализовать метод <i><b>compareTo()</b></i> для выполнения осмысленных сравнений. Методы <i><b>toString()</b></i> и <i><b>summary()</b></i> обеспечивают формати­рование вывода.
</p><p>Из выходных данных видно, что порядок создания задач не влияет на
 порядок их выполнения — вместо этого задачи, как и предполагалось, 
выполняются в порядке следования задержек.
</p>
<h3><span class="mw-headline" id="PriorityBlockingQueue">PriorityBlockingQueue</span></h3>
<p>Фактически класс <i><b>PriorityBlockingQueue</b></i> представляет 
приоритетную очередь с блокирующими операциями выборки. В следующем 
примере объектами в приоритетной очереди являются задачи, покидающие 
очередь в порядке приоритетов. Для определения этого порядка в класс <i><b>PrioritizedTask</b></i> включается поле <i><b>priority</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/PriorityBlockingQueueDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> PrioritizedTask <span class="kw2">implements</span>
<span class="kw21">Runnable</span>, <span class="kw21">Comparable</span><span class="sy0">&lt;</span>PrioritizedTask<span class="sy0">&gt;</span>  <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> priority<span class="sy0">;</span>
  <span class="kw2">protected</span> <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;</span>PrioritizedTask<span class="sy0">&gt;</span> sequence =
    <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>PrioritizedTask<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> PrioritizedTask<span class="br0">(</span><span class="kw3">int</span> priority<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">priority</span> = priority<span class="sy0">;</span>
    sequence.<span class="me1">add</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> compareTo<span class="br0">(</span>PrioritizedTask arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> priority <span class="sy0">&lt;</span> arg.<span class="me1">priority</span> <span class="sy0">?</span> <span class="nu0">1</span>&nbsp;:
      <span class="br0">(</span>priority <span class="sy0">&gt;</span> arg.<span class="me1">priority</span> <span class="sy0">?</span> -<span class="nu0">1</span>&nbsp;: <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">250</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw21">String</span>.<span class="me1">format</span><span class="br0">(</span><span class="st0">"[%1$-3d]"</span>, priority<span class="br0">)</span> +
      <span class="st0">" Task "</span> + id<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> summary<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + id + <span class="st0">":"</span> + priority + <span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">class</span> EndSentinel <span class="kw2">extends</span> PrioritizedTask <span class="br0">{</span>
    <span class="kw2">private</span> <span class="kw47">ExecutorService</span> exec<span class="sy0">;</span>
    <span class="kw2">public</span> EndSentinel<span class="br0">(</span><span class="kw47">ExecutorService</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">super</span><span class="br0">(</span>-<span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Минимальный приоритет в этой программе</span>
      exec = e<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">int</span> count = <span class="nu0">0</span><span class="sy0">;</span>
      <span class="kw1">for</span><span class="br0">(</span>PrioritizedTask pt&nbsp;: sequence<span class="br0">)</span> <span class="br0">{</span>
        printnb<span class="br0">(</span>pt.<span class="me1">summary</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>++count <span class="sy0">%</span> <span class="nu0">5</span> == <span class="nu0">0</span><span class="br0">)</span>
          print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">" Calling shutdownNow()"</span><span class="br0">)</span><span class="sy0">;</span>
      exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> PrioritizedTaskProducer <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">Queue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span> queue<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw47">ExecutorService</span> exec<span class="sy0">;</span>
  <span class="kw2">public</span> PrioritizedTaskProducer<span class="br0">(</span>
    <span class="kw46">Queue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span> q, <span class="kw47">ExecutorService</span> e<span class="br0">)</span> <span class="br0">{</span>
    queue = q<span class="sy0">;</span>
    exec = e<span class="sy0">;</span> <span class="co1">// Используется для EndSentinel</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Неограниченная очередь без блокировки. </span>
    <span class="co1">// Быстрое заполнение случайными приоритетами:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">20</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      queue.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTask<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">Thread</span>.<span class="me1">yield</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1">// Добавление высокоприоритетных задач:</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">250</span><span class="br0">)</span><span class="sy0">;</span>
        queue.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTask<span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="co1">// Добавление заданий, начиная с наименьших приоритетов:</span>
      <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
        queue.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTask<span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="co1">// Предохранитель для остановки всех задач::</span>
      queue.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTask.<span class="me1">EndSentinel</span><span class="br0">(</span>exec<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"Finished PrioritizedTaskProducer"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> PrioritizedTaskConsumer <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw47">PriorityBlockingQueue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span> q<span class="sy0">;</span>
  <span class="kw2">public</span> PrioritizedTaskConsumer<span class="br0">(</span>
    <span class="kw47">PriorityBlockingQueue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span> q<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">q</span> = q<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
        <span class="co1">// Использование текущего потока для запуска задачи:</span>
        q.<span class="me1">take</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">run</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый вариант выхода</span>
    <span class="br0">}</span>
    print<span class="br0">(</span><span class="st0">"Finished PrioritizedTaskConsumer"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PriorityBlockingQueueDemo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">PriorityBlockingQueue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span> queue =
      <span class="kw2">new</span> <span class="kw47">PriorityBlockingQueue</span><span class="sy0">&lt;</span><span class="kw21">Runnable</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTaskProducer<span class="br0">(</span>queue, exec<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> PrioritizedTaskConsumer<span class="br0">(</span>queue<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Как и в предыдущем примере, последовательность создания объектов <i><b>PrioritizedTask</b></i> сохраняется в контейнере <i><b>List</b></i> sequence для сравнения с фактическим порядком выполнения. Метод <i><b>run()</b></i> делает небольшую паузу, а затем выводит информацию об объекте, а предохранитель <i><b>EndSentinel</b></i> выполняет те же функции, что и прежде.
</p><p><i><b>PrioritizedTaskProducer</b></i> и <i><b>PrioritizedTaskConsumer</b></i> связываются друг с другом через <i><b>PriorityBlockingQueue</b></i>.
 Так как сам блокирующий характер очереди обеспечивает всю необходимую 
синхронизацию, явная синхронизация не нужна — при чтении вам не нужно 
думать о том, содержит ли очередь элементы, потому что при отсутствии 
элементов очередь просто заблокирует читающую сторону.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BE.D1.80.D0.B0.D0.BD.D0.B6.D0.B5.D1.80.D0.B5.D0.B5.D0.B9_.D0.BD.D0.B0_.D0.B1.D0.B0.D0.B7.D0.B5_ScheduledExecutor">Управление оранжереей на базе ScheduledExecutor</span></h2>
<p>В главе 10 была представлена система управления гипотетической 
оранжереей, которая включала (отключала) различные устройства и 
регулировала их работу. Происходящее можно преобразовать в контекст 
многозадачности: каждое событие оранжереи представляет собой задачу, 
запускаемую в заранее заданное время. Класс <i><b>ScheduledThreadPoolExecutor</b></i> предоставляет именно тот сервис, который необходим для решения задачи. Используя методы <i><b>schedule()</b></i> (однократный запуск задачи) или <i><b>scheduleAtFixedRate()</b></i> (повторение задачи с постоянным промежутком), мы создаем объекты <i><b>Runnable</b></i>,
 которые должны запуститься в положенное время. Сравните это решение с 
тем, что приведено в главе 10, и посмотрите, насколько оно упрощается 
благодаря готовой функциональности <i><b>ScheduledThreadPoolExecutor</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/GreenhouseScheduler.java</span>
<span class="co1">// Новая реализация іnnerclasses/GreenhouseController.java</span>
<span class="co1">// с использованием ScheduledThreadPoolExecutor.</span>
<span class="co1">// {Args: 5000}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GreenhouseScheduler <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">boolean</span> light = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">boolean</span> water = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> thermostat = <span class="st0">"Day"</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw21">String</span> getThermostat<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> thermostat<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> setThermostat<span class="br0">(</span><span class="kw21">String</span> value<span class="br0">)</span> <span class="br0">{</span>
    thermostat = value<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw47">ScheduledThreadPoolExecutor</span> scheduler =
    <span class="kw2">new</span> <span class="kw47">ScheduledThreadPoolExecutor</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> schedule<span class="br0">(</span><span class="kw21">Runnable</span> event, <span class="kw3">long</span> delay<span class="br0">)</span> <span class="br0">{</span>
    scheduler.<span class="me1">schedule</span><span class="br0">(</span>event,delay,<span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span>
  repeat<span class="br0">(</span><span class="kw21">Runnable</span> event, <span class="kw3">long</span> initialDelay, <span class="kw3">long</span> period<span class="br0">)</span> <span class="br0">{</span>
    scheduler.<span class="me1">scheduleAtFixedRate</span><span class="br0">(</span>
      event, initialDelay, period, <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> LightOn <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here to</span>
      <span class="co1">// physically turn on the light.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Turning on lights"</span><span class="br0">)</span><span class="sy0">;</span>
      light = <span class="kw4">true</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> LightOff <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here to</span>
      <span class="co1">// physically turn off the light.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Turning off lights"</span><span class="br0">)</span><span class="sy0">;</span>
      light = <span class="kw4">false</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> WaterOn <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Turning greenhouse water on"</span><span class="br0">)</span><span class="sy0">;</span>
      water = <span class="kw4">true</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> WaterOff <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Turning greenhouse water off"</span><span class="br0">)</span><span class="sy0">;</span>
      water = <span class="kw4">false</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> ThermostatNight <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Thermostat to night setting"</span><span class="br0">)</span><span class="sy0">;</span>
      setThermostat<span class="br0">(</span><span class="st0">"Night"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> ThermostatDay <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Put hardware control code here.</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Thermostat to day setting"</span><span class="br0">)</span><span class="sy0">;</span>
      setThermostat<span class="br0">(</span><span class="st0">"Day"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> Bell <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Bing!"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> Terminate <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Terminating"</span><span class="br0">)</span><span class="sy0">;</span>
      scheduler.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="co1">// Must start a separate task to do this job,</span>
      <span class="co1">// since the scheduler has been shut down:</span>
      <span class="kw2">new</span> <span class="kw21">Thread</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
          <span class="kw1">for</span><span class="br0">(</span>DataPoint d&nbsp;: data<span class="br0">)</span>
            <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>d<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>.<span class="me1">start</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// New feature: data collection</span>
  <span class="kw2">static</span> <span class="kw2">class</span> DataPoint <span class="br0">{</span>
    <span class="kw2">final</span> <span class="kw46">Calendar</span> time<span class="sy0">;</span>
    <span class="kw2">final</span> <span class="kw3">float</span> temperature<span class="sy0">;</span>
    <span class="kw2">final</span> <span class="kw3">float</span> humidity<span class="sy0">;</span>
    <span class="kw2">public</span> DataPoint<span class="br0">(</span><span class="kw46">Calendar</span> d, <span class="kw3">float</span> temp, <span class="kw3">float</span> hum<span class="br0">)</span> <span class="br0">{</span>
      time = d<span class="sy0">;</span>
      temperature = temp<span class="sy0">;</span>
      humidity = hum<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> time.<span class="me1">getTime</span><span class="br0">(</span><span class="br0">)</span> +
        <span class="kw21">String</span>.<span class="me1">format</span><span class="br0">(</span>
          <span class="st0">" temperature:&nbsp;%1$.1f humidity:&nbsp;%2$.2f"</span>,
          temperature, humidity<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw46">Calendar</span> lastTime = <span class="kw46">Calendar</span>.<span class="me1">getInstance</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">{</span> <span class="co1">// Adjust date to the half hour</span>
    lastTime.<span class="me1">set</span><span class="br0">(</span><span class="kw46">Calendar</span>.<span class="me1">MINUTE</span>, <span class="nu0">30</span><span class="br0">)</span><span class="sy0">;</span>
    lastTime.<span class="me1">set</span><span class="br0">(</span><span class="kw46">Calendar</span>.<span class="me1">SECOND</span>, 00<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">float</span> lastTemp = 65.0f<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> tempDirection = +<span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">float</span> lastHumidity = 50.0f<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> humidityDirection = +<span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw166">List</span><span class="sy0">&lt;</span>DataPoint<span class="sy0">&gt;</span> data = <span class="kw46">Collections</span>.<span class="me1">synchronizedList</span><span class="br0">(</span>
    <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>DataPoint<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">class</span> CollectData <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Collecting data"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">synchronized</span><span class="br0">(</span>GreenhouseScheduler.<span class="kw2">this</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// Pretend the interval is longer than it is:</span>
        lastTime.<span class="me1">set</span><span class="br0">(</span><span class="kw46">Calendar</span>.<span class="me1">MINUTE</span>,
          lastTime.<span class="me1">get</span><span class="br0">(</span><span class="kw46">Calendar</span>.<span class="me1">MINUTE</span><span class="br0">)</span> + <span class="nu0">30</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// One in 5 chances of reversing the direction:</span>
        <span class="kw1">if</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span> == <span class="nu0">4</span><span class="br0">)</span>
          tempDirection = -tempDirection<span class="sy0">;</span>
        <span class="co1">// Store previous value:</span>
        lastTemp = lastTemp +
          tempDirection <span class="sy0">*</span> <span class="br0">(</span>1.0f + rand.<span class="me1">nextFloat</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span> == <span class="nu0">4</span><span class="br0">)</span>
          humidityDirection = -humidityDirection<span class="sy0">;</span>
        lastHumidity = lastHumidity +
          humidityDirection <span class="sy0">*</span> rand.<span class="me1">nextFloat</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Calendar must be cloned, otherwise all</span>
        <span class="co1">// DataPoints hold references to the same lastTime.</span>
        <span class="co1">// For a basic object like Calendar, clone() is OK.</span>
        data.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> DataPoint<span class="br0">(</span><span class="br0">(</span><span class="kw46">Calendar</span><span class="br0">)</span>lastTime.<span class="me1">clone</span><span class="br0">(</span><span class="br0">)</span>,
          lastTemp, lastHumidity<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GreenhouseScheduler gh = <span class="kw2">new</span> GreenhouseScheduler<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">schedule</span><span class="br0">(</span>gh.<span class="kw2">new</span> Terminate<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">5000</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Former "Restart" class not necessary:</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> Bell<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">1000</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> ThermostatNight<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">2000</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> LightOn<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">200</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> LightOff<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">400</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> WaterOn<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">600</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> WaterOff<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">800</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> ThermostatDay<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">0</span>, <span class="nu0">1400</span><span class="br0">)</span><span class="sy0">;</span>
    gh.<span class="me1">repeat</span><span class="br0">(</span>gh.<span class="kw2">new</span> CollectData<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">500</span>, <span class="nu0">500</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>В этой версии, помимо реорганизации кода, добавляется новая 
возможность: сбор данных о температуре и влажности в оранжерее. Объект <i><b>DataPoint</b></i> содержит и выводит одну точку данных, а запланированная задача <i><b>CollectData</b></i> генерирует данные имитации и включает их в <i><b>List&lt;DataPoint&gt;</b></i> при каждом запуске.
</p><p>Обратите внимание на ключевые слова <i><b>volatile</b></i> и <i><b>synchronized</b></i>; благодаря им задачи не мешают работе друг друга. Все методы контейнера <i><b>List</b></i> с элементами <i><b>DataPoint</b></i> синхронизируются с использованием метода <i><b>synchronizedList()</b></i> библио­теки <i><b>java.util.Соllectiоns</b></i> при создании <i><b>List</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B5.D0.BC.D0.B0.D1.84.D0.BE.D1.80.D1.8B">Семафоры</span></h2>
<p>При обычной блокировке доступ к ресурсу в любой момент времени 
разрешается только одной задаче. Семафор со счетчиком позволяет n 
задачам одновременно обращаться к ресурсу. Можно считать, что семафор 
«выдает разрешения» на использование ресурса, хотя никаких реальных 
объектов разрешений в этой схеме нет.
В качестве примера рассмотрим концепцию пула объектов: объекты, входящие
 в пул, «выдаются» для использования, а затем снова возвращаются в пул 
после того, как пользователь закончит работу с ними. Эта 
функциональность инкапсулируется в параметризованном классе:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Pool.java</span>
<span class="co1">// Использование Semaphore в Pool ограничивает количество </span>
<span class="co1">// задач, которые могут использовать ресурс.</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Pool<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> size<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> items = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">boolean</span><span class="br0">[</span><span class="br0">]</span> checkedOut<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw47">Semaphore</span> available<span class="sy0">;</span>
  <span class="kw2">public</span> Pool<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> classObject, <span class="kw3">int</span> size<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">size</span> = size<span class="sy0">;</span>
    checkedOut = <span class="kw2">new</span> <span class="kw3">boolean</span><span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
    available = <span class="kw2">new</span> <span class="kw47">Semaphore</span><span class="br0">(</span>size, <span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Заполнение пула объектами&nbsp;:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> ++i<span class="br0">)</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="co1">// Предполагается наличие конструктора по умолчанию:</span>
        items.<span class="me1">add</span><span class="br0">(</span>classObject.<span class="me1">newInstance</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> T checkOut<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">InterruptedException</span> <span class="br0">{</span>
    available.<span class="me1">acquire</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> getItem<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> checkIn<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>releaseItem<span class="br0">(</span>x<span class="br0">)</span><span class="br0">)</span>
      available.<span class="me1">release</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">synchronized</span> T getItem<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> size<span class="sy0">;</span> ++i<span class="br0">)</span>
      <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>checkedOut<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span>
        checkedOut<span class="br0">[</span>i<span class="br0">]</span> = <span class="kw4">true</span><span class="sy0">;</span>
        <span class="kw2">return</span> items.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="kw2">return</span> <span class="kw4">null</span><span class="sy0">;</span>  <span class="co1">// Семафор предотвращает переход в зту точку</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">synchronized</span> <span class="kw3">boolean</span> releaseItem<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span> index = items.<span class="me1">indexOf</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>index == -<span class="nu0">1</span><span class="br0">)</span> <span class="kw2">return</span> <span class="kw4">false</span><span class="sy0">;</span> <span class="co1">// Отсутствует в списке</span>
    <span class="kw1">if</span><span class="br0">(</span>checkedOut<span class="br0">[</span>index<span class="br0">]</span><span class="br0">)</span> <span class="br0">{</span>
      checkedOut<span class="br0">[</span>index<span class="br0">]</span> = <span class="kw4">false</span><span class="sy0">;</span>
      <span class="kw2">return</span> <span class="kw4">true</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">return</span> <span class="kw4">false</span><span class="sy0">;</span> <span class="co1">// He был освобожден</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>В этой упрощенной форме конструктор использует <i><b>newInstance()</b></i> для заполнения пула объектами. Если вам понадобится новый объект, вызовите <i><b>checkOut()</b></i>; завершив работу с объектом, передайте его <i><b>checkIn()</b></i>.
</p><p>Логический массив <i><b>checkedOut</b></i> отслеживает выданные объекты. Для управления его содержимым используются методы <i><b>getItem()</b></i> и <i><b>releaseItem()</b></i>. В свою очередь, эти методы защищены семафором <i><b>available</b></i>, поэтому в <i><b>checkOut()</b></i> семафор <i><b>available</b></i> блокирует дальнейшее выполнение при отсутствии семафорных разрешений (то есть при отсутствии объектов в пуле). Метод <i><b>checkIn()</b></i> проверяет действительность возвращаемого объекта, и, если объект действителен, разрешение возвращается семафору.
</p><p>Для примера мы воспользуемся классом <i><b>Fat</b></i>. Создание объектов этого класса является высокозатратной операцией, а на выполнение конструктора уходит много времени:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/Fat.java</span>
<span class="co1">// Объекты, создание которых занимает много времени.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Fat <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> <span class="kw3">double</span> d<span class="sy0">;</span> <span class="co1">// Предотвращает оптимизацию</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">public</span> Fat<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Затратная, прервываемая операция:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10000</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      d += <span class="br0">(</span><span class="kw21">Math</span>.<span class="me1">PI</span> + <span class="kw21">Math</span>.<span class="me1">E</span><span class="br0">)</span> / <span class="br0">(</span><span class="kw3">double</span><span class="br0">)</span>i<span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> operation<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Fat id: "</span> + id<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Мы создадим пул объектов <i><b>Fat</b></i>, чтобы свести к минимуму затраты на выполнение конструктора. Для тестирования класса <i><b>Pool</b></i> будет создана задача, которая забирает объекты <i><b>Fat</b></i> для использования, удерживает их в течение некоторого времени, а затем возвращает обратно:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/SemaphoreDemo.java</span>
<span class="co1">// Тестирование класса Pool</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Задача для получения ресурса из пула:</span>
<span class="kw2">class</span> CheckoutTask<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> Pool<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> pool<span class="sy0">;</span>
  <span class="kw2">public</span> CheckoutTask<span class="br0">(</span>Pool<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> pool<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">pool</span> = pool<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      T item = pool.<span class="me1">checkOut</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"checked out "</span> + item<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="kw2">this</span> +<span class="st0">"checking in "</span> + item<span class="br0">)</span><span class="sy0">;</span>
      pool.<span class="me1">checkIn</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый способ завершения</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"CheckoutTask "</span> + id + <span class="st0">" "</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SemaphoreDemo <span class="br0">{</span>
  <span class="kw2">final</span> <span class="kw2">static</span> <span class="kw3">int</span> SIZE = <span class="nu0">25</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw2">final</span> Pool<span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span> pool =
      <span class="kw2">new</span> Pool<span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span>Fat.<span class="kw2">class</span>, SIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> SIZE<span class="sy0">;</span> i++<span class="br0">)</span>
      exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> CheckoutTask<span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span>pool<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"All CheckoutTasks created"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span> list = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> SIZE<span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      Fat f = pool.<span class="me1">checkOut</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      printnb<span class="br0">(</span>i + <span class="st0">": main() thread checked out "</span><span class="br0">)</span><span class="sy0">;</span>
      f.<span class="me1">operation</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      list.<span class="me1">add</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw47">Future</span><span class="sy0">&lt;?&gt;</span> blocked = exec.<span class="me1">submit</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw21">Runnable</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">try</span> <span class="br0">{</span>
          <span class="co1">// Семафор предотвращает лишний вызов checkout. </span>
          <span class="co1">// поэтому следующий вызов блокируется:</span>
          pool.<span class="me1">checkOut</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
          print<span class="br0">(</span><span class="st0">"checkOut() Interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    blocked.<span class="me1">cancel</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Выход из заблокированного вызова</span>
    print<span class="br0">(</span><span class="st0">"Checking in objects in "</span> + list<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Fat f&nbsp;: list<span class="br0">)</span>
      pool.<span class="me1">checkIn</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Fat f&nbsp;: list<span class="br0">)</span>
      pool.<span class="me1">checkIn</span><span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Второй вызов checkIn игнорируется</span>
    exec.<span class="me1">shutdown</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>В коде main() создается объект <i><b>Pool</b></i> для хранения объектов <i><b>Fat</b></i>, после чего группа задач <i><b>CheckoutTask</b></i> начинает использовать <i><b>Pool</b></i>. Далее поток <i><b>main()</b></i> начинает выдавать объекты <i><b>Fat</b></i>, не возвращая их обратно. После того как все объекты пула будут выданы, семафор запрещает дальнейшие выдачи. Метод <i><b>run()</b></i> блокируется, и через две секунды вызывается метод <i><b>cancel()</b></i>. Лишние возвраты <i><b>Pool</b></i> игнорирует.
</p><p><br>
</p>
<h2><span class="mw-headline" id="Exchanger">Exchanger</span></h2>
<p>Класс <i><b>Exchanger</b></i> представляет собой «барьер», который 
меняет местами объекты двух задач. На подходе к барьеру задачи имеют 
один объект, а на выходе — объект, ранее удерживавшийся другой задачей. 
Объекты <i><b>Exchanger</b></i> обычно исполь­зуются в тех ситуациях, 
когда одна задача создает высокозатратные объекты, а другая задача эти 
объекты потребляет.
</p><p>Чтобы опробовать на практике класс <i><b>Exchanger</b></i>, мы 
создадим задачу-поставщика и задачу-потребителя, которые благодаря 
параметризации и генераторам могут работать с объектами любого типа. 
Затем эти параметризованные задачи будут применены к классу <i><b>Fat</b></i>. <i><b>ExchangerProducer</b></i> и <i><b>ExchangerConsumer</b></i> меняют местами <i><b>List&lt;T&gt;</b></i>; при вызове метода <i><b>Exchanger.exchange()</b></i> вызов блокируется до тех пор, пока парная задача не вызовет свой метод <i><b>exchange()</b></i>, после чего оба метода <i><b>exchange()</b></i> завершаются, а контейнеры <i><b>List&lt;T&gt;</b></i> меняются местами:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/ExchangerDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> ExchangerProducer<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> generator<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span> exchanger<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder<span class="sy0">;</span>
  ExchangerProducer<span class="br0">(</span><span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span> exchg,
  Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> gen, <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder<span class="br0">)</span> <span class="br0">{</span>
    exchanger = exchg<span class="sy0">;</span>
    generator = gen<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">holder</span> = holder<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> ExchangerDemo.<span class="me1">size</span><span class="sy0">;</span> i++<span class="br0">)</span>
          holder.<span class="me1">add</span><span class="br0">(</span>generator.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Заполненный контейнер заменяется пустым::</span>
        holder = exchanger.<span class="me1">exchange</span><span class="br0">(</span>holder<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый способ завершения.</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> ExchangerConsumer<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span> exchanger<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">volatile</span> T value<span class="sy0">;</span>
  ExchangerConsumer<span class="br0">(</span><span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span> ex, <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder<span class="br0">)</span><span class="br0">{</span>
    exchanger = ex<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">holder</span> = holder<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        holder = exchanger.<span class="me1">exchange</span><span class="br0">(</span>holder<span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>T x&nbsp;: holder<span class="br0">)</span> <span class="br0">{</span>
          value = x<span class="sy0">;</span> <span class="co1">// Выборка значения</span>
          holder.<span class="me1">remove</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Нормально для CopyOnWriteArrayList</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// Приемлемый способ завершения.</span>
    <span class="br0">}</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Final value: "</span> + value<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ExchangerDemo <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">int</span> size = <span class="nu0">10</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">int</span> delay = <span class="nu0">5</span><span class="sy0">;</span> <span class="co1">// Секунды</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
      size = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span>
      delay = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;&gt;</span> xc = <span class="kw2">new</span> <span class="kw47">Exchanger</span><span class="sy0">&lt;</span><span class="kw166">List</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span>
      producerList = <span class="kw2">new</span> <span class="kw47">CopyOnWriteArrayList</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>,
      consumerList = <span class="kw2">new</span> <span class="kw47">CopyOnWriteArrayList</span><span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> ExchangerProducer<span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span>xc,
      BasicGenerator.<span class="me1">create</span><span class="br0">(</span>Fat.<span class="kw2">class</span><span class="br0">)</span>, producerList<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>
      <span class="kw2">new</span> ExchangerConsumer<span class="sy0">&lt;</span>Fat<span class="sy0">&gt;</span><span class="br0">(</span>xc,consumerList<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>delay<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>Final value: Fat id: 29999
</pre>
<p>&lt;/spoiler&gt;
В методе <i><b>main()</b></i> для обеих задач создается один объект <i><b>Exchanger</b></i>, а для перестановки создаются два контейнера <i><b>CopyOnWriteArrayList</b></i>. Эта разновидность <i><b>List</b></i> нормально переносит вызов метода <i><b>remove()</b></i> при перемещении по списку, не вы­давая исключения <i><b>ConcurrentModificationException</b></i>. 
</p><p><i><b>ExchangerProducer</b></i> заполняет список, а затем меняет местами заполненный список с пустым, передаваемым от <i><b>ExchangerConsumer</b></i>. Благодаря <i><b>Exchanger</b></i> заполнение списка происходит одно­временно с использованием уже заполненного списка.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D0.B5.D0.BB.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5">Моделирование</span></h2>
<p>Одна из самых интересных областей применения параллельных вычислений —
 всевозможные имитации и моделирование. Каждый компонент модели 
оформляется в виде отдельной задачи, что значительно упрощает его 
программирование.
</p><p>Примеры <i><b>HorseRace.java</b></i> и <i><b>GreenhouseScheduler.java</b></i>, приведенные ранее, тоже можно считать своего рода имитаторами.
</p>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D0.B5.D0.BB.D1.8C_.D0.BA.D0.B0.D1.81.D1.81.D0.B8.D1.80.D0.B0">Модель кассира</span></h3>
<p>В этой классической модели объекты появляются случайным образом и 
обслуживаются за случайное время ограниченным количеством серверов. 
Моделирование позволяет определить идеальное количество серверов. 
Продолжительность обслуживания в следующей модели зависит от клиента и 
определяется случайным образом. Вдобавок мы не знаем, сколько новых 
клиентов будет прибывать за каждый период времени, поэтому эта величина 
тоже определяется случайным образом.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: concurrency/BankTellerSimulation.java</span>
<span class="co1">// Пример использования очередей и многопоточного программирования..</span>
<span class="co1">// {Args: 5}</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// Объекты, доступные только для чтения, не требуют синхронизации:</span>
<span class="kw2">class</span> Customer <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> serviceTime<span class="sy0">;</span>
  <span class="kw2">public</span> Customer<span class="br0">(</span><span class="kw3">int</span> tm<span class="br0">)</span> <span class="br0">{</span> serviceTime = tm<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getServiceTime<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> serviceTime<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"["</span> + serviceTime + <span class="st0">"]"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Очередь клиентов умеет выводить информацию о своем состоянии:</span>
<span class="kw2">class</span> CustomerLine <span class="kw2">extends</span> <span class="kw47">ArrayBlockingQueue</span><span class="sy0">&lt;</span>Customer<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> CustomerLine<span class="br0">(</span><span class="kw3">int</span> maxLineSize<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>maxLineSize<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span><span class="kw2">this</span>.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> == <span class="nu0">0</span><span class="br0">)</span>
      <span class="kw2">return</span> <span class="st0">"[Empty]"</span><span class="sy0">;</span>
    <span class="kw21">StringBuilder</span> result = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Customer customer&nbsp;: <span class="kw2">this</span><span class="br0">)</span>
      result.<span class="me1">append</span><span class="br0">(</span>customer<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Случайное добавление клиентов в очередь:</span>
<span class="kw2">class</span> CustomerGenerator <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> CustomerLine customers<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> CustomerGenerator<span class="br0">(</span>CustomerLine cq<span class="br0">)</span> <span class="br0">{</span>
    customers = cq<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">300</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        customers.<span class="me1">put</span><span class="br0">(</span><span class="kw2">new</span> Customer<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"CustomerGenerator interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"CustomerGenerator terminating"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Teller <span class="kw2">implements</span> <span class="kw21">Runnable</span>, <span class="kw21">Comparable</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id = counter++<span class="sy0">;</span>
  <span class="co1">// Счетчик клиентов, обслуженных за текущую смену:</span>
  <span class="kw2">private</span> <span class="kw3">int</span> customersServed = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> CustomerLine customers<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">boolean</span> servingCustomerLine = <span class="kw4">true</span><span class="sy0">;</span>
  <span class="kw2">public</span> Teller<span class="br0">(</span>CustomerLine cq<span class="br0">)</span> <span class="br0">{</span> customers = cq<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        Customer customer = customers.<span class="me1">take</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>
          customer.<span class="me1">getServiceTime</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw2">synchronized</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span> <span class="br0">{</span>
          customersServed++<span class="sy0">;</span>
          <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span>servingCustomerLine<span class="br0">)</span>
            wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"terminating"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> doSomethingElse<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    customersServed = <span class="nu0">0</span><span class="sy0">;</span>
    servingCustomerLine = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">void</span> serveCustomerLine<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">assert</span> <span class="sy0">!</span>servingCustomerLine:<span class="st0">"already serving: "</span> + <span class="kw2">this</span><span class="sy0">;</span>
    servingCustomerLine = <span class="kw4">true</span><span class="sy0">;</span>
    notifyAll<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Teller "</span> + id + <span class="st0">" "</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> shortString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"T"</span> + id<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Используется приоритетной очередью:</span>
  <span class="kw2">public</span> <span class="kw2">synchronized</span> <span class="kw3">int</span> compareTo<span class="br0">(</span>Teller other<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> customersServed <span class="sy0">&lt;</span> other.<span class="me1">customersServed</span> <span class="sy0">?</span> -<span class="nu0">1</span>&nbsp;:
      <span class="br0">(</span>customersServed == other.<span class="me1">customersServed</span> <span class="sy0">?</span> <span class="nu0">0</span>&nbsp;: <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> TellerManager <span class="kw2">implements</span> <span class="kw21">Runnable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw47">ExecutorService</span> exec<span class="sy0">;</span>
  <span class="kw2">private</span> CustomerLine customers<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">PriorityQueue</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span> workingTellers =
    <span class="kw2">new</span> <span class="kw46">PriorityQueue</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">Queue</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span> tellersDoingOtherThings =
    <span class="kw2">new</span> <span class="kw46">LinkedList</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> adjustmentPeriod<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> TellerManager<span class="br0">(</span><span class="kw47">ExecutorService</span> e,
    CustomerLine customers, <span class="kw3">int</span> adjustmentPeriod<span class="br0">)</span> <span class="br0">{</span>
    exec = e<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">customers</span> = customers<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">adjustmentPeriod</span> = adjustmentPeriod<span class="sy0">;</span>
    <span class="co1">// Начинаем с одного кассира:</span>
    Teller teller = <span class="kw2">new</span> Teller<span class="br0">(</span>customers<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
    workingTellers.<span class="me1">add</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> adjustTellerNumber<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Фактически это система управления. Регулировка числовых </span>
    <span class="co1">// параметров позволяет выявить проблемы стабильности </span>
    <span class="co1">// в механизме управления.</span>
    <span class="co1">// Если очередь слишком длинна, добавить другого кассира:</span>
    <span class="kw1">if</span><span class="br0">(</span>customers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> / workingTellers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> <span class="nu0">2</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="co1">// Если кассиры отдыхают или заняты </span>
        <span class="co1">// другими делами, вернуть одного из них:</span>
        <span class="kw1">if</span><span class="br0">(</span>tellersDoingOtherThings.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
          Teller teller = tellersDoingOtherThings.<span class="me1">remove</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
          teller.<span class="me1">serveCustomerLine</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
          workingTellers.<span class="me1">offer</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
          <span class="kw2">return</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="co1">// Иначе создаем (нанимаем) нового кассира</span>
      Teller teller = <span class="kw2">new</span> Teller<span class="br0">(</span>customers<span class="br0">)</span><span class="sy0">;</span>
      exec.<span class="me1">execute</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
      workingTellers.<span class="me1">add</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">return</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1">// Если очередь достаточно коротка, освободить кассира:</span>
    <span class="kw1">if</span><span class="br0">(</span>workingTellers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> <span class="nu0">1</span> <span class="sy0">&amp;&amp;</span>
      customers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> / workingTellers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&lt;</span> <span class="nu0">2</span><span class="br0">)</span>
        reassignOneTeller<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Если очереди нет. достаточно одного кассира:</span>
    <span class="kw1">if</span><span class="br0">(</span>customers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> == <span class="nu0">0</span><span class="br0">)</span>
      <span class="kw1">while</span><span class="br0">(</span>workingTellers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&gt;</span> <span class="nu0">1</span><span class="br0">)</span>
        reassignOneTeller<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Поручаем кассиру другую работу или отправляем его отдыхать:</span>
  <span class="kw2">private</span> <span class="kw3">void</span> reassignOneTeller<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    Teller teller = workingTellers.<span class="me1">poll</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    teller.<span class="me1">doSomethingElse</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    tellersDoingOtherThings.<span class="me1">offer</span><span class="br0">(</span>teller<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="sy0">!</span><span class="kw21">Thread</span>.<span class="me1">interrupted</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span>adjustmentPeriod<span class="br0">)</span><span class="sy0">;</span>
        adjustTellerNumber<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>customers + <span class="st0">" { "</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span>Teller teller&nbsp;: workingTellers<span class="br0">)</span>
          <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>teller.<span class="me1">shortString</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"}"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">InterruptedException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"interrupted"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">this</span> + <span class="st0">"terminating"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"TellerManager "</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BankTellerSimulation <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> MAX_LINE_SIZE = <span class="nu0">50</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> ADJUSTMENT_PERIOD = <span class="nu0">1000</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw47">ExecutorService</span> exec = <span class="kw47">Executors</span>.<span class="me1">newCachedThreadPool</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Если очередь слишком длинна, клиенты уходят:</span>
    CustomerLine customers =
      <span class="kw2">new</span> CustomerLine<span class="br0">(</span>MAX_LINE_SIZE<span class="br0">)</span><span class="sy0">;</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> CustomerGenerator<span class="br0">(</span>customers<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// TellerManager добавляет и убирает кассиров </span>
    <span class="co1">// по мере необходимости:</span>
    exec.<span class="me1">execute</span><span class="br0">(</span><span class="kw2">new</span> TellerManager<span class="br0">(</span>
      exec, customers, ADJUSTMENT_PERIOD<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span> <span class="co1">// Необязательный аргумент</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Press 'Enter' to quit"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">in</span>.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    exec.<span class="me1">shutdownNow</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>[429][200][207] { T0 T1 }
[861][258][140][322] { T0 T1 }
[575][342][804][826][896][984] { T0 T1 T2 }
[984][810][141][12][689][992][976][368][395][354] { T0 T1 T2 T3 }
Teller 2 interrupted
Teller 2 terminating
Teller 1 interrupted
Teller 1 terminating
TellerManager interrupted
TellerManager terminating
Teller 3 interrupted
Teller 3 terminating
Teller 0 interrupted
Teller 0 terminating
CustomerGenerator interrupted
CustomerGenerator terminating
</pre>
<p>&lt;/spoiler&gt;
Объекты <i><b>Customer</b></i> очень просты; они содержат только поле данных <i><b>final int</b></i>.
 Так как эти объекты никогда не изменяют своего состояния, они являются 
объектами, доступными только для чтения, и поэтому требуют синхронизации
 или использования <i><b>volatile</b></i>. Вдобавок каждая задача <i><b>Teller</b></i> удаляет из очереди ввода только один объект <i><b>Customer</b></i> и работает с ним до завершения, поэтому задачи все равно будут работать с <i><b>Customer</b></i> последовательно.
</p><p>Класс <i><b>CustomerLine</b></i> представляет собой общую очередь, в которой клиенты ожидают обслуживания. Он реализован в виде очереди <i><b>ArrayBlockingQueue</b></i> с методом <i><b>toString()</b></i>, который выводит результаты в желаемом формате. Генератор <i><b>CustomerGenerator</b></i> присоединяется к <i><b>CustomerLine</b></i> и ставит объекты <i><b>Customer</b></i> в очередь со случайными интервалами.
</p><p><i><b>Teller</b></i> извлекает клиентов <i><b>Customer</b></i> из <i><b>CustomerLine</b></i>
 и обрабатывает их последовательно, подсчитывая количество клиентов, 
обслуженных за текущую смену. Если клиентов не хватает, его можно 
перевести на другую работу (<i><b>doSomethingElse()</b></i>), а при появлении большого количества клиентов — снова вернуть на обслуживание очереди методом <i><b>serveCustomerLine()</b></i>. Чтобы приказать следующему кассиру вернуться к очереди, метод <i><b>compareTo()</b></i>
 проверяет количество обслуженных клиентов, чтобы приоритетная очередь 
автоматически ставила в начало кассира, работавшего меньше других.
</p><p>Вся основная деятельность выполняется в <i><b>TellerManager</b></i>.
 Этот класс следит за всеми кассирами и за тем, что происходит с 
клиентами. Одна из интересных особенностей данной имитации заключается в
 том, что она пытается подобрать оптимальное количество кассиров для 
заданного потока покупателей. Пример встречается в методе <i><b>adjustTellerNumber()</b></i>
 — управляющей системе для надежной, стабильной регулировки количества 
кассиров. У всех управляющих систем в той или иной мере присутствуют 
проблемы со стабильностью; слишком быстрая реакция на изменения снижает 
стабильность, а слишком медленная переводит систему в одно из крайних 
состояний.
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5">Резюме</span></h2>
<p>В этой главе я постарался изложить основы многопоточного программирования с использованием потоков <i>Java</i>. Прочитав ее, читатель должен понять следующее:
</p>
<hr>
<ul>
<li><span style="color:#800000">Программу можно разделить на несколько независимых задач.</span>
</li>
<li><span style="color:#800000">Необходимо заранее предусмотреть всевозможные проблемы, возникающие при завершении задач.</span>
</li>
<li><span style="color:#800000">Задачи, работающие с общими ресурсами, 
могут мешать друг другу. Основным средством  предотвращения конфликтов 
является блокировка.</span>
</li>
<li><span style="color:#800000">В неаккуратно спроектированных многозадачных системах возможны взаимные блокировки.</span>
</li>
</ul>
<hr>
<p>Очень важно понимать, когда рационально использовать параллельное 
выполнение, а когда этого делать не стоит. Основные причины для его 
использования:
</p>
<hr>
<ul>
<li><span style="color:#800000">управление несколькими подзадачами, 
одновременное выполнение которых позволяет эффективнее распоряжаться 
ресурсами компьютера (включая возможность незаметного распределения этих
 задач  по нескольким процессорам);</span>
</li>
<li><span style="color:#800000">улучшенная организация кода;</span>
</li>
<li><span style="color:#800000">удобство для пользователя.</span>
</li>
</ul>
<hr>
<p>Классический пример распределения ресурсов — использование процессора
 во время ожидания завершения операций ввода/вывода. Классический пример
 чуткого пользовательского интерфейса — отслеживание нажатий кнопки 
«Пре­рвать» во время продолжительного процесса загрузки.
</p><p>Дополнительным преимуществом потоков является то, что они 
заменяют «тяжелое» переключение контекста процессов (порядка 1000 и 
более инструкций) «легким» переключением контекста выполнения (около 100
 инструкций). Так как все потоки процесса разделяют одно и то же 
пространство памяти, легкое переключение затрагивает только выполнение 
программы и локальные переменные. С другой стороны, чередование 
процессов — тяжелое переключение контекста — требует обновления всего 
пространства памяти.
</p><p>Основные недостатки многозадачности:
</p>
<hr>
<ul>
<li><span style="color:#800000">Замедление программы, связанное с ожиданием освобождения блокированных ресурсов.</span>
</li>
<li><span style="color:#800000">Дополнительная нагрузка на процессор для управления потоками.</span>
</li>
<li><span style="color:#800000">Совершенно ненужная сложность, являющаяся следствием неудачных решений при проектировании программы.</span>
</li>
<li><span style="color:#800000">Аномальные ситуации: взаимные блокировки, конфликты доступа, гонки и т. д.</span>
</li>
<li><span style="color:#800000">Непоследовательное поведение на 
различных платформах. Например, при разработке некоторых примеров для 
данной книги я обнаружил ситуации гонки, быстро проявлявшиеся на 
некоторых компьютерах, но незаметные на  других.</span>
</li>
</ul>
<hr>
<p>Пожалуй, основные трудности с потоками возникают тогда, когда 
несколько потоков одновременно пытаются использовать один и тот же 
ресурс — например, память объекта, и вы должны сделать так, чтобы этого 
ни в коем случае не произошло. Для этого нужно разумно использовать 
ключевое слово synchronized — полезный инструмент языка, который тем не 
менее необходимо хорошо понимать (без этого в программе может незаметно 
возникнуть опасность взаимной блокировки).
</p><p>Вдобавок многозадачное программирование сродни искусству. Язык <i>Java</i>
 существует для того, чтобы вы могли свободно создавать столько 
объектов, сколько вам нужно для решения вашей задачи — по крайней мере, в
 теории это так. (Например, создание миллионов объектов для проведения 
проекционно-разностного анализа вряд ли будет иметь смысл в <i>Java</i>.)
 Однако оказывается, что количество потоков упирается в определенный 
«потолок», так как после превышения этой-границы потоки становятся 
неподатливыми. Это критическое число трудно определить, зачастую оно 
зависит от операционной системы и виртуальной машины <i>Java</i>, 
значение может находиться где-то в районе сотни, а может исчисляться 
тысячами. Если для решения своей задачи вам требуется небольшая группа 
потоков, это ограничение не актуально, но при разработке больших 
программ оно может создать затруднения.

</p>
                <p><br>
                </p>
                <hr>
                <p><a href="http://wikijava.it-cache.net/index.php" title="Thinking in Java 4th edition">назад в Оглавление</a>
                </p><p><br>
                </p>
<!-- 
NewPP limit report
CPU time usage: 6.432 seconds
Real time usage: 6.438 seconds
Preprocessor visited node count: 680/1000000
Preprocessor generated node count: 1386/1000000
Post‐expand include size: 243/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wjava2-wj_:pcache:idhash:31-0!*!*!!ru!*!* and timestamp 20140812095848
 -->
</div>								<div class="printfooter">
				Источник — «<a href="http://wikijava.org.ua/index.php?title=Glava_17_Thinking_in_Java_4th_edition&amp;oldid=41">http://wikijava.org.ua/index.php?title=Глава_17_Thinking_in_Java_4th_edition&amp;oldid=41</a>»				</div>
                                <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8" title="Категория:Книги">Книги</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:Java" title="Категория:Java">Java</a></li></ul></div></div>												<div class="visualClear"></div>
            </div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Персональные инструменты</h3>
	<ul>
<li id="pt-login"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0+17+Thinking+in+Java+4th+edition" title="Здесь можно зарегистрироваться в системе, но это необязательно. [o]" accesskey="o">Представиться системе</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Пространства имён</h3>
	<ul>
					<!--<li  id="ca-nstab-main" class="selected"><span><a href="index.php@title=Glava_17_Thinking_in_Java_4th_edition.html"  title="Просмотр основной страницы [c]" accesskey="c">Статья</a></span></li>-->
					<!--<li  id="ca-talk" class="new"><span><a href="http://wikijava.org.ua/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;action=edit&amp;redlink=1"  title="Обсуждение основной страницы [t]" accesskey="t">Обсуждение</a></span></li>-->
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Варианты</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Просмотры</h3>
	<ul>
					<!--<li id="ca-view" class="selected"><span><a href="index.php@title=Glava_17_Thinking_in_Java_4th_edition.html" >Читать</a></span></li>-->
					<!--<li id="ca-viewsource"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;action=edit"  title="Эта страница защищена от изменений, но вы можете посмотреть и скопировать её исходный текст [e]" accesskey="e">Просмотр</a></span></li>-->
					<!--<li id="ca-history" class="collapsible"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;action=history"  title="Журнал изменений страницы [h]" accesskey="h">История</a></span></li>-->
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Действия</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_17_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Поиск</label></h3>
	<form action="http://wikijava.org.ua/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Поиск" title="Искать в WikiJava: Wiki of Java: викифицированные книги и статьи по Java [f]" accesskey="f" id="searchInput">						<button type="submit" name="button" title="Найти страницы, содержащие указанный текст" id="searchButton"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/search-ltr.asc" alt="Найти" height="13" width="12"></button>								<input name="title" value="Служебная:Поиск" type="hidden">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<!--<div id="p-logo" role="banner"><a style="background-image: url(/skins/common/images/wikijava.png);" href="index.php@title=Заглавная_страница.html"  title="Перейти на заглавную страницу"></a></div>-->
				<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
	<h3 id="p-navigation-label">Навигация</h3>
	<div class="body">
        <ul>
            <li id="n-mainpage-description"><a href="http://wikijava.org.ua/index.php?title=%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [z]" accesskey="z">Заглавная страница</a></li>
            <li id="n-recentchanges"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [r]" accesskey="r">Свежие правки</a></li>
            <li id="n-.D0.9A.D0.BD.D0.B8.D0.B3.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8_Java">Книги Java</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D1.8C.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D0%B8_Java">Статьи Java</a></li>
            <li id="n-Java-.D0.BF.D0.BE.D1.80.D1.82.D0.B0.D0.BB"><a href="http://wikijava.org.ua/index.php?title=Java-portal">Java портал</a></li>
            <li id="n-help"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Место, где можно получить справку">Справка</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.81.D1.82.D0.B8.D0.BA.D0.B0"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0">Статистика</a></li>
        </ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label">Инструменты</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition" title="Список всех страниц, ссылающихся на данную [j]" accesskey="j">Ссылки сюда</a></li>
			<li id="t-recentchangeslinked"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition" title="Последние изменения в страницах, на которые ссылается эта страница [k]" accesskey="k">Связанные правки</a></li>
			<li id="t-specialpages"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [q]" accesskey="q">Спецстраницы</a></li>
			<li id="t-print"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [p]" accesskey="p">Версия для печати</a></li>
			<li id="t-permalink"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;oldid=41" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
			<li id="t-info"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_17_Thinking_in_Java_4th_edition&amp;action=info">Сведения о странице</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B" aria-labelledby="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">
	<h3 id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">Другие проекты</h3>
	<div class="body">
		<ul>
			<li id="n-rastafara.com.ua"><a href="http://rastafara.com.ua/" rel="nofollow">rastafara.com.ua</a></li>
			<li id="n-rastafara-blog"><a href="http://sergey-rastafara.blogspot.com/" rel="nofollow">rastafara blog</a></li>
			<li id="n-rastaban"><a href="http://rastaban.com.ua/" rel="nofollow">rastaban</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 22:04, 16 февраля 2014.</li>
											<li id="footer-info-viewcount">К этой странице обращались 3958 раза.</li>
											<li id="footer-info-copyright">Содержимое доступно по лицензии <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 или более поздняя</a> (если не указано иное).</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Описание">Описание WikiJava: Wiki of Java: викифицированные книги и статьи по Java</a></li>
											<li id="footer-places-disclaimer"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Отказ от ответственности">Отказ от ответственности</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/copyleft/fdl.html"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/gnu-fdl.png" alt="GNU Free Documentation License 1.3 или более поздняя" height="31" width="88"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","ext.vector.simpleSearch","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.225 secs. -->
	

</body></html>