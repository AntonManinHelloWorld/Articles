<!DOCTYPE html>
<html dir="ltr" class="client-nojs" lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>Глава 5 Thinking in Java 4th edition — WikiJava: Wiki of Java: викифицированные книги и статьи по Java</title>
<meta name="generator" content="MediaWiki 1.22.2">
<link rel="shortcut icon" href="http://wikijava.it-cache.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wikijava.it-cache.net/opensearch_desc.php" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://wikijava.it-cache.net/api.php@action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java&nbsp;— Atom-лента" href="http://wikijava.it-cache.net/index.php@title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F%253A%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="stylesheet" href="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/style3.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wjava2-wj_:resourceloader:filter:minify-css:7:32e7e505403c81fe0a24e297ef166436 */</style>

<script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/style1.css"></script><script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/load.html"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Глава_5_Thinking_in_Java_4th_edition","wgTitle":"Глава 5 Thinking in Java 4th edition","wgCurRevisionId":29,"wgRevisionId":29,"wgArticleId":19,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Книги","Java"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Глава_5_Thinking_in_Java_4th_edition","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"simplesearch":true,"experiments":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"ru","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"ru"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wjava2-wj_:resourceloader:filter:minify-js:7:07bb1f4d2452379e70abca47c4cde6d9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java5.source-java5 .de1, .java5.source-java5 .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java5.source-java5  {font-family:monospace;}
.java5.source-java5 .imp {font-weight: bold; color: red;}
.java5.source-java5 li, .java5.source-java5 .li1 {font-weight: normal; vertical-align:top;}
.java5.source-java5 .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java5.source-java5 .li2 {font-weight: bold; vertical-align:top;}
.java5.source-java5 .kw1 {color: #000000;  font-weight: bold;}
.java5.source-java5 .kw2 {color: #000000; font-weight: bold;}
.java5.source-java5 .kw3 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw4 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw5 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw6 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw7 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw8 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw9 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw10 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw11 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw12 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw13 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw14 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw15 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw16 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw17 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw18 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw19 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw20 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw21 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw22 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw23 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw24 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw25 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw26 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw27 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw28 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw29 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw30 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw31 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw32 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw33 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw34 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw35 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw36 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw37 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw38 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw39 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw40 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw41 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw42 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw43 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw44 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw45 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw46 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw47 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw48 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw49 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw50 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw51 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw52 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw53 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw54 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw55 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw56 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw57 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw58 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw59 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw60 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw61 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw62 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw63 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw64 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw65 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw66 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw67 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw68 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw69 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw70 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw71 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw72 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw73 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw74 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw75 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw76 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw77 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw78 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw79 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw80 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw81 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw82 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw83 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw84 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw85 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw86 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw87 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw88 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw89 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw90 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw91 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw92 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw93 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw94 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw95 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw96 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw97 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw98 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw99 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw100 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw101 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw102 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw103 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw104 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw105 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw106 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw107 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw108 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw109 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw110 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw111 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw112 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw113 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw114 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw115 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw116 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw117 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw118 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw119 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw120 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw121 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw122 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw123 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw124 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw125 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw126 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw127 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw128 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw129 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw130 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw131 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw132 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw133 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw134 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw135 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw136 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw137 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw138 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw139 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw140 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw141 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw142 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw143 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw144 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw145 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw146 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw147 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw148 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw149 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw150 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw151 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw152 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw153 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw154 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw155 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw156 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw157 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw158 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw159 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw160 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw161 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw162 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw163 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw164 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw165 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw166 {color: #003399; font-weight: bold;}
.java5.source-java5 .co1 {color: #666666; font-style: italic;}
.java5.source-java5 .co2 {color: #006699;}
.java5.source-java5 .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java5.source-java5 .coMULTI {color: #666666; font-style: italic;}
.java5.source-java5 .es0 {color: #000099; font-weight: bold;}
.java5.source-java5 .br0 {color: #009900;}
.java5.source-java5 .sy0 {color: #339933;}
.java5.source-java5 .st0 {color: #0000ff;}
.java5.source-java5 .nu0 {color: #cc66cc;}
.java5.source-java5 .me1 {color: #006633;}
.java5.source-java5 .me2 {color: #006633;}
.java5.source-java5 .ln-xtra, .java5.source-java5 li.ln-xtra, .java5.source-java5 div.ln-xtra {background-color: #ffc;}
.java5.source-java5 span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Глава_5_Thinking_in_Java_4th_edition skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="ru"><span dir="auto">Глава 5 Thinking in Java 4th edition</span></h1>
			<div id="bodyContent">
								<div id="siteSub">Материал из WikiJava: Wiki of Java: викифицированные книги и статьи по Java</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#mw-navigation">навигация</a>, 					<a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#p-search">поиск</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="ru"><table style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;" cellpadding="0" cellspacing="0">
<tbody><tr>
<td> <div id="toc" class="toc"><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.9D.D0.98.D0.A6.D0.98.D0.90.D0.9B.D0.98.D0.97.D0.90.D0.A6.D0.98.D0.AF_.D0.98_.D0.97.D0.90.D0.92.D0.95.D0.A0.D0.A8.D0.95.D0.9D.D0.98.D0.95"><span class="tocnumber">1</span> <span class="toctext"><b>ИНИЦИАЛИЗАЦИЯ И ЗАВЕРШЕНИЕ</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80_.D0.B3.D0.B0.D1.80.D0.B0.D0.BD.D1.82.D0.B8.D1.80.D1.83.D0.B5.D1.82_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8E"><span class="tocnumber">1.1</span> <span class="toctext">Конструктор гарантирует инициализацию</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2"><span class="tocnumber">1.2</span> <span class="toctext">Перегрузка методов</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B0.D0.B7.D0.BB.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.BD.D1.8B.D1.85_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2"><span class="tocnumber">1.3</span> <span class="toctext">Различение перегруженных методов</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D1.81_.D0.BF.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.B0.D0.BC.D0.B8"><span class="tocnumber">1.4</span> <span class="toctext">Перегрузка с примитивами</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BF.D0.BE_.D0.B2.D0.BE.D0.B7.D0.B2.D1.80.D0.B0.D1.89.D0.B0.D0.B5.D0.BC.D1.8B.D0.BC_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F.D0.BC"><span class="tocnumber">1.5</span> <span class="toctext">Перегрузка по возвращаемым значениям</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D1.8B_.D0.BF.D0.BE_.D1.83.D0.BC.D0.BE.D0.BB.D1.87.D0.B0.D0.BD.D0.B8.D1.8E"><span class="tocnumber">1.6</span> <span class="toctext">Конструкторы по умолчанию</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_this"><span class="tocnumber">1.7</span> <span class="toctext">Ключевое слово this</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.92.D1.8B.D0.B7.D0.BE.D0.B2_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.B2_.D0.B8.D0.B7_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.B2"><span class="tocnumber">1.8</span> <span class="toctext">Вызов конструкторов из конструкторов</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.97.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B3.D0.BE_.D1.81.D0.BB.D0.BE.D0.B2.D0.B0_static"><span class="tocnumber">1.9</span> <span class="toctext">Значение ключевого слова static</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9E.D1.87.D0.B8.D1.81.D1.82.D0.BA.D0.B0:_.D1.84.D0.B8.D0.BD.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B8_.D1.81.D0.B1.D0.BE.D1.80.D0.BA.D0.B0_.D0.BC.D1.83.D1.81.D0.BE.D1.80.D0.B0"><span class="tocnumber">1.10</span> <span class="toctext">Очистка: финализация и сборка мусора</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.94.D0.BB.D1.8F_.D1.87.D0.B5.D0.B3.D0.BE_.D0.BD.D1.83.D0.B6.D0.B5.D0.BD_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4_finalize.28.29.3F"><span class="tocnumber">1.10.1</span> <span class="toctext">Для чего нужен метод finalize()?</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9E.D1.87.D0.B8.D1.81.D1.82.D0.BA.D0.B0_.E2.80.94_.D0.B2.D0.B0.D1.88_.D0.B4.D0.BE.D0.BB.D0.B3"><span class="tocnumber">1.10.2</span> <span class="toctext">Очистка — ваш долг</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.A3.D1.81.D0.BB.D0.BE.D0.B2.D0.B8.D0.B5_.C2.AB.D0.B3.D0.BE.D1.82.D0.BE.D0.B2.D0.BD.D0.BE.D1.81.D1.82.D0.B8.C2.BB"><span class="tocnumber">1.10.3</span> <span class="toctext">Условие «готовности»</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9A.D0.B0.D0.BA_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D0.B5.D1.82_.D1.81.D0.B1.D0.BE.D1.80.D1.89.D0.B8.D0.BA_.D0.BC.D1.83.D1.81.D0.BE.D1.80.D0.B0"><span class="tocnumber">1.10.4</span> <span class="toctext">Как работает сборщик мусора</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.87.D0.BB.D0.B5.D0.BD.D0.BE.D0.B2_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0"><span class="tocnumber">1.11</span> <span class="toctext">Инициализация членов класса</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.AF.D0.B2.D0.BD.D0.B0.D1.8F_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">1.11.1</span> <span class="toctext">Явная инициализация</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.BC"><span class="tocnumber">1.11.2</span> <span class="toctext">Инициализация конструктором</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8"><span class="tocnumber">1.11.3</span> <span class="toctext">Порядок инициализации</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.11.4</span> <span class="toctext">Инициализация статических данных</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.AF.D0.B2.D0.BD.D0.B0.D1.8F_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D1.87.D0.BB.D0.B5.D0.BD.D0.BE.D0.B2"><span class="tocnumber">1.11.5</span> <span class="toctext">Явная инициализация статических членов</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BD.D0.B5.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D1.8D.D0.BA.D0.B7.D0.B5.D0.BC.D0.BF.D0.BB.D1.8F.D1.80.D0.B0"><span class="tocnumber">1.11.6</span> <span class="toctext">Инициализация нестатических данных экземпляра</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BC.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D0.BE.D0.B2"><span class="tocnumber">1.12</span> <span class="toctext">Инициализация массивов</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.BE.D0.B2_.D0.BF.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D0.BE.D0.B9_.D0.B4.D0.BB.D0.B8.D0.BD.D1.8B"><span class="tocnumber">1.13</span> <span class="toctext">Списки аргументов переменной длины</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><span class="tocnumber">1.14</span> <span class="toctext">Резюме</span></a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>
<h1><span class="mw-headline" id=".D0.98.D0.9D.D0.98.D0.A6.D0.98.D0.90.D0.9B.D0.98.D0.97.D0.90.D0.A6.D0.98.D0.AF_.D0.98_.D0.97.D0.90.D0.92.D0.95.D0.A0.D0.A8.D0.95.D0.9D.D0.98.D0.95"><b>ИНИЦИАЛИЗАЦИЯ И ЗАВЕРШЕНИЕ</b></span></h1>
<p>В ходе компьютерной революции выяснилось, что основной причиной 
чрезмерных затрат в программировании является «небезопасное» 
программирование. Основные проблемы с безопасностью относятся к 
инициализации и завершению. Очень многие ошибки при программировании на 
языке <i>C</i> обусловлены неверной инициализацией переменных. Это 
особенно часто происходит при работе с библиотеками, когда пользователи 
не знают, как нужно инициализировать компонент библиотеки, или забывают 
это сделать. Завершение — очень акту­альная проблема; слишком легко 
забыть об элементе, когда вы закончили с ним работу и его дальнейшая 
судьба вас не волнует. В этом случае ресурсы, занимаемые элементом, не 
освобождаются, и в программе может возникнуть нехватка ресурсов (прежде 
всего памяти).
</p><p>В <i>C++</i> появилось понятие конструктора — специального 
метода, который вызывается при создании нового объекта. Конструкторы 
используются и в <i>Java</i>; к тому же в <i>Java</i> есть сборщик 
мусора, который автоматически освобождает ресурсы, когда объект 
перестает использоваться. В этой главе рассматриваются вопросы 
инициализации и завершения, а также их поддержка в <i>Java</i>.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80_.D0.B3.D0.B0.D1.80.D0.B0.D0.BD.D1.82.D0.B8.D1.80.D1.83.D0.B5.D1.82_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8E">Конструктор гарантирует инициализацию</span></h2>
<p>Конечно, можно создать особый метод, назвать его <i><b>initialize()</b></i>
 и включить во все ваши классы. Имя метода подсказывает пользователю, 
что он должен вызвать этот метод, прежде чем работать с объектом. К 
сожалению, это означает, что пользователь должен постоянно помнить о 
необходимости вызова данного метода. В <i>Java</i> разработчик класса 
может в обязательном порядке выполнить инициализацию каждого объекта при
 помощи специального метода, называемого конструктором. Если у класса 
имеется конструктор, <i>Java</i> автоматически
вызывает его при создании объекта, перед тем как пользователи смогут 
обратиться к этому объекту. Таким образом, инициализация объекта 
гарантирована.
</p><p>Как должен называться конструктор? Здесь есть две тонкости. 
Во-первых, любое имя, которое вы используете, может быть задействовано 
при определении членов класса; так возникает потенциальный конфликт 
имен. Во-вторых, за вызов конструктора отвечает компилятор, поэтому он 
всегда должен знать, какой именно метод следует вызвать. Реализация 
конструктора в <i>C++</i> кажется наиболее простым и логичным решением, поэтому оно использовано и в <i>Java</i>:
 имя конструктора совпадает с именем класса. Смысл такого решения 
очевиден — именно такой метод способен автоматически вызываться при 
инициализации.
Рассмотрим определение простого класса с конструктором:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/SimpleConstructor.java</span>
<span class="co1">// Demonstration of a simple constructor.</span>
<span class="co1">// Демонстрация простого конструктора</span>
<span class="kw2">class</span> Rock <span class="br0">{</span>
  Rock<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// This is the constructor</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"Rock "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimpleConstructor <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw2">new</span> Rock<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock
</pre>
<p>&lt;/spoiler&gt;
Теперь при создании объекта:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">new</span> Rock<span class="br0">(</span> <span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>выделяется память и вызывается конструктор. Тем самым гарантируется, 
что объект будет инициализирован, прежде чем программа сможет работать с
 ним.
</p><p>Заметьте, что стиль программирования, при котором имена методов 
начинаются со строчной буквы, к конструкторам не относится, поскольку 
имя конструктора должно точно совпадать с именем класса.
Подобно любому методу, у конструктора могут быть аргументы, для того 
чтобы позволить вам указать, как создать объект. Предыдущий пример легко
 изменить так, чтобы конструктору при вызове передавался аргумент:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/SimpleConstructor2.java</span>
<span class="co1">// Constructors can have arguments.</span>
<span class="co1">// Конструкторы могут получать аргументы</span>
<span class="kw2">class</span> Rock2 <span class="br0">{</span>
  Rock2<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"Rock "</span> + i + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimpleConstructor2 <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">8</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw2">new</span> Rock2<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Rock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7
</pre>
<p>&lt;/spoiler&gt;
В аргументах конструктора передаются параметры для инициализации объекта. Например, если у класса <i><b>Tree</b></i> (дерево) имеется конструктор, который получает в качестве аргумента целое число, обозначающее высоту дерева, то объекты <i><b>Tree</b></i> будут создаваться следующим образом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> Tree t = <span class="kw2">new</span> Тrее<span class="br0">(</span><span class="nu0">12</span><span class="br0">)</span>, <span class="co1">// 12-метровое дерево</span></pre></div></div>
<p>Если <i><b>Tree(int initialHeight)</b></i> является единственным конструктором класса, то компилятор не позволит создавать объекты <i><b>Tree</b></i>
 каким-либо другим способом.
Конструкторы устраняют большой пласт проблем и упрощают чтение кода. В 
предыдущем фрагменте кода не встречаются явные вызовы метода, подобного <i><b>initialize()</b></i>, который концептуально отделен от создания. В <i>Java</i> создание и инициализация являются неразделимыми понятиями — одно без другого невозможно.
</p><p>Конструктор — не совсем обычный метод, так как у него отсутствует
 возвращаемое значение. Это ощутимо отличается даже от случая с 
возвратом значения <i><b>void</b></i>, когда метод ничего не возвращает,
 но при этом все же можно заставить его вернуть что-нибудь другое. 
Конструкторы не возвращают никогда и ничего (оператор <i><b>new</b></i> 
возвращает ссылку на вновь созданный объект, но сами конструкторы не 
имеют выходного значения). Если бы у них существовало возвращаемое 
значение и его можно было бы выбирать, то компилятору пришлось бы как-то
 объяснять, что же делать с этим значением.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2">Перегрузка методов</span></h2>
<p>Одним из важнейших аспектов любого языка программирования является 
использование имен. Создавая объект, вы фактически присваиваете имя 
области памяти. Метод — имя для действия. Использование имен при 
описании системы упрощает ее понимание и модификацию. Работа 
программиста сродни работе писателя; в обоих случаях задача состоит в 
том, чтобы донести свою мысль до читателя.
</p><p>Проблемы возникают при перенесении нюансов человеческого языка в 
языки программирования. Часто одно и то же слово имеет несколько разных 
значений — оно перегружено. Это полезно, особенно в отношении простых 
различий. Вы говорите «вымыть посуду», «вымыть машину» и «вымыть 
собаку». Было бы глупо вместо этого говорить «посудоМыть посуду», 
«машиноМыть машину» и «собакоМыть собаку» только для того, чтобы 
слушатель не утруждал себя выявлением разницы между этими действиями. 
Большинство человеческих языков несет избыточность, и даже при пропуске 
некоторых слов определить смысл не так сложно. Уникальные имена не 
обязательны — сказанное можно понять из контекста.
</p><p>Большинство языков программирования (и в особенности <i>C</i>) требовали использования уникальных имен для всех функций. Иначе говоря, программа не могла содержать функцию <i><b>print()</b></i>
 для распечатки целых чисел и одноименную функцию для вывода 
вещественных чисел — каждая функция должна была иметь уникальное имя.
</p><p>В <i>Java</i> (и в <i>C++</i>) также существует другой фактор, 
который заставляет использовать перегрузку имен методов: наличие 
конструкторов. Так как имя конструктора предопределено именем класса, 
оно может быть только единственным. Но что, если вы захотите создавать 
объекты разными способами? Допустим, вы создаете класс с двумя 
вариантами инициализации: либо стандартно, либо на основании из 
некоторого файла. В этом случае необходимость двух конструкторов 
очевидна: один из них не имеет аргументов (конструктор по умолчанию, 
также называемый конструктором без аргументов (<i>no-arg</i>)), а другой
 получает в качестве аргумента строку с именем файла. Оба они являются 
полноценными конструкторами, и поэтому должны называться одинаково — 
именем класса. 
</p><p>Здесь перегрузка методов (<i>overloading</i>) однозначно 
необходима, чтобы мы могли использовать методы с одинаковыми именами, но
 с разными аргументами. И хотя перегрузка методов обязательна только для
 конструкторов, она удобна в принципе и может быть применена к любому 
методу.
Следующая программа показывает пример перегрузки как конструктора, так и
 обычного метода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Overloading.java</span>
<span class="co1">// Demonstration of both constructor</span>
<span class="co1">// and ordinary method overloading.</span>
<span class="co1">// Демонстрация перегрузки конструкторов наряду </span>
<span class="co1">// с перегрузкой обычных методов</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Tree <span class="br0">{</span>
  <span class="kw3">int</span> height<span class="sy0">;</span>
  Tree<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Planting a seedling"</span><span class="br0">)</span><span class="sy0">;</span>
    height = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Tree<span class="br0">(</span><span class="kw3">int</span> initialHeight<span class="br0">)</span> <span class="br0">{</span>
    height = initialHeight<span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Creating new Tree that is "</span> +
      height + <span class="st0">" feet tall"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw3">void</span> info<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Tree is "</span> + height + <span class="st0">" feet tall"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> info<span class="br0">(</span><span class="kw21">String</span> s<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span>s + <span class="st0">": Tree is "</span> + height + <span class="st0">" feet tall"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Overloading <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      Tree t = <span class="kw2">new</span> Tree<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
      t.<span class="me1">info</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      t.<span class="me1">info</span><span class="br0">(</span><span class="st0">"overloaded method"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="co1">// Перегруженный конструктор:</span>
    <span class="kw2">new</span> Tree<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method: Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method: Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method: Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method: Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method: Tree is 4 feet tall
Planting a seedling
</pre>
<p>&lt;/spoiler&gt;
Объект <i><b>Tree</b></i> (дерево) может быть создан или в форме ростка 
(без аргументов), или в виде «взрослого растения» с некоторой высотой. 
Для этого в классе определяются два конструктора; один используется по 
умолчанию, а другой получает аргумент с высотой дерева.
Возможно, вы захотите вызывать метод <i><b>info()</b></i> несколькими способами. Например, вызов с аргументом-строкой <i><b>info(String)</b></i> используется при необходимости вывода дополнительной информации, а вызов без аргументов <i><b>info()</b></i>
 — когда дополнений к сообщению метода не требуется. Было бы странно 
давать два разных имени методам, когда их схожесть столь очевидна. К 
счастью, перегрузка методов позволяет использовать одно и то же имя для 
обоих методов.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B0.D0.B7.D0.BB.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.BD.D1.8B.D1.85_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2">Различение перегруженных методов</span></h2>
<p>Если у методов одинаковые имена, как <i>Java</i> узнает, какой именно
 из них вызывается? Ответ прост: каждый перегруженный метод должен иметь
 уникальный список типов аргументов.
</p><p>Если немного подумать, такой подход оказывается вполне логичным. 
Как еще различить два одноименных метода, если не по типу аргументов?
</p><p>Даже разного порядка аргументов достаточно для того, чтобы методы
 считались разными (хотя описанный далее подход почти не используется, 
так как он усложняет сопровождение программного кода):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/OverloadingOrder.java</span>
<span class="co1">// Overloading based on the order of the arguments.</span>
<span class="co1">// Перегрузка, основанная на порядке </span>
<span class="co1">// следования аргументов</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> OverloadingOrder <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="kw21">String</span> s, <span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"String: "</span> + s + <span class="st0">", int: "</span> + i<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="kw3">int</span> i, <span class="kw21">String</span> s<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"int: "</span> + i + <span class="st0">", String: "</span> + s<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    f<span class="br0">(</span><span class="st0">"String first"</span>, <span class="nu0">11</span><span class="br0">)</span><span class="sy0">;</span>
    f<span class="br0">(</span><span class="nu0">99</span>, <span class="st0">"Int first"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>String: String first, int: 11
int: 99, String: Int first
</pre>
<p>&lt;/spoiler&gt;
Два метода <i><b>f()</b></i> имеют одинаковые аргументы с разным порядком следования, и это различие позволяет идентифицировать метод.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D1.81_.D0.BF.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.B0.D0.BC.D0.B8">Перегрузка с примитивами</span></h2>
<p>Простейший тип может быть автоматически приведен от меньшего типа к 
большему, и это в состоянии привнести немалую путаницу в перегрузку. 
Следующий пример показывает, что происходит при передаче примитивного 
типа пе­регруженному методу:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/PrimitiveOverloading.java</span>
<span class="co1">// Promotion of primitives and overloading.</span>
<span class="co1">// Повышение примитивных типов и перегрузка</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PrimitiveOverloading <span class="br0">{</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(char) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(byte) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(short) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(int) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(long) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f1(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(byte) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(short) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(int) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(long) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f2(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f3(short) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f3(int) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f3(long) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f3(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f3(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f4(int) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f4(long) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f4(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f4(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f5(long) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f5(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f5(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f6<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f6(float) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f6<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f6(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f7<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> printnb<span class="br0">(</span><span class="st0">"f7(double) "</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> testConstVal<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    printnb<span class="br0">(</span><span class="st0">"5: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testChar<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">char</span> x = <span class="st0">'x'</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"char: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testByte<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">byte</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"byte: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testShort<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">short</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"short: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testInt<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"int: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testLong<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">long</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"long: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testFloat<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">float</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"float: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> testDouble<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">double</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"double: "</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f5<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    PrimitiveOverloading p =
      <span class="kw2">new</span> PrimitiveOverloading<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testConstVal</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testChar</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testByte</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testShort</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testInt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testLong</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testFloat</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testDouble</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>5: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
char: f1(char) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
byte: f1(byte) f2(byte) f3(short) f4(int) f5(long) f6(float) f7(double)
short: f1(short) f2(short) f3(short) f4(int) f5(long) f6(float) f7(double)
int: f1(int) f2(int) f3(int) f4(int) f5(long) f6(float) f7(double)
long: f1(long) f2(long) f3(long) f4(long) f5(long) f6(float) f7(double)
float: f1(float) f2(float) f3(float) f4(float) f5(float) f6(float) f7(double)
double: f1(double) f2(double) f3(double) f4(double) f5(double) f6(double) f7(double)
</pre>
<p>&lt;/spoiler&gt;
Если вы рассмотрите результат работы программы, то увидите, что константа <i>5</i> трактуется как <i><b>int</b></i>, поэтому если есть перегруженный метод, принимающий аргумент типа <i><b>int</b></i>,
 то он и используется. Во всех остальных случаях, если имеется тип 
данных, «меньший», чем требуется для существующего метода, то этот тип 
данных повышается соответственным образом. Только тип <i><b>char</b></i> ведет себя несколько иначе по той причине, что, если метода с параметром <i><b>char</b></i> нет, этот тип приводится сразу к типу <i><b>int</b></i>, а не к промежуточным типам <i><b>byte</b></i> или <i><b>short</b></i>.
</p><p>Что же произойдет, если ваш аргумент «больше», чем аргумент, 
требующийся в перегруженном методе? Ответ можно найти в модификации 
рассмотренной программы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Demotion.java</span>
<span class="co1">// Demotion of primitives and overloading.</span>
<span class="co1">// Понижение примитивов и перегрузка.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Demotion <span class="br0">{</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(short)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(int)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(long)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(float)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">double</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f1(double)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(short)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(int)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(long)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">float</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f2(float)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f3(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f3(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f3(short)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f3(int)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">long</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f3(long)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f4(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f4(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f4(short)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f4<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f4(int)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f5(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f5(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f5<span class="br0">(</span><span class="kw3">short</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f5(short)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f6<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f6(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f6<span class="br0">(</span><span class="kw3">byte</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f6(byte)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> f7<span class="br0">(</span><span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f7(char)"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw3">void</span> testDouble<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">double</span> x = <span class="nu0">0</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"double argument:"</span><span class="br0">)</span><span class="sy0">;</span>
    f1<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>f2<span class="br0">(</span><span class="br0">(</span><span class="kw3">float</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>f3<span class="br0">(</span><span class="br0">(</span><span class="kw3">long</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>f4<span class="br0">(</span><span class="br0">(</span><span class="kw3">int</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>
    f5<span class="br0">(</span><span class="br0">(</span><span class="kw3">short</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>f6<span class="br0">(</span><span class="br0">(</span><span class="kw3">byte</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>f7<span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>x<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Demotion p = <span class="kw2">new</span> Demotion<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    p.<span class="me1">testDouble</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>double argument:
f1(double)
f2(float)
f3(long)
f4(int)
f5(short)
f6(byte)
f7(char)
</pre>
<p>&lt;/spoiler&gt;
Здесь методы требуют сужения типов данных. Если ваш аргумент «шире», 
необходимо явно привести его к нужному типу. В противном случае 
компилятор выведет сообщение об ошибке.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BF.D0.BE_.D0.B2.D0.BE.D0.B7.D0.B2.D1.80.D0.B0.D1.89.D0.B0.D0.B5.D0.BC.D1.8B.D0.BC_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F.D0.BC">Перегрузка по возвращаемым значениям</span></h2>
<p>Вполне логично спросить, почему при перегрузке используются только 
имена классов и списки аргументов? Почему не идентифицировать методы по 
их возвращаемым значениям? Следующие два метода имеют одинаковые имена и
 ар­гументы, но их легко отличить друг от друга:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> 
 <span class="kw3">int</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span></pre></div></div>
<p>Такой подход прекрасно сработает в ситуации, в которой компилятор может однозначно выбрать нужную версию метода, например: <i><b>int х = f()</b></i>.
 Однако возвращаемое значение при вызове метода может быть 
проигнорировано; это часто называется вызовом метода для получения 
побочного эффекта, так как метод вызывается не для естественного 
результата, а для каких-то других целей. Допустим, метод вызывается 
следующим способом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Как здесь <i>Java</i> определит, какая из версий метода <i><b>f()</b></i>
 должна выполняться? И поймет ли читатель программы, что происходит при 
этом вызове? Именно из-за подобных проблем перегруженные методы не 
разрешается различать по возвращаемым значениям.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D1.8B_.D0.BF.D0.BE_.D1.83.D0.BC.D0.BE.D0.BB.D1.87.D0.B0.D0.BD.D0.B8.D1.8E">Конструкторы по умолчанию</span></h2>
<p>Как упоминалось ранее, конструктором по умолчанию называется 
конструктор без аргументов, применяемый для создания «типового» объекта.
 Если созданный вами класс не имеет конструктора, компилятор 
автоматически добавит конструктор по умолчанию. Например:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/DefaultConstructor.java</span>
<span class="kw2">class</span> Bird <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DefaultConstructor <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Bird b = <span class="kw2">new</span> Bird<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Default!</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>создает новый объект и вызывает конструктор по умолчанию, хотя 
последний и не был явно определен в классе. Без него не существовало бы 
метода для построения объекта класса из данного примера. Но если вы уже 
определили некоторый конструктор (или несколько конструкторов, с 
аргументами или без), компилятор не будет генерировать конструктор по 
умолчанию:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/NoSynthesis.java</span>
<span class="kw2">class</span> Bird2 <span class="br0">{</span>
  Bird2<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  Bird2<span class="br0">(</span><span class="kw3">double</span> d<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> NoSynthesis <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">//! Bird2 b = new Bird2(); // No default</span>
    Bird2 b2 = <span class="kw2">new</span> Bird2<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    Bird2 b3 = <span class="kw2">new</span> Bird2<span class="br0">(</span><span class="nu0">1.0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Теперь при попытке выполнения <i><b>new Bird2()</b></i> компилятор 
заявит, что не может найти конструктор, подходящий по описанию. 
Получается так: если определения конструкторов отсутствуют, компилятор 
скажет: «Хотя бы один конструктор необходим, позвольте создать его за 
вас». Если же вы записываете конструктор явно, компилятор говорит: «Вы 
написали конструктор, а следовательно, знаете, что вам нужно; и если вы 
создали конструктор по умолчанию, значит, он вам и не нужен».
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_this">Ключевое слово this</span></h2>
<p>Если у вас есть два объекта одинакового типа с именами <i><b>а</b></i> и <i><b>b</b></i>, вы, возможно, заинтересуетесь, каким образом производится вызов метода <i><b>peel()</b></i> для обоих объектов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/BananaPeel.java</span>
<span class="kw2">class</span> Banana <span class="br0">{</span> <span class="kw3">void</span> peel<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* ... */</span> <span class="br0">}</span> <span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BananaPeel <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Banana a = <span class="kw2">new</span> Banana<span class="br0">(</span><span class="br0">)</span>,
           b = <span class="kw2">new</span> Banana<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    a.<span class="me1">peel</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    b.<span class="me1">peel</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Если существует только один метод с именем <i><b>peel()</b></i>, как этот метод узнает, для какого объекта он вызывается — <i><b>а</b></i> или <i><b>b</b></i>?
</p><p>Чтобы программа могла записываться в объектно-ориентированном 
стиле, основанном на «отправке сообщений объектам», компилятор выполняет
 для вас некоторую тайную работу. При вызове метода <i><b>peel()</b></i>
 передается скрытый первый аргумент — не что иное, как ссылка на 
используемый объект. Таким образом, вызовы указанного метода на самом 
деле можно представить как:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> Banana.рееl<span class="br0">(</span>a,<span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
 Banana.<span class="me1">peel</span><span class="br0">(</span>b,<span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Передача дополнительного аргумента относится к внутреннему 
синтаксису. При попытке явно воспользоваться ею компилятор выдает 
сообщение об ошибке, но вы примерно представляете суть происходящего.
</p><p>Предположим, во время выполнения метода вы хотели бы получить 
ссылку на текущий объект. Так как эта ссылка передается компилятором 
скрытно, идентификатора для нее не существует. Но для решения этой 
задачи существует ключевое слово — <i><b>this</b></i>. Ключевое слово <i><b>this</b></i>
 может использоваться только внутри не-статического метода и 
предоставляет ссылку на объект, для которого был вызван метод. 
Обращаться с ней можно точно так же, как и с любой другой ссылкой на 
объект. Помните, что при вызове метода вашего класса из другого метода 
этого класса <i><b>this</b></i> вам не нужно; просто укажите имя метода. Текущая ссылка <i><b>this</b></i> будет автоматически использована в другом методе. Таким образом, продолжая сказанное:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Apricot.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Apricot <span class="br0">{</span>
  <span class="kw3">void</span> pick<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="coMULTI">/* ... */</span> <span class="br0">}</span>
  <span class="kw3">void</span> pit<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> pick<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="coMULTI">/* ... */</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Внутри метода <i><b>pit()</b></i> можно использовать запись <i><b>this.pick()</b></i>, но в этом нет необходимости. Компилятор сделает это автоматически. Ключевое слово <i><b>this</b></i>
 употребляется только в особых случаях, когда вам необходимо явно 
сослаться на текущий объект. Например, оно часто применяется для 
возврата ссылки на текущий объект в команде <i><b>return</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Leaf.java</span>
<span class="co1">// Simple use of the "this" keyword.</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Leaf <span class="br0">{</span>
  <span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span>
  Leaf increment<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    i++<span class="sy0">;</span>
    <span class="kw2">return</span> <span class="kw2">this</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> print<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"i = "</span> + i<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Leaf x = <span class="kw2">new</span> Leaf<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">increment</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">increment</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">increment</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">print</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>i = 3
</pre>
<p>&lt;/spoiler&gt;
Так как метод <i><b>increment()</b></i> возвращает ссылку на текущий объект посредством ключевого слова <i><b>this</b></i>, над одним и тем же объектом легко можно провести множество операций.
Ключевое слово <i><b>this</b></i> также может пригодиться для передачи текущего объекта другому методу:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/PassingThis.java</span>
&nbsp;
<span class="kw2">class</span> Person <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> eat<span class="br0">(</span>Apple apple<span class="br0">)</span> <span class="br0">{</span>
    Apple peeled = apple.<span class="me1">getPeeled</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Yummy"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Peeler <span class="br0">{</span>
  <span class="kw2">static</span> Apple peel<span class="br0">(</span>Apple apple<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// ... remove peel</span>
    <span class="kw2">return</span> apple<span class="sy0">;</span> <span class="co1">// Peeled</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Apple <span class="br0">{</span>
  Apple getPeeled<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> Peeler.<span class="me1">peel</span><span class="br0">(</span><span class="kw2">this</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PassingThis <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">new</span> Person<span class="br0">(</span><span class="br0">)</span>.<span class="me1">eat</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Yummy
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Apple</b></i> вызывает <i><b>Peeler.peel()</b></i> — вспомогательный метод, который по какой-то причине должен быть оформлен как внешний по отношению к <i><b>Apple</b></i>
 (может быть, он должен обслуживать несколько разных классов, и вы 
хотите избежать дублирования кода). Для передачи текущего объекта 
внешнему методу используется ключевое слово <i><b>this</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D1.8B.D0.B7.D0.BE.D0.B2_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.B2_.D0.B8.D0.B7_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.B2">Вызов конструкторов из конструкторов</span></h2>
<p>Если вы пишете для класса несколько конструкторов, иногда бывает 
удобно вызвать один конструктор из другого, чтобы избежать дублирования 
кода. Такая операция проводится с использованием ключевого слова <i><b>this</b></i>.
Обычно при употреблении <i><b>this</b></i> подразумевается «этот объект»
 или «текущий объект», и само слово является ссылкой на текущий объект. В
 конструкторе ключевое слово <i><b>this</b></i> имеет другой смысл: при 
использовании его со списком аргументов вызывается конструктор, 
соответствующий данному списку. Таким образом, появляется возможность 
прямого вызова других конструкторов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Flower.java</span>
<span class="co1">// Calling constructors with "this"</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Flower <span class="br0">{</span>
  <span class="kw3">int</span> petalCount = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw21">String</span> s = <span class="st0">"initial value"</span><span class="sy0">;</span>
  Flower<span class="br0">(</span><span class="kw3">int</span> petals<span class="br0">)</span> <span class="br0">{</span>
    petalCount = petals<span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Constructor w/ int arg only, petalCount= "</span>
      + petalCount<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Flower<span class="br0">(</span><span class="kw21">String</span> ss<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Constructor w/ String arg only, s = "</span> + ss<span class="br0">)</span><span class="sy0">;</span>
    s = ss<span class="sy0">;</span>
  <span class="br0">}</span>
  Flower<span class="br0">(</span><span class="kw21">String</span> s, <span class="kw3">int</span> petals<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span><span class="br0">(</span>petals<span class="br0">)</span><span class="sy0">;</span>
<span class="co1">//!    this(s); // Can't call two!</span>
    <span class="kw2">this</span>.<span class="me1">s</span> = s<span class="sy0">;</span> <span class="co1">// Another use of "this"</span>
    print<span class="br0">(</span><span class="st0">"String &amp; int args"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Flower<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span><span class="br0">(</span><span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"default constructor (no args)"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> printPetalCount<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
<span class="co1">//! this(11); // Not inside non-constructor!</span>
    print<span class="br0">(</span><span class="st0">"petalCount = "</span> + petalCount + <span class="st0">" s = "</span>+ s<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Flower x = <span class="kw2">new</span> Flower<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">printPetalCount</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Constructor w/ int arg only, petalCount= 47
String &amp; int args
default constructor (no args)
petalCount = 47 s = hi
</pre>
<p>&lt;/spoiler&gt;
Конструктор <i><b>Flower(String s, int petals)</b></i> показывает, что при вызове одного конструктора через <i><b>this</b></i>
 вызывать второй запрещается. Вдобавок вызов другого конструктора должен
 быть первой выполняемой операцией, иначе компилятор выдаст сообщение об
 ошибке.
</p><p>Пример демонстрирует еще один способ использования <i><b>this</b></i>. Так как имена аргумента <i><b>s</b></i> и поля данных класса <i><b>s</b></i> совпадают, возникает неоднозначность. Разрешить это затруднение можно при помощи конструкции <i><b>this.s</b></i>, однозначно оп­ределяющей поле данных класса. Вы еще не раз встретите такой подход в различных <i>Java</i>-программах, да и в этой книге он практикуется довольно часто.
</p><p>Метод <i><b>printPetalCount()</b></i> показывает, что компилятор не разрешает вызывать конструктор из обычного метода; это разрешено только в конструкторах.
</p>
<h2><span class="mw-headline" id=".D0.97.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B3.D0.BE_.D1.81.D0.BB.D0.BE.D0.B2.D0.B0_static">Значение ключевого слова static</span></h2>
<p>Ключевое слово <i><b>this</b></i> поможет лучше понять, что же фактически означает объявление статического (<i><b>static</b></i>) метода. У таких методов не существует ссылки <i><b>this</b></i>.
 Вы не в состоянии вызывать нестатические методы из статических (хотя 
обратное позволено), и статические методы можно вызывать для имени 
класса, без каких-либо объектов. Статические методы отчасти напоминают 
глобальные функции языка <i>C</i>, но с некоторыми исключениями: глобальные функции не разрешены в <i>Java</i>, и создание статического метода внутри класса дает ему право на доступ к другим статическим методам и полям.
</p><p>Некоторые люди утверждают, что статические методы со своей 
семантикой глобальной функции противоречат объектно-ориентированной 
парадигме; в случае использования статического метода вы не посылаете 
сообщение объекту, поскольку отсутствует ссылка <i><b>this</b></i>. 
Возможно, что это справедливый упрек, и если вы обнаружите, что 
используете слишком много статических методов, то стоит пересмотреть 
вашу стратегию разработки программ. Однако ключевое слово static полезно
 на практике, и в некоторых ситуациях они определенно необходимы. Споры 
же о «чистоте ООП» лучше оставить теоретикам.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9E.D1.87.D0.B8.D1.81.D1.82.D0.BA.D0.B0:_.D1.84.D0.B8.D0.BD.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B8_.D1.81.D0.B1.D0.BE.D1.80.D0.BA.D0.B0_.D0.BC.D1.83.D1.81.D0.BE.D1.80.D0.B0">Очистка: финализация и сборка мусора</span></h2>
<p>Программисты помнят и знают о важности инициализации, но часто 
забывают о значимости «приборки». Да и зачем, например, «прибирать» 
после использования обычной переменной <i><b>int</b></i>? Но при 
использовании программных библиотек «просто забыть» об объекте после 
завершения его работы не всегда безопасно. Конечно, в <i>Java</i> 
существует сборщик мусора, освобождающий память от ненужных объектов. Но
 представим себе необычную ситуацию. Предположим, что объект выделяет 
«специальную» память без использования оператора <i><b>new</b></i>. Сборщик мусора умеет освобождать память, выделенную <i><b>new</b></i>, но ему неизвестно, как следует очищать специфическую память объекта. 
</p><p>Для таких ситуаций в <i>Java</i> предусмотрен метод <i><b>finalize()</b></i>,
 который вы можете определить в вашем классе. Вот как он должен 
работать: когда сборщик мусора готов освободить память, использованную 
вашим объектом, он для начала вызывает метод <i><b>finalize()</b></i>. Hо только после этого освобождает занимаемую объектом память. Таким образом, метод <i><b>finalize()</b></i> позволяет выполнять завершающие действия во время работы сборщика мусора.
</p><p>Все это может создать немало проблем для программистов, особенно для программистов на языке <i>C++</i>, так как они могут спутать метод <i><b>finalize()</b></i> с деструктором языка <i>C++</i> — функцией, всегда вызываемой перед разрушением объекта. Но здесь очень важно понять разницу между <i>Java</i> и <i>C++</i>, поскольку в <i>C++</i> объекты разрушаются всегда (в правильно написанной программе), в то время как в <i>Java</i> объекты удаляются сборщиком мусора не во всех случаях. Другими словами:
</p><p><span style="color:#800000"><b>ВНИМАНИЕ----------------------------------------------------</b></span>
</p>
<ul>
<li><span style="color:#800000"><b>1.  Ваши объекты могут быть и не переданы сборщику мусора.</b></span>
</li>
<li><span style="color:#800000"><b>2.  Сборка мусора не является удалением.</b></span>
</li>
</ul>
<p>Если программа завершает свою работу и сборщик мусора не удалил ни 
одного объекта и не освободил занимаемую память, то эта память будет 
возвращена операционной системе после завершения работы программы. Это 
хорошо, так как сборка мусора сопровождается весомыми издержками, и если
 сборщик не используется, то, соответственно, эти издержки не 
проявляются.
</p>
<h3><span class="mw-headline" id=".D0.94.D0.BB.D1.8F_.D1.87.D0.B5.D0.B3.D0.BE_.D0.BD.D1.83.D0.B6.D0.B5.D0.BD_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4_finalize.28.29.3F">Для чего нужен метод finalize()?</span></h3>
<p>Итак, если метод <i><b>finalize()</b></i> не стоит использовать для проведения стандартных операций завершения, то для чего же он нужен? Запомните третье правило:
</p><p><span style="color:#800000"> <b>ВНИМАНИЕ ------------------------------------------</b></span>
</p>
<ul>
<li><span style="color:#800000"><b>3. Процесс сборки мусора относится только к памяти.</b></span>
</li>
</ul>
<p>Единственная причина существования сборщика мусора — освобождение 
памяти, которая перестала использоваться вашей программой. Поэтому все 
действия, так или иначе связанные со сбором мусора, особенно те, что 
записаны в методе <i><b>finalize()</b></i>, должны относиться к управлению и освобождению памяти.
</p><p>Но значит ли это, что если ваш объект содержит другие объекты, то в <i><b>finalize()</b></i>
 они должны явно удаляться? Нет — сборщик мусора займется освобождением 
памяти и удалением объектов вне зависимости от способа их создания. 
Получается, что использование метода <i><b>finalize()</b></i> ограничено
 особыми случаями, в которых ваш объект размещается в памяти необычным 
способом, не связанным с прямым созданием экземпляра. Но, если в <i>Java</i> все является объектом, как же тогда такие особые случаи происходят?
</p><p>Похоже, что поддержка метода <i><b>finalize()</b></i> была введена в язык, чтобы сделать возможными операции с памятью в стиле <i>C</i>,
 с привлечением нестандартных механизмов выделения памяти. Это может 
произойти в основном при использовании методов, предоставляющих способ 
вызова He-<i>Java</i>-кода из программы на <i>Java</i>. <i>C</i> и <i>C++</i> пока являются единственными поддерживаемыми языками, но, так как для них таких ограничений нет, в действительности программа <i>Java</i> может вызвать любую процедуру или функцию на любом языке. Во внешнем коде можно выделить память вызовом функций <i>C</i>, относящихся к семейству <i>malloc()</i>. Если не воспользоваться затем функцией <i>free()</i>, произойдет «утечка» памяти. Конечно, функция <i>free()</i> тоже принадлежит к <i>C</i> и <i>C++</i>, поэтому придется в методе <i><b>finalize()</b></i> провести вызов еще одного «внешнего» метода.
</p><p>После прочтения этого абзаца у вас, скорее всего, сложилось мнение, что метод <i><b>finalize()</b></i>
 используется нечасто. И правда, это не то место, где следует проводить 
рутинные операции очистки. Но где же тогда эти обычные операции будут 
уместны?
</p>
<h3><span class="mw-headline" id=".D0.9E.D1.87.D0.B8.D1.81.D1.82.D0.BA.D0.B0_.E2.80.94_.D0.B2.D0.B0.D1.88_.D0.B4.D0.BE.D0.BB.D0.B3">Очистка — ваш долг</span></h3>
<p>Для очистки объекта его пользователю нужно вызвать соответствующий 
метод в той точке, где эти завершающие действия по откреплению и должны 
осуществляться. Звучит просто, но немного противоречит традиционным 
представлениям о деструкторах <i>C++</i>. В этом языке все объекты должны уничтожаться. Если объект <i>C++</i> создается локально (то есть в стеке, что невозможно в <i>Java</i>),
 то удаление и вызов деструктора происходит у закрывающей фигурной 
скобки, ограничивающей область действия такого объекта. Если же объект 
создается оператором <i>new</i> (как в <i>Java</i>), то деструктор вызывается при выполнении программистом оператора <i>C++</i> <i>delete</i> (не имеющего аналога в <i>Java</i>). А когда программист на <i>C++</i> забывает вызвать оператор <i>delete</i>,
 деструктор не вызывается и происходит «утечка» памяти, к тому же 
остальные части объекта не проходят необходимой очистки. Такого рода 
ошибки очень сложно найти и устранить, и они являются веским доводом в 
пользу перехода с <i>C++</i> на <i>Java</i>.
<i>Java</i> не позволяет создавать локальные объекты — все объекты должны быть результатом действия оператора new. Но в <i>Java</i> отсутствует аналог оператора <i>delete</i>,
 вызываемого для разрушения объекта, так как сборщик мусора и без того 
выполнит освобождение памяти. Значит, в несколько упрощенном изложении 
можно утверждать, что деструктор в <i>Java</i> отсутствует из-за 
присутствия сборщика мусора. Но в процессе чтения книги вы еще не раз 
убедитесь, что наличие сборщика мусора не устраняет необходимости в 
деструкторах или их аналогах. (И никогда не стоит вызывать метод <i><b>finalize()</b></i>
 непосредственно, так как этот подход не решает проблему.) Если же 
потребуется провести какие-то завершающие действия, отличные от 
освобождения памяти, все же придется явно вызвать подходящий метод, 
выполняющий функцию деструктора <i>C++</i>, но это уже не так удобно, как встроенный деструктор.
Помните, что ни сборка мусора, ни финализация не гарантированы. Если виртуальная машина <i>Java</i> (<i>Java Virtual Machine, JVM</i>)
 далека от критической точки расходования ресурсов, она не станет 
тратить время на освобождение памяти с использованием сборки мусора.
</p>
<h3><span class="mw-headline" id=".D0.A3.D1.81.D0.BB.D0.BE.D0.B2.D0.B8.D0.B5_.C2.AB.D0.B3.D0.BE.D1.82.D0.BE.D0.B2.D0.BD.D0.BE.D1.81.D1.82.D0.B8.C2.BB">Условие «готовности»</span></h3>
<p>В общем, вы не должны полагаться на вызов метода <i><b>finalize()</b></i> — создавайте отдельные «функции очистки» и вызывайте их явно. Скорее всего, <i><b>finalize()</b></i>
 пригодится только в особых ситуациях нестандартного освобождения 
памяти, с которыми большинство программистов никогда не сталкивается. 
Тем не менее существует очень интересное применение метода <i><b>finalize()</b></i>, не зависящее от того, вызывается ли он каждый раз или нет. Это проверка условия готовности объекта.
</p><p>В той точке, где объект становится ненужным — там, где он готов к
 проведению очистки, — этот объект должен находиться в состоянии, когда 
освобождение закрепленной за ним памяти безопасно. Например, если объект
 представляет открытый файл, то он должен быть соответствующим образом 
закрыт, перед тем как его «приберет» сборщик мусора. Если какая-то часть
 объекта не будет готова к уничтожению, результатом станет ошибка в 
программе, которую затем очень сложно обнаружить. Ценность <i><b>finalize()</b></i>
 в том и состоит, что он позволяет вам обнаружить такие ошибки, даже 
если и не всегда вызывается. Единожды проведенная финализация явным 
образом укажет на ошибку, а это все, что вам нужно.
Простой пример использования данного подхода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/TerminationCondition.java</span>
<span class="co1">// Использование finalize() для выявления объекта,</span>
<span class="co1">// не осуществившего необходимой финализации</span>
<span class="kw2">class</span> <span class="kw17">Book</span> <span class="br0">{</span>
  <span class="kw3">boolean</span> checkedOut = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="kw17">Book</span><span class="br0">(</span><span class="kw3">boolean</span> checkOut<span class="br0">)</span> <span class="br0">{</span>
    checkedOut = checkOut<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> checkIn<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    checkedOut = <span class="kw4">false</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">protected</span> <span class="kw3">void</span> finalize<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>checkedOut<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Error: checked out"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Обычно это делается так-:</span>
    <span class="co1">// super.finalize();  // Вызов версии базового класса</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TerminationCondition <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw17">Book</span> novel = <span class="kw2">new</span> <span class="kw17">Book</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Правильная очистка-:</span>
    novel.<span class="me1">checkIn</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Теряем ссылку, забыли про очистку:</span>
    <span class="kw2">new</span> <span class="kw17">Book</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// запрос JVM на сборку мусора и финализация&nbsp;:</span>
    <span class="kw21">System</span>.<span class="me1">gc</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Error: checked out
</pre>
<p>&lt;/spoiler&gt;
«Условие готовности» состоит в том, что все объекты <i><b>Book</b></i> должны быть «сняты с учета» перед предоставлением их в распоряжение сборщика мусора, но в методе <i><b>main()</b></i> программист ошибся и не отметил один из объектов <i><b>Book</b></i>. Если бы в методе <i><b>finalize()</b></i> не было проверки на условие «готовности», такую оплошность было бы очень сложно обнаружить.
</p><p>Заметьте, что для проведения принудительной финализации был использован метод <i><b>System.gc()</b></i>. Но даже если бы его не было, с высокой степенью вероятности можно сказать, что «утерянный» объект <i><b>Book</b></i>
 рано или поздно будет обнаружен в процессе исполнения программы (в этом
 случае предполагается, что программе будет выделено столько памяти, 
сколько нужно, чтобы сборщик мусора приступил к своим обязанностям).
</p><p>Обычно следует считать, что версия <i><b>finalize()</b></i> базового класса делает что-то важное, и вызывать ее в синтаксисе <i><b>super</b></i>, как показано в <i><b>Book.finalize()</b></i>. В данном примере вызов закомментирован, потому что он требует обработки исключений, а эта тема нами еще не рассматривалась.
</p>
<h3><span class="mw-headline" id=".D0.9A.D0.B0.D0.BA_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D0.B0.D0.B5.D1.82_.D1.81.D0.B1.D0.BE.D1.80.D1.89.D0.B8.D0.BA_.D0.BC.D1.83.D1.81.D0.BE.D1.80.D0.B0">Как работает сборщик мусора</span></h3>
<p>Если ранее вы работали на языке программирования, в котором выделение
 места для объектов в куче было связано с большими издержками, то вы 
можете предположить, что и в <i>Java</i> механизм выделения памяти из 
кучи для всех данных (за исключением примитивов) также обходится слишком
 дорого. Однако в действительности использование сборщика мусора дает 
немалый эффект по ускорению создания объектов. Сначала это может звучать
 немного странно — освобождение памяти сказывается на ее выделении — но 
именно так работают некоторые <i>JVM</i>, и это значит, что резервирование места для объектов в куче <i>Java</i> не уступает по скорости выделению пространства в стеке в других языках.
</p><p>Представтьте кучу языка <i>C++</i> в виде лужайки, где каждый 
объект «застолбил» свой собственный участок. Позднее площадка 
освобождается для повторного использования. В некоторых виртуальных 
машинах <i>Java</i> куча выглядит совсем иначе; она скорее похоже на 
ленту конвейера, которая передвигается вперед при создании нового 
объекта. А это значит, что скорость выделения хранилища для объекта 
оказывается весьма высокой. «Указатель кучи» просто передвигается вперед
 в «невозделанную» территорию, и по эффективности этот процесс близок к 
выделению памяти в стеке <i>C++</i>. (Конечно, учет выделенного 
пространства сопряжен с небольшими издержками, но их никоим образом 
нельзя сравнить с затратами, возникающими при поиске свободного блока в 
памяти.)
</p><p>Конечно, использование кучи в режиме «ленты конвейера» не может 
продолжаться бесконечно, и рано или поздно память станет сильно 
фрагментирована (что заметно снижает производительность), а затем и 
вовсе исчерпается. Как раз здесь в действие вступает сборщик мусора; во 
время своей работы он компактно размещает объекты кучи, как бы смещая 
«указатель кучи» ближе к началу «ленты», тем самым предотвращая 
фрагментацию памяти. Сборщик мусора реструктуризует внутреннее 
расположение объектов в памяти и позволит получить высокоскоростную 
модель кучи для резервирования памяти.
</p><p>Чтобы понять, как работает сборка мусора в <i>Java</i>, 
необходимо узнать, как устроены реализации сборщиков мусора (СМ) в 
других системах. Простой, но медленный механизм СМ называется подсчетом 
ссылок. С каждым объектом хранится счетчик ссылок на него, и всякий раз 
при присоединении новой ссылки к объекту этот счетчик увеличивается. 
Каждый раз при выходе ссылки из области действия или установке ее 
значения в null счетчик ссылок уменьшается. Таким образом, подсчет 
ссылок создает небольшие, но постоянные издержки во время работы вашей 
программы. Сборщик мусора перебирает объект за объектом списка; 
обнаружив объект с нулевым счетчиком, он освобождает ресурсы, занимаемые
 этим объектом. Но существует одна проблема — если объекты содержат 
циклические ссылки друг на друга, их счетчики ссылок не обнуляются, хотя
 на самом деле объекты уже являются «мусором». Обнаружение таких 
«циклических» групп является серьезной работой и отнимает у сборщика 
мусора достаточно времени. Подсчет ссылок часто используется для 
объяснения принципов процесса сборки мусора, но, судя по всему, он не 
используется ни в одной из виртуальных машин <i>Java</i>.
</p><p>В более быстрых схемах сборка мусора не зависит от подсчета 
ссылок. Вместо этого она опирается на идею, что любой существующий 
объект прослеживается до ссылки, находящейся в стеке или в статической 
памяти. Цепочка проверки проходит через несколько уровней объектов. 
Таким образом, если начать со стека и статического хранилища, мы 
обязательно доберемся до всех используемых объектов. Для каждой 
найденной ссылки надо взять объект, на который она указывает, и 
отследить все ссылки этого объекта; при этом выявляются другие объекты, 
на которые они указывают, и так далее, пока не будет проверена вся 
инфраструктура ссылок, берущая начало в стеке и статической памяти. 
Каждый объект, обнаруженный в ходе поиска, все еще используется в 
системе. Заметьте, что проблемы циклических ссылок не существует — такие
 ссылки просто не обнаруживаются, и поэтому становятся добычей сборщика 
мусора автоматически.
</p><p>В описанном здесь подходе работает адаптивный механизм сбора мусора, при котором <i>JVM</i>
 обращается с найденными используемыми объектами согласно определенному 
варианту действий. Один из таких вариантов называется ос- 
тановить-и-копировать. Смысл термина понятен: работа программы временно 
приостанавливается (эта схема не поддерживает сборку мусора в фоновом 
режиме). Затем все найденные «живые» (используемые) объекты копируются 
из одной кучи в другую, а «мусор» остается в первой. При копировании 
объектов в новую кучу они размещаются в виде компактной непрерывной 
цепочки, высвобождая пространство в куче {и позволяя удовлетворять заказ
 на новое хранилище простым перемещением указателя).
</p><p>Конечно, когда объект перемещается из одного места в другое, все 
ссылки, указывающие на него, должны быть изменены. Ссылки в стеке или в 
статическом хранилище переопределяются сразу, но могут быть и другие 
ссылки на этот объект, которые исправляются позже, во время очередного 
«прохода». Исправление происходит по мере нахождения ссылок.
</p><p>Существует два фактора, из-за которых «копирующие сборщики» 
обладают низкой эффективностью. Во-первых, в системе существует две 
кучи, и вы «перелопачиваете» память то туда, то сюда между двумя 
отдельными кучами, при этом половина памяти тратится впустую. Некоторые <i>JVM</i>
 пытаются решить эту проблему, выделяя память для кучи небольшими 
порциями по мере необходимости, а затем просто копируя одну порцию в 
другую.
</p><p><br>
Второй вопрос — копирование. Как только программа перейдет в фазу 
стабильной работы, она обычно либо становится «безотходной», либо 
производит совсем немного «мусора». Несмотря на это, копирующий сборщик 
все равно не перестанет копировать память из одного места в другое, что 
расточительно. Некоторые <i>JVM</i> определяют, что новых «отходов» не 
появляется, и переключаются на другую схему («адаптивная» часть). Эта 
схема называется пометить-и-убрать (удалить), и именно на ней работали 
ранние версии виртуальных машин фирмы <i>Sun</i>. Для повсеместного 
использования вариант «пометить-и-убрать» чересчур медлителен, но, когда
 известно, что нового «мусора» мало или вообще нет, он выполняется 
быстро.
</p><p>Схема «пометить-и-убрать» использует ту же логику — проверка 
начинается со стека и статического хранилища, после чего постепенно 
обнаруживаются все ссылки на «живые» объекты. Однако каждый раз при 
нахождении объект поме­чается флагом, но еще продолжает существование. 
«Уборка» происходит только после завершения процесса проверки и пометки.
 Все «мертвые» объекты при этом удаляются. Но копирования не происходит,
 и если сборщик решит «упаковать» фрагментированную кучу, то делается 
это перемещением объектов внутри нее.
</p><p>Идея «остановиться-и-копировать» несовместима с фоновым процессом
 сборки мусора; в начале уборки программа останавливается. В литературе 
фирмы <i>Sun</i> можно найти немало заявлений о том, что сборка мусора 
является фоновым процессом с низким приоритетом, но оказывается, что 
реализации в таком виде (по крайней мере в первых реализациях 
виртуальной машины <i>Sun</i>) в действительности не существует. Вместо этого сборщик мусора от <i>Sun</i> начинал выполнение только при нехватке памяти. Схема «пометить-и-убрать» также требует остановки программы.
</p><p>Как упоминалось ранее, в описываемой здесь виртуальной машине 
память выделяется большими блоками. При создании большого объекта ему 
выделяется собственный блок. Строгая реализация схемы 
«остановиться-и-копировать» требует, чтобы каждый используемый объект из
 исходной кучи копировался в новую кучу перед освобождением памяти 
старой кучи, что сопряжено с большими перемещениями памяти. При работе с
 блоками памяти СМ использует незанятые блоки для копирования по мере их
 накопления. У каждого блока имеется счетчик поколений, следящий за 
использованием блока. В обычной ситуации «упаковываются» только те 
блоки, которые были созданы после последней сборки мусора; для всех 
остальных блоков значение счетчика увеличивается при создании внешних 
ссылок. Такой подход годится для стандартной ситуации — создания 
множества временных объектов с коротким сроком жизни. Периодически 
производится полная очистка — большие блоки не копируются (только 
наращиваются их счетчики), но блоки с маленькими объектами копируются и 
«упаковываются». Виртуальная машина постоянно следит за эффективностью 
сборки мусора и, если она становится неэффективной, потому что в 
программе остались только долгоживущие объекты, переключается на схему 
«пометить-и-убрать». Аналогично <i>JVM</i> следит за успешностью схемы 
«пометить-и-убрать», и, когда куча становится излишне фрагментированной,
 СМ переключается обратно к схеме «остановиться-и-копировать». Это и 
есть адаптивный механизм.
</p><p>Существуют и другие способы ускорения работы в <i>JVM</i>. Наиболее важные — это действия загрузчика и то, что называется компиляцией «на лету» (<i>Just-In-Time, JIT</i>). Компилятор <i>JIT</i>
 частично или полностью конвертирует программу в «родной» машинный код, 
благодаря чему последний не нуждается в обработке виртуальной машиной и 
может выполняться гораздо быстрее. При загрузке класса (обычно это 
происходит при первом создании объекта этого класса) система находит 
файл .class, и байт-код из этого файла переносится в память. В этот 
момент можно просто провести компиляцию <i>JIT</i> для кода класса, но 
такой подход имеет два недостатка: во-первых, это займет чуть больше 
времени, что вместе с жизненным циклом программы может серьезно 
отразиться на производительности. Во-вторых, увеличивается размер 
исполняемого файла (байт-код занимает гораздо меньше места в сравнении с
 расширенным кодом <i>JIT</i>), что может привести к подкачке памяти, и 
это тоже замедлит программу. Альтернативная схема отложенного вычисления
 подразумевает, что код <i>JIT</i> компилируется только тогда, когда это станет необходимо. Иначе говоря, код, который никогда не исполняется, не компилируется <i>JIT</i>. Новая технология <i>Java HotSpot</i>, встроенная в последние версии <i>JDK</i>,
 делает это похожим образом с применением последовательной оптимизации 
кода при каждом его выполнении. Таким образом, чем чаще выполняется код,
 тем быстрее он работает.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.87.D0.BB.D0.B5.D0.BD.D0.BE.D0.B2_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0">Инициализация членов класса</span></h2>
<p><i>Java</i> иногда нарушает гарантии инициализации переменных перед 
их использованием. В случае с переменными, определенными локально, в 
методе, эта гарантия предоставляется в форме сообщения об ошибке. 
Скажем, при попытке ис­пользования фрагмента
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw3">int</span> і<span class="sy0">;</span>
    і ++, <span class="co1">// Ошибка - переменная і не инициализирована</span>
 <span class="br0">}</span></pre></div></div>
<p>вы получите сообщение об ошибке, указывающее на то, что переменная <i><b>і</b></i>
 не была инициализирована. Конечно, компилятор мог бы присваивать таким 
переменным значения по умолчанию, но данная ситуация больше похожа на 
ошибку программиста, и подобный подход лишь скрыл бы ее. Заставить 
программиста присвоить переменной значение по умолчанию — значит 
предотвратить ошибку в программе.
</p><p>Если примитивный тип является полем класса, то и способ обращения
 с ним несколько иной. Как было показано в главе 2, каждому примитивному
 полю класса гарантированно присваивается значение по умолчанию. 
Следующая программа подтверждает этот факт и выводит значения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/InitialValues.java</span>
<span class="co1">// Вывод начальных значений, присваиваемых по умолчанию.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> InitialValues <span class="br0">{</span>
  <span class="kw3">boolean</span> t<span class="sy0">;</span>
  <span class="kw3">char</span> c<span class="sy0">;</span>
  <span class="kw3">byte</span> b<span class="sy0">;</span>
  <span class="kw3">short</span> s<span class="sy0">;</span>
  <span class="kw3">int</span> i<span class="sy0">;</span>
  <span class="kw3">long</span> l<span class="sy0">;</span>
  <span class="kw3">float</span> f<span class="sy0">;</span>
  <span class="kw3">double</span> d<span class="sy0">;</span>
  InitialValues reference<span class="sy0">;</span>
  <span class="kw3">void</span> printInitialValues<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Data type      Initial value"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"boolean        "</span> + t<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"char           ["</span> + c + <span class="st0">"]"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"byte           "</span> + b<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"short          "</span> + s<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"int            "</span> + i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"long           "</span> + l<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"float          "</span> + f<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"double         "</span> + d<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"reference      "</span> + reference<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    InitialValues iv = <span class="kw2">new</span> InitialValues<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    iv.<span class="me1">printInitialValues</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="coMULTI">/* Тут возможен следующий вариант:
    new InitialValues().printInitialValues();
    */</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Data type      Initial value
boolean        false
char           [ ]
byte           0
</pre>
<p>&lt;/spoiler&gt;
Присмотритесь — даже если значения явно не указываются, они автоматически инициализируются. (Символьной переменной <i><b>char</b></i>
 присваивается значение ноль, которое отображается в виде пробела.) По 
крайней мере, нет опасности случайного использования 
неинициализированной переменной.
</p><p>Если ссылка на объект, определямая внутри класса, не связывается с
 новым объектом, то ей автоматически присваивается специальное значение <i><b>null</b></i> (ключевое слово <i>Java</i>).
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.AF.D0.B2.D0.BD.D0.B0.D1.8F_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F">Явная инициализация</span></h3>
<p>Что делать, если вам понадобится придать переменной начальное 
значение? Проще всего сделать это прямым присваиванием этой переменной 
значения в точке ее объявления в классе. (Заметьте, что в <i>C++</i> 
такое действие запрещено, хотя его постоянно пытаются выполнить 
новички.) В следующем примере полям уже знакомого класса InitialValues 
присвоены начальные значения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/InitialValues2.java</span>
<span class="co1">// Явное определение начальных значений переменных.</span>
<span class="kw2">public</span> <span class="kw2">class</span> InitialValues2 <span class="br0">{</span>
  <span class="kw3">boolean</span> bool = <span class="kw4">true</span><span class="sy0">;</span>
  <span class="kw3">char</span> ch = <span class="st0">'x'</span><span class="sy0">;</span>
  <span class="kw3">byte</span> b = <span class="nu0">47</span><span class="sy0">;</span>
  <span class="kw3">short</span> s = 0xff<span class="sy0">;</span>
  <span class="kw3">int</span> i = <span class="nu0">999</span><span class="sy0">;</span>
  <span class="kw3">long</span> lng = <span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw3">float</span> f = 3.14f<span class="sy0">;</span>
  <span class="kw3">double</span> d = <span class="nu0">3.14159</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Аналогичным образом можно инициализировать и не-примитивные типы. Если <i><b>Depth</b></i> является классом, вы можете добавить переменную и инициализировать ее следующим образом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Measurement.java</span>
<span class="kw2">class</span> Depth <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Measurement <span class="br0">{</span>
  Depth d = <span class="kw2">new</span> Depth<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// ...</span>
<span class="br0">}</span></pre></div></div>
<p>Если вы попытаетесь использовать ссылку <i><b>d</b></i>, которой не 
задано начальное значение, произойдет ошибка времени исполнения, 
называемая исключением (исключения подробно описываются в главе 10).
Начальное значение даже может задаваться вызовом метода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/MethodInit.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> MethodInit <span class="br0">{</span>
  <span class="kw3">int</span> i = f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw3">int</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="nu0">11</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Конечно, метод может получать аргументы, но в качестве последних не 
должны использоваться неинициализированные члены класса. Например, так 
правильно:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/MethodInit2.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> MethodInit2 <span class="br0">{</span>
  <span class="kw3">int</span> i = f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw3">int</span> j = g<span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
  <span class="kw3">int</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="nu0">11</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> g<span class="br0">(</span><span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> n <span class="sy0">*</span> <span class="nu0">10</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>a так нет:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/MethodInit3.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> MethodInit3 <span class="br0">{</span>
  <span class="co1">//! int j = g(i); // Illegal forward reference</span>
  <span class="kw3">int</span> i = f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw3">int</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="nu0">11</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> g<span class="br0">(</span><span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> n <span class="sy0">*</span> <span class="nu0">10</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Это одно из мест, где компилятор на полном основании выражает 
недовольство преждевременной ссылкой, поскольку ошибка связана с 
порядком инициализации, а не с компиляцией программы.
Описанный подход инициализации очень прост и прямолинеен. У него есть 
ограничение — все объекты типа <i><b>InitialValues</b></i> получат одни и те же начальные значения. Иногда вам нужно именно это, но в других ситуациях необходима большая гибкость.
</p>
<h3><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D0.BE.D0.BC">Инициализация конструктором</span></h3>
<p>Для проведения инициализации можно использовать конструктор. Это 
придает большую гибкость процессу программирования, так как появляется 
возможность вызова методов и выполнения действия по инициализации прямо 
во время работы программы. Впрочем, при этом необходимо учитывать еще 
одно обстоятельство: оно не исключает автоматической инициализации, 
происходящей перед выполнением конструктора. Например, в следующем 
фрагменте
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Counter.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Counter <span class="br0">{</span>
  <span class="kw3">int</span> i<span class="sy0">;</span>
  Counter<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> i = <span class="nu0">7</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// ...</span>
<span class="br0">}</span></pre></div></div>
<p>переменной <i><b>і</b></i> сначала будет присвоено значение <i>0</i>, а затем уже <i>7</i>.
 Это верно для всех примитивных типов и ссылок на объекты, включая те, 
которым задаются явные значения в точке определения. По этим причинам 
компилятор не пытается заставить вас инициализировать элементы в 
конструкторе, или в ином определенном месте, или перед их использованием
 — инициализация и так гарантирована.
</p>
<h3><span class="mw-headline" id=".D0.9F.D0.BE.D1.80.D1.8F.D0.B4.D0.BE.D0.BA_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8">Порядок инициализации</span></h3>
<p>Внутри класса очередность инициализации определяется порядком 
следования переменных, объявленных в этом классе. Определения переменных
 могут быть разбросаны по разным определениям методов, но в любом случае
 переменные инициализируются перед вызовом любого метода — даже 
конструктора. Например:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/OrderOfInitialization.java</span>
<span class="co1">// Демонстрирует порядок инициализации.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="co1">// При вызове конструктора для создания объекта </span>
<span class="co1">// Window выводится сообщение:</span>
<span class="kw2">class</span> <span class="kw6">Window</span> <span class="br0">{</span>
  <span class="kw6">Window</span><span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Window("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> House <span class="br0">{</span>
  <span class="kw6">Window</span> w1 = <span class="kw2">new</span> <span class="kw6">Window</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Перед конструктором</span>
  House<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Показывает, что выполняется конструктор:</span>
    print<span class="br0">(</span><span class="st0">"House()"</span><span class="br0">)</span><span class="sy0">;</span>
    w3 = <span class="kw2">new</span> <span class="kw6">Window</span><span class="br0">(</span><span class="nu0">33</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Повторная инициализация w3</span>
  <span class="br0">}</span>
  <span class="kw6">Window</span> w2 = <span class="kw2">new</span> <span class="kw6">Window</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// После конструктора</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"f()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw6">Window</span> w3 = <span class="kw2">new</span> <span class="kw6">Window</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// В конце</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> OrderOfInitialization <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    House h = <span class="kw2">new</span> House<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    h.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Показывает, что объект сконструирован</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Window(1)
Window(2)
Window(3)
House()
Window(33)
f()
</pre>
<p>&lt;/spoiler&gt;
В классе <i><b>House</b></i> определения объектов <i><b>Window</b></i> 
намеренно разбросаны, чтобы доказать, что все они инициализируются перед
 выполнением конструктора или каким-то другим действием. Вдобавок ссылка
 <i><b>w3</b></i> заново проходит инициализацию в конструкторе.
</p><p>Из результатов программы видно, что ссылка <i><b>w3</b></i> 
минует двойную инициализацию, перед вызовом конструктора и во время 
него. (Первый объект теряется, и со временем его уничтожит сборщик 
мусора.) Поначалу это может показаться неэффективным, но такой подход 
гарантирует верную инициализацию — что произошло бы, если бы в классе 
был определен перегруженный конструктор, который не инициализировал бы 
ссылку <i><b>w3</b></i>, а она при этом не получала бы значения по умолчанию?
</p>
<h3><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Инициализация статических данных</span></h3>
<p>Данные статических полей всегда существуют в единственном экземпляре,
 независимо от количества созданных объектов. Ключевое слово <i><b>static</b></i>
 не может применяться к локальным-переменным, только к полям. Если 
статическое поле относится к примитивному типу, при отсутствии явной 
инициализации ему присваивается значение по умолчанию. Если это ссылка 
на объект, то ей присваивается значение <i><b>null</b></i>.
Если вы хотите провести инициализацию в месте определения, она выглядит точно так же, как и у нестатических членов класса.
Следующий пример помогает понять, когда инициализируется статическая память:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/StaticInitialization.java</span>
<span class="co1">// Указание значений по умолчанию в определении класса.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Bowl <span class="br0">{</span>
  Bowl<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Bowl("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"f1("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Table <span class="br0">{</span>
  <span class="kw2">static</span> Bowl bowl1 = <span class="kw2">new</span> Bowl<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  Table<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Table()"</span><span class="br0">)</span><span class="sy0">;</span>
    bowl2.<span class="me1">f1</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"f2("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> Bowl bowl2 = <span class="kw2">new</span> Bowl<span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Cupboard <span class="br0">{</span>
  Bowl bowl3 = <span class="kw2">new</span> Bowl<span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> Bowl bowl4 = <span class="kw2">new</span> Bowl<span class="br0">(</span><span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
  Cupboard<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Cupboard()"</span><span class="br0">)</span><span class="sy0">;</span>
    bowl4.<span class="me1">f1</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> f3<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"f3("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> Bowl bowl5 = <span class="kw2">new</span> Bowl<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> StaticInitialization <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Creating new Cupboard() in main"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> Cupboard<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Creating new Cupboard() in main"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> Cupboard<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    table.<span class="me1">f2</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    cupboard.<span class="me1">f3</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> Table table = <span class="kw2">new</span> Table<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> Cupboard cupboard = <span class="kw2">new</span> Cupboard<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Bowl(1)
Bowl(2)
Table()
f1(1)
Bowl(4)
Bowl(5)
Bowl(3)
Cupboard()
f1(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f1(2)
Creating new Cupboard() in main
Bowl(3)
Cupboard()
f1(2)
f2(1)
f3(1)
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Bowl</b></i> позволяет проследить за процессом создания классов; классы <i><b>Table</b></i> и <i><b>Cupboard</b></i> содержат определения статических объектов <i><b>Bowl</b></i>. Заметьте, что в классе <i><b>Cupboard</b></i> создается нестатическая переменная <i><b>Bowl bowl3</b></i>, хотя все ос­тальные определения — статические.
</p><p>Из выходных данных программы видно, что статическая инициализация
 происходит только в случае необходимости. Если вы не создаете объектов <i><b>Table</b></i> и никогда не обращаетесь к <i><b>Table.bowl1</b></i> или <i><b>Table.bowl2</b></i>, то, соответственно, не будет и объектов <i><b>static Bowl bowl1</b></i> и <i><b>static Bowl bowl2</b></i>. Они инициализируются только при создании первого объекта <i><b>Table</b></i> (или при первом обращении к статическим данным). После этого статические объекты повторно не переопределяются.
</p><p>Сначала инициализируются <i><b>static</b></i>-члены, если они еще
 не были проинициализированы, и только затем нестатические объекты. 
Доказательство справедливости этого утверждения легко найти в результате
 работы программы. Для выполнения <i><b>main()</b></i> (а это статический метод!) загружается класс <i><b>Staticlnitialization</b></i>; затем инициализируются статические поля <i><b>table</b></i> и <i><b>cupboard</b></i>, вследствие чего загружаются эти классы. И так как все они содержат статические объекты <i><b>Bowl</b></i>, загружается класс <i><b>Bowl</b></i>. Таким образом, все классы программы загружаются до начала <i><b>main()</b></i>. Впрочем, эта ситуация нетипична, поскольку в рядовой программе не все поля объявляются как статические, как в данном примере.
</p><p>Неплохо теперь обобщить знания о процессе создания объекта. Для примера возьмем класс с именем <i><b>Dog</b></i>:
</p>
<hr>
<ul>
<li><span style="color:#800000">Хотя ключевое слово <i><b>static</b></i> и не используется явно, конструктор в действительности является статическим методом. При создании первого объекта типа <i><b>Dog</b></i> или при первом вызове статического метода-обращения к статическому полю класса <i><b>Dog</b></i>, интерпретатор <i>Java</i> должен найти класс <i><b>Dog.class</b></i>. Поиск осуществляется в стандартных каталогах, перечисленных в переменной окружения <i><b>СLASSPATH</b></i>.
</span></li>
</ul>
<p>
</p>
<ul>
<li><span style="color:#800000">После загрузки файла <i><b>Dog.class</b></i> (с созданием особого объекта <i><b>Class</b></i>,
 о котором мы узнаем позже) производится инициализация статических  
элементов. Таким образом, инициализация статических членов проводится 
только один раз, при первой загрузке объекта <i><b>Class</b></i>.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">При создании нового объекта конструкцией <i><b>new Dog()</b></i> для начала выделяется блок памяти, достаточный для хранения объекта <i><b>Dog</b></i> в куче.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Выделенная память заполняется нулями, при этом все примитивные поля объекта <i><b>Dog</b></i> автоматически инициализируются значениями по умолчанию (ноль для чисел, его эквиваленты для типов <i><b>boolean</b></i> и <i><b>char, null</b></i> для ссылок).</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Выполняются все действия по инициализации, происходящие в точке определения полей класса.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">Выполняются конструкторы. Как вы узнаете
 из главы 7, на этом этапе выполняется довольно большая часть работы, 
особенно при использовании наследования.</span>
</li>
</ul>
<hr>
<h3><span class="mw-headline" id=".D0.AF.D0.B2.D0.BD.D0.B0.D1.8F_.D0.B8.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D1.87.D0.BB.D0.B5.D0.BD.D0.BE.D0.B2">Явная инициализация статических членов</span></h3>
<p>Язык <i>Java</i> позволяет сгруппировать несколько действий по инициализации объектов <i><b>static</b></i> в специальной конструкции, называемой статическим блоком. Выглядит это примерно так:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Spoon.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Spoon <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">int</span> i<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="br0">{</span>
    i = <span class="nu0">47</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Похоже на определение метода, но на самом деле мы видим лишь ключевое слово <i><b>static</b></i> с последующим блоком кода. Этот код, как и остальная инициализация <i><b>static</b></i>,
 выполняется только один раз: при первом создании объекта этого класса 
или при первом обращении к статическим членам этого класса (даже если 
объект класса никогда не создается). Например:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/ExplicitStatic.java</span>
<span class="co1">//Явная инициализация с использованием конструкции "static"</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Cup <span class="br0">{</span>
  Cup<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Cup("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"f("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Cups <span class="br0">{</span>
  <span class="kw2">static</span> Cup cup1<span class="sy0">;</span>
  <span class="kw2">static</span> Cup cup2<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="br0">{</span>
    cup1 = <span class="kw2">new</span> Cup<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    cup2 = <span class="kw2">new</span> Cup<span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Cups<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Cups()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ExplicitStatic <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Inside main()"</span><span class="br0">)</span><span class="sy0">;</span>
    Cups.<span class="me1">cup1</span>.<span class="me1">f</span><span class="br0">(</span><span class="nu0">99</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// (1)</span>
  <span class="br0">}</span>
  <span class="co1">// static Cups cups1 = new Cups();  // (2)</span>
  <span class="co1">// static Cups cups2 = new Cups();  // (2)</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Inside main()
Cup(1)
Cup(2)
f(99)
</pre>
<p>&lt;/spoiler&gt;
Статический инициализатор класса <i><b>Cups</b></i> выполняется либо при обращении к статическому объекту <i><b>cup1</b></i>
 в строке с пометкой (1), либо если строка (1) закомментирована — в 
строках (2) после снятия комментариев. Если же и строка (1), и строки 
(2) закомментированы, <i><b>static</b></i>-инициализация класса Cups никогда не выполнится. Также неважно, будут ли исполнены одна или обе строки (2) программы — <i><b>static</b></i>-инициализация все равно выполняется только один раз.
</p>
<h3><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BD.D0.B5.D1.81.D1.82.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D1.85_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D1.8D.D0.BA.D0.B7.D0.B5.D0.BC.D0.BF.D0.BB.D1.8F.D1.80.D0.B0">Инициализация нестатических данных экземпляра</span></h3>
<p>В <i>Java</i> имеется сходный синтаксис для инициализации нестатических переменных для каждого объекта. Вот пример: .
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/Mugs.java</span>
<span class="co1">// "Инициализация экземпляра"</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Mug <span class="br0">{</span>
  Mug<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Mug("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="kw3">int</span> marker<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"f("</span> + marker + <span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Mugs <span class="br0">{</span>
  Mug mug1<span class="sy0">;</span>
  Mug mug2<span class="sy0">;</span>
  <span class="br0">{</span>
    mug1 = <span class="kw2">new</span> Mug<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    mug2 = <span class="kw2">new</span> Mug<span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"mug1 &amp; mug2 initialized"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Mugs<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Mugs()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  Mugs<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Mugs(int)"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Inside main()"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> Mugs<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"new Mugs() completed"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> Mugs<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"new Mugs(1) completed"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Inside main()
Mug(1)
Mug(2)
mug1 &amp; mug2 initialized
Mugs()
new Mugs() completed
Mug(1)
Mug(2)
mug1 &amp; mug2 initialized
Mugs(int)
new Mugs(1) completed
</pre>
<p>&lt;/spoiler&gt;
выглядит в точности так же, как и конструкция <i><b>static</b></i>-инициализации, разве что ключевое слово <i><b>static</b></i>
 отсутствует. Такой синтаксис необходим для поддержки инициализации 
анонимных внутренних классов (см. главу 9), но он также гарантирует, что
 некоторые операции будут выполнены независимо от того, какой именно 
конструктор был вызван в программе. Из результатов видно, что секция 
инициализации экземпляра выполняется раньше любых конструкторов.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BC.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D0.BE.D0.B2">Инициализация массивов</span></h2>
<p>Массив представляет собой последовательность объектов или примитивов,
 относящихся к одному типу, обозначаемую одним идентификатором. Массивы 
определяются и используются с помощью оператора индексирования <i><b>[ ]</b></i>. Чтобы объявить массив, вы просто. указываете вслед за типом пустые квадратные скобки:
</p>
<pre>int[] al;
</pre>
<p>Квадратные скобки также могут размещаться после идентификатора, эффект будет точно таким же:
</p>
<pre>int al[];
</pre>
<p>Это соответствует ожиданиям программистов на <i>C</i> и <i>C++</i>, 
привыкших к такому синтаксису. Впрочем, первый стиль, пожалуй, выглядит 
более логично — он сразу дает понять, что имеется в виду «массив 
значений типа <i><b>int</b></i>». Он и будет использоваться в книге.
</p><p>Компилятор не позволяет указать точный размер массива. Вспомните,
 что говорилось ранее о ссылках. Все, что у вас сейчас есть, — это 
ссылка на массив, для которого еще не было выделено памяти. Чтобы 
резервировать память для массива, необходимо записать некоторое 
выражение инициализации. Для массивов такое выражение может находиться в
 любом месте программы, но существует и особая разновидность выражений 
инициализации, используемая только в точке объявления массива. Эта 
специальная инициализация выглядит как набор значений в фигурных 
скобках. Выделение памяти (эквивалентное действию оператора <i><b>new</b></i>) в этом случае проводится компилятором. Например:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> al = <span class="br0">{</span> <span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span> <span class="br0">}</span><span class="sy0">;</span></pre></div></div>
<p>Но зачем тогда вообще нужно определять ссылку на массив без самого массива?
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> а<span class="nu0">2</span><span class="sy0">;</span></pre></div></div>
<p>Во-первых, в <i>Java</i> можно присвоить один массив другому, записав следующее:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> а<span class="nu0">2</span> = al<span class="sy0">;</span></pre></div></div>
<p>В данном случае вы на самом деле копируете ссылку, как показано в примере:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/ArraysOfPrimitives.java</span>
<span class="co1">// Массивы простейших типов.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArraysOfPrimitives <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> a1 = <span class="br0">{</span> <span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span> <span class="br0">}</span><span class="sy0">;</span>
    <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> a2<span class="sy0">;</span>
    a2 = a1<span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a2.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span>
      a2<span class="br0">[</span>i<span class="br0">]</span> = a2<span class="br0">[</span>i<span class="br0">]</span> + <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a1.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span>
      print<span class="br0">(</span><span class="st0">"a1["</span> + i + <span class="st0">"] = "</span> + a1<span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>a1[0] = 2
a1[1] = 3
a1[2] = 4
a1[3] = 5
a1[4] = 6
</pre>
<p>&lt;/spoiler&gt;
Массив <i><b>a1</b></i> инициализируется набором значений, в то время как массив <i><b>а2</b></i> — нет; присваивание по ссылке <i><b>а2</b></i> присваивается позже — в данном случае присваивается другой массив.
</p><p>Все массивы (как массивы примитивов, так и массивы объектов) 
содержат поле&gt; которое можно прочитать (но не изменить!) для 
получения количества элементов в массиве. Это поле называется <i><b>length</b></i>. Так как в массивах <i>Java</i>, <i>C</i> и <i>C++</i> . Нумерация элементов начинается с нуля, последнему элементу массива соответствует индекс <i><b>length—1</b></i>. При выходе за границы массива <i>C</i> и <i>C++</i> не препятствуют «прогулкам в памяти» программы, что часто приводит к печальным последствиям. Но <i>Java</i> защищает вас от таких проблем — при выходе за рамки массива происходит ошибка времени исполнения (исключение, тема главы 10).
</p><p>А если во время написания программы вы не знаете, сколько элементов вам понадобится в новом массиве? Тогда просто используйте <i><b>new</b></i> для создания его элементов. В следующем примере <i><b>new</b></i> работает, хотя в программе создается массив примитивных типов (оператор <i><b>new</b></i> неприменим для создания примитивов вне массива):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/ArrayNew.java</span>
<span class="co1">// Создание массивов оператором new.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArrayNew <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> a<span class="sy0">;</span>
    <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    a = <span class="kw2">new</span> <span class="kw3">int</span><span class="br0">[</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="br0">]</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"length of a = "</span> + a.<span class="me1">length</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>a<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>length of a = 18
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre>
<p>&lt;/spoiler&gt;
Размер массива выбирается случайным образом, с использованием метода <i><b>Random.nextInt()</b></i>,
 генерирующего число от нуля до переданного в качестве аргумента 
значения. Так как размер массива случаен, очевидно, что создание массива
 происходит во время исполнения программы. Вдобавок, результат работы 
программы позволяет убедиться в том, что элементы массивов простейших 
типов автоматически инициализируются «пустыми» значениями. (Для чисел и 
символов это ноль, а для логического типа <i><b>boolean — false</b></i>.)
</p><p>Метод <i><b>Arrays.toString()</b></i>, входящий в стандартную библиотеку <i><b>java.util</b></i>, выдает печатную версию одномерного массива.
</p><p>Конечно, в данном примере массив можно определить и инициализировать в одной строке:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> а = <span class="kw2">new</span> <span class="kw3">int</span><span class="br0">[</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="br0">]</span><span class="sy0">;</span></pre></div></div>
<p>Если возможно, рекомендуется использовать именно такую форму записи. 
При создании массива непримитивных объектов вы фактически создаете 
массив ссылок. Для примера возьмем класс-обертку <i><b>Integer</b></i>, который является именно классом, а не примитивом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/ArrayClassObj.java</span>
<span class="co1">// Создание массива непримитивных объектов.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArrayClassObj <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> a = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">[</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="br0">]</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"length of a = "</span> + a.<span class="me1">length</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> a.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span>
      a<span class="br0">[</span>i<span class="br0">]</span> = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Автоматическая упаковка</span>
    print<span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>a<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>length of a = 18
[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]
</pre>
<p>&lt;/spoiler&gt;
Здесь даже после вызова new для создания массива
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> а = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">[</span>rand nextlnt<span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="br0">]</span><span class="sy0">;</span></pre></div></div>
<p>мы имеем лишь массив из ссылок — до тех пор, пока каждая ссылка не будет инициализирована новым объектом <i><b>Integer</b></i> (в данном случае это делается посредством автоупаковки):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> a<span class="br0">[</span>i<span class="br0">]</span> = rand.<span class="me1">nextlnt</span><span class="br0">(</span><span class="nu0">500</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>Если вы забудете создать объект, то получите исключение во время 
выполнения программы, при попытке чтения несуществующего элемента 
массива.
Массивы объектов также можно инициализировать списком в фигурных 
скобках. Существует две формы синтаксиса:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/ArrayInit.java</span>
 <span class="co1">// Инициализация массивов</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArrayInit <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> a = <span class="br0">{</span>
      <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span>,
      <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span>,
      <span class="nu0">3</span>, <span class="co1">// Autoboxing</span>
    <span class="br0">}</span><span class="sy0">;</span>
    <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> b = <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span>
      <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span>,
      <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span>,
      <span class="nu0">3</span>, <span class="co1">// Автоматическая упаковка</span>
    <span class="br0">}</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>a<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>b<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[1, 2, 3]
[1, 2, 3]
</pre>
<p>&lt;/spoiler&gt;
В обоих случаях завершающая запятая в списке инициализаторов не 
обязательна (она всего лишь упрощает ведение длинных списков).
Первая форма полезна, но она более ограничена, поскольку может 
использоваться только в точке определения массива. Вторая форма может 
использоваться везде, даже внутри вызова метода.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.BE.D0.B2_.D0.BF.D0.B5.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D0.BE.D0.B9_.D0.B4.D0.BB.D0.B8.D0.BD.D1.8B">Списки аргументов переменной длины</span></h2>
<p>Синтаксис второй формы предоставляет удобный синтаксис создания и 
вызова методов с эффектом, напоминающим списки аргументов переменной 
длины языка <i>C</i>.
Такой список способен содержать неизвестное заранее количество 
аргументов неизвестного типа. Так как абсолютно все классы унаследованы 
от общего корневого класса <i><b>Object</b></i>, можно создать метод, принимающий в качестве аргумента массив <i><b>Object</b></i>, и вызывать его следующим образом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/VarArgs.java</span>
<span class="co1">// Использование синтаксиса массивов</span>
<span class="co1">// для получения переменного списка параметров.</span>
<span class="kw2">class</span> A <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> VarArgs <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span> printArray<span class="br0">(</span><span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw166">Object</span> obj&nbsp;: args<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>obj + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    printArray<span class="br0">(</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span>
      <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span>, <span class="kw2">new</span> <span class="kw21">Float</span><span class="br0">(</span><span class="nu0">3.14</span><span class="br0">)</span>, <span class="kw2">new</span> <span class="kw21">Double</span><span class="br0">(</span><span class="nu0">11.11</span><span class="br0">)</span>
    <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span><span class="st0">"one"</span>, <span class="st0">"two"</span>, <span class="st0">"three"</span> <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span><span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span><span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>47 3.14 11.11
one two three
A@1a46e30 A@3e25a5 A@19821f
</pre>
<p>&lt;/spoiler&gt;
Видно, что метод<i><b> print()</b></i> принимает массив объектов типа <i><b>Object</b></i>, перебирает его элементы и выводит их. Классы из стандартной библиотеки <i>Java</i> при печати выводят осмысленную информацию, однако объекты классов в данном примере выводят имя класса, затем символ <i><b>@</b></i>
 и несколько шестнадцатеричных цифр. Таким образом, по умолчанию класс 
выводит имя и адрес объекта (если только вы не переопределите в классе 
метод <i><b>toString()</b></i> — см. далее).
</p><p>До выхода <i>Java</i> <i>SE5</i> переменные списки аргументов реализовывались именно так. В <i>Java</i> <i>SE5</i>
 эта долгожданная возможность наконец-то была добавлена в язык — теперь 
для определения переменного списка аргументов может ис­пользоваться 
многоточие, как видно в определении метода <i><b>printArray</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: initialization/NewVarArgs.java</span>
/ Создание списков аргументов переменной длины 
<span class="co1">// с использованием синтаксиса массивов.</span>
<span class="kw2">public</span> <span class="kw2">class</span> NewVarArgs <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span> printArray<span class="br0">(</span><span class="kw166">Object</span>... <span class="me1">args</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw166">Object</span> obj&nbsp;: args<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>obj + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Можно передать отдельные элементы:</span>
    printArray<span class="br0">(</span><span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span>, <span class="kw2">new</span> <span class="kw21">Float</span><span class="br0">(</span><span class="nu0">3.14</span><span class="br0">)</span>,
      <span class="kw2">new</span> <span class="kw21">Double</span><span class="br0">(</span><span class="nu0">11.11</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="nu0">47</span>, 3.14F, <span class="nu0">11.11</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="st0">"one"</span>, <span class="st0">"two"</span>, <span class="st0">"three"</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> A<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Или массив:</span>
    printArray<span class="br0">(</span><span class="br0">(</span><span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span> <span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span> <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    printArray<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Пустой список тоже возможен</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (75% match)
</p>
<pre>47 3.14 11.11
47 3.14 11.11
one two three
A@1bab50a A@c3c749 A@150bd4d
1 2 3 4
</pre>
<p>&lt;/spoiler&gt;
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5">Резюме</span></h2>
<p>Такой сложный механизм инициализации, как конструктор, показывает, 
насколько важное внимание в языке уделяется инициализации. Когда Бьерн 
Страуструп разрабатывал <i>C++</i>, в первую очередь он обратил внимание на то, что низкая продуктивность <i>C</i>
 связана с плохо продуманной инициализацией, которой была обусловлена 
значительная доля ошибок. Аналогичные проблемы возникают и при 
некорректной финализации. Так как конструкторы позволяют гарантировать 
соответствующие инициализацию и завершающие действия по очистке 
(компилятор не позволит создать объект без вызова конструктора), тем 
самым обеспечивается полная управляемость и защищенность программы.
</p><p>В языке <i>C++</i> уничтожение объектов играет очень важную роль,
 потому что объекты, созданные оператором new, должны быть 
соответствующим образом разрушены. В <i>Java</i> память автоматически освобождается сборщиком мусора, и аналоги деструкторов обычно не нужны. В таких случаях сборщик мусора <i>Java</i>
 значительно упрощает процесс программирования и к тому же добавляет так
 необходимую безопасность при освобождении ресурсов. Некоторые сборщики 
мусора могут проводить завершающие действия даже с такими ресурсами, как
 графические и файловые дескрипторы. Однако сборщики мусора добавляют 
издержки во время выполнения программы, которые пока трудно реально 
оценить из-за сложившейся исторически медлительности интерпретаторов <i>Java</i>. И хотя в последнее время язык <i>Java</i>
 намного улучшил свою производительность, проблема его «задумчивости» 
все-таки наложила свой отпечаток на возможность решения языком 
некоторого класса задач.
</p><p>Так как для всех объектов гарантированно используются 
конструкторы, на последние возлагаются дополнительные обязанности, не 
описанные в этой главе. В частности, гарантия конструирования действует и
 при создании новых классов с использованием композиции или 
наследования, и для их поддержки требуются некоторые дополнения к 
синтаксису языка. Композиция и наследование, а также их влияние на 
конструкторы, рассматриваются в следующих главах.


</p>
                <p><br>
                </p>
                <hr>
                <p><a href="http://wikijava.it-cache.net/index.php" title="Thinking in Java 4th edition">назад в Оглавление</a>
                </p><p><br>
                </p>
<!-- 
NewPP limit report
CPU time usage: 3.913 seconds
Real time usage: 3.920 seconds
Preprocessor visited node count: 521/1000000
Preprocessor generated node count: 1088/1000000
Post‐expand include size: 242/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wjava2-wj_:pcache:idhash:19-0!*!*!!ru!*!* and timestamp 20140812121115
 -->
</div>								<div class="printfooter">
				Источник — «<a href="http://wikijava.org.ua/index.php?title=Glava_5_Thinking_in_Java_4th_edition&amp;oldid=29">http://wikijava.org.ua/index.php?title=Глава_5_Thinking_in_Java_4th_edition&amp;oldid=29</a>»				</div>
                                <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8" title="Категория:Книги">Книги</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:Java" title="Категория:Java">Java</a></li></ul></div></div>												<div class="visualClear"></div>
            </div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Персональные инструменты</h3>
	<ul>
<li id="pt-login"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0+5+Thinking+in+Java+4th+edition" title="Здесь можно зарегистрироваться в системе, но это необязательно. [o]" accesskey="o">Представиться системе</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Пространства имён</h3>
	<ul>
					<!--<li  id="ca-nstab-main" class="selected"><span><a href="index.php@title=Glava_5_Thinking_in_Java_4th_edition.html"  title="Просмотр основной страницы [c]" accesskey="c">Статья</a></span></li>-->
					<!--<li  id="ca-talk" class="new"><span><a href="http://wikijava.org.ua/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;action=edit&amp;redlink=1"  title="Обсуждение основной страницы [t]" accesskey="t">Обсуждение</a></span></li>-->
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Варианты</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Просмотры</h3>
	<ul>
					<!--<li id="ca-view" class="selected"><span><a href="index.php@title=Glava_5_Thinking_in_Java_4th_edition.html" >Читать</a></span></li>-->
					<!--<li id="ca-viewsource"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;action=edit"  title="Эта страница защищена от изменений, но вы можете посмотреть и скопировать её исходный текст [e]" accesskey="e">Просмотр</a></span></li>-->
					<!--<li id="ca-history" class="collapsible"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;action=history"  title="Журнал изменений страницы [h]" accesskey="h">История</a></span></li>-->
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Действия</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_5_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Поиск</label></h3>
	<form action="http://wikijava.org.ua/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Поиск" title="Искать в WikiJava: Wiki of Java: викифицированные книги и статьи по Java [f]" accesskey="f" id="searchInput">						<button type="submit" name="button" title="Найти страницы, содержащие указанный текст" id="searchButton"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/search-ltr.asc" alt="Найти" height="13" width="12"></button>								<input name="title" value="Служебная:Поиск" type="hidden">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<!--<div id="p-logo" role="banner"><a style="background-image: url(/skins/common/images/wikijava.png);" href="index.php@title=Заглавная_страница.html"  title="Перейти на заглавную страницу"></a></div>-->
				<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
	<h3 id="p-navigation-label">Навигация</h3>
	<div class="body">
        <ul>
            <li id="n-mainpage-description"><a href="http://wikijava.org.ua/index.php?title=%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [z]" accesskey="z">Заглавная страница</a></li>
            <li id="n-recentchanges"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [r]" accesskey="r">Свежие правки</a></li>
            <li id="n-.D0.9A.D0.BD.D0.B8.D0.B3.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8_Java">Книги Java</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D1.8C.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D0%B8_Java">Статьи Java</a></li>
            <li id="n-Java-.D0.BF.D0.BE.D1.80.D1.82.D0.B0.D0.BB"><a href="http://wikijava.org.ua/index.php?title=Java-portal">Java портал</a></li>
            <li id="n-help"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Место, где можно получить справку">Справка</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.81.D1.82.D0.B8.D0.BA.D0.B0"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0">Статистика</a></li>
        </ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label">Инструменты</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition" title="Список всех страниц, ссылающихся на данную [j]" accesskey="j">Ссылки сюда</a></li>
			<li id="t-recentchangeslinked"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition" title="Последние изменения в страницах, на которые ссылается эта страница [k]" accesskey="k">Связанные правки</a></li>
			<li id="t-specialpages"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [q]" accesskey="q">Спецстраницы</a></li>
			<li id="t-print"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [p]" accesskey="p">Версия для печати</a></li>
			<li id="t-permalink"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;oldid=29" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
			<li id="t-info"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_5_Thinking_in_Java_4th_edition&amp;action=info">Сведения о странице</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B" aria-labelledby="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">
	<h3 id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">Другие проекты</h3>
	<div class="body">
		<ul>
			<li id="n-rastafara.com.ua"><a href="http://rastafara.com.ua/" rel="nofollow">rastafara.com.ua</a></li>
			<li id="n-rastafara-blog"><a href="http://sergey-rastafara.blogspot.com/" rel="nofollow">rastafara blog</a></li>
			<li id="n-rastaban"><a href="http://rastaban.com.ua/" rel="nofollow">rastaban</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 21:25, 16 февраля 2014.</li>
											<li id="footer-info-viewcount">К этой странице обращались 3696 раза.</li>
											<li id="footer-info-copyright">Содержимое доступно по лицензии <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 или более поздняя</a> (если не указано иное).</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Описание">Описание WikiJava: Wiki of Java: викифицированные книги и статьи по Java</a></li>
											<li id="footer-places-disclaimer"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Отказ от ответственности">Отказ от ответственности</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/copyleft/fdl.html"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/gnu-fdl.png" alt="GNU Free Documentation License 1.3 или более поздняя" height="31" width="88"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%205_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","ext.vector.simpleSearch","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.225 secs. -->
	

</body></html>