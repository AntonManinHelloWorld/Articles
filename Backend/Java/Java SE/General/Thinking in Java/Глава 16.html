<!DOCTYPE html>
<html dir="ltr" class="client-nojs" lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>Глава 16 Thinking in Java 4th edition — WikiJava: Wiki of Java: викифицированные книги и статьи по Java</title>
<meta name="generator" content="MediaWiki 1.22.2">
<link rel="shortcut icon" href="http://wikijava.it-cache.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wikijava.it-cache.net/opensearch_desc.php" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://wikijava.it-cache.net/api.php@action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java&nbsp;— Atom-лента" href="http://wikijava.it-cache.net/index.php@title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F%253A%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="stylesheet" href="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/style3.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wjava2-wj_:resourceloader:filter:minify-css:7:32e7e505403c81fe0a24e297ef166436 */</style>

<script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/style1.css"></script><script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/load.html"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Глава_16_Thinking_in_Java_4th_edition","wgTitle":"Глава 16 Thinking in Java 4th edition","wgCurRevisionId":40,"wgRevisionId":40,"wgArticleId":30,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Книги","Java"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Глава_16_Thinking_in_Java_4th_edition","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"simplesearch":true,"experiments":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"ru","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"ru"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wjava2-wj_:resourceloader:filter:minify-js:7:07bb1f4d2452379e70abca47c4cde6d9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java5.source-java5 .de1, .java5.source-java5 .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java5.source-java5  {font-family:monospace;}
.java5.source-java5 .imp {font-weight: bold; color: red;}
.java5.source-java5 li, .java5.source-java5 .li1 {font-weight: normal; vertical-align:top;}
.java5.source-java5 .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java5.source-java5 .li2 {font-weight: bold; vertical-align:top;}
.java5.source-java5 .kw1 {color: #000000;  font-weight: bold;}
.java5.source-java5 .kw2 {color: #000000; font-weight: bold;}
.java5.source-java5 .kw3 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw4 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw5 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw6 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw7 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw8 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw9 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw10 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw11 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw12 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw13 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw14 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw15 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw16 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw17 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw18 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw19 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw20 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw21 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw22 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw23 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw24 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw25 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw26 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw27 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw28 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw29 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw30 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw31 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw32 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw33 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw34 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw35 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw36 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw37 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw38 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw39 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw40 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw41 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw42 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw43 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw44 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw45 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw46 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw47 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw48 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw49 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw50 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw51 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw52 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw53 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw54 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw55 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw56 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw57 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw58 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw59 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw60 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw61 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw62 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw63 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw64 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw65 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw66 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw67 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw68 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw69 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw70 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw71 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw72 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw73 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw74 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw75 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw76 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw77 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw78 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw79 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw80 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw81 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw82 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw83 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw84 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw85 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw86 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw87 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw88 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw89 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw90 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw91 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw92 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw93 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw94 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw95 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw96 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw97 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw98 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw99 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw100 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw101 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw102 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw103 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw104 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw105 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw106 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw107 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw108 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw109 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw110 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw111 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw112 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw113 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw114 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw115 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw116 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw117 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw118 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw119 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw120 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw121 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw122 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw123 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw124 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw125 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw126 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw127 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw128 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw129 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw130 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw131 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw132 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw133 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw134 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw135 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw136 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw137 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw138 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw139 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw140 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw141 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw142 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw143 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw144 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw145 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw146 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw147 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw148 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw149 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw150 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw151 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw152 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw153 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw154 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw155 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw156 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw157 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw158 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw159 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw160 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw161 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw162 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw163 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw164 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw165 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw166 {color: #003399; font-weight: bold;}
.java5.source-java5 .co1 {color: #666666; font-style: italic;}
.java5.source-java5 .co2 {color: #006699;}
.java5.source-java5 .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java5.source-java5 .coMULTI {color: #666666; font-style: italic;}
.java5.source-java5 .es0 {color: #000099; font-weight: bold;}
.java5.source-java5 .br0 {color: #009900;}
.java5.source-java5 .sy0 {color: #339933;}
.java5.source-java5 .st0 {color: #0000ff;}
.java5.source-java5 .nu0 {color: #cc66cc;}
.java5.source-java5 .me1 {color: #006633;}
.java5.source-java5 .me2 {color: #006633;}
.java5.source-java5 .ln-xtra, .java5.source-java5 li.ln-xtra, .java5.source-java5 div.ln-xtra {background-color: #ffc;}
.java5.source-java5 span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Глава_16_Thinking_in_Java_4th_edition skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="ru"><span dir="auto">Глава 16 Thinking in Java 4th edition</span></h1>
			<div id="bodyContent">
								<div id="siteSub">Материал из WikiJava: Wiki of Java: викифицированные книги и статьи по Java</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#mw-navigation">навигация</a>, 					<a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#p-search">поиск</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="ru"><table style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;" cellpadding="0" cellspacing="0">
<tbody><tr>
<td> <div id="toc" class="toc"><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.98.D0.A1.D0.A2.D0.95.D0.9C.D0.90_.D0.92.D0.92.D0.9E.D0.94.D0.90.2F.D0.92.D0.AB.D0.92.D0.9E.D0.94.D0.90_JAVA"><span class="tocnumber">1</span> <span class="toctext"><b>СИСТЕМА ВВОДА/ВЫВОДА JAVA</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D0.B0.D1.81.D1.81_File"><span class="tocnumber">1.1</span> <span class="toctext">Класс File</span></a>
<ul>
<li class="toclevel-3 tocsection-3"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D0.BA.D0.B0.D1.82.D0.B0.D0.BB.D0.BE.D0.B3.D0.BE.D0.B2"><span class="tocnumber">1.1.1</span> <span class="toctext">Список каталогов</span></a></li>
<li class="toclevel-3 tocsection-4"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.91.D0.B5.D0.B7.D1.8B.D0.BC.D1.8F.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B"><span class="tocnumber">1.1.2</span> <span class="toctext">Безымянные внутренние классы</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D0.B2.D0.B5.D1.80.D0.BA.D0.B0_.D1.81.D1.83.D1.89.D0.B5.D1.81.D1.82.D0.B2.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D0.B8_.D1.81.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.B0.D1.82.D0.B0.D0.BB.D0.BE.D0.B3.D0.BE.D0.B2"><span class="tocnumber">1.1.3</span> <span class="toctext">Проверка существования и создание каталогов</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-6"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.92.D0.B2.D0.BE.D0.B4_.D0.B8_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4"><span class="tocnumber">1.2</span> <span class="toctext">Ввод и вывод</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A2.D0.B8.D0.BF.D1.8B_InputStream"><span class="tocnumber">1.2.1</span> <span class="toctext">Типы InputStream</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A2.D0.B8.D0.BF.D1.8B_OutputStream"><span class="tocnumber">1.2.2</span> <span class="toctext">Типы OutputStream</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.94.D0.BE.D0.B1.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B0.D1.82.D1.80.D0.B8.D0.B1.D1.83.D1.82.D0.BE.D0.B2_.D0.B8_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.BE.D0.B2"><span class="tocnumber">1.3</span> <span class="toctext">Добавление атрибутов и интерфейсов</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_InputStream_.D1.81_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC_FilterInputStream"><span class="tocnumber">1.4</span> <span class="toctext">Чтение из InputStream с использованием FilterInputStream</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.97.D0.B0.D0.BF.D0.B8.D1.81.D1.8C_.D0.B2_OutputStream_.D1.81_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D1.8C.D1.8E_FilterOutputStream"><span class="tocnumber">1.5</span> <span class="toctext">Запись в OutputStream с помощью FilterOutputStream</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D0.B0.D1.81.D1.81.D1.8B_Reader_.D0.B8_Writer"><span class="tocnumber">1.6</span> <span class="toctext">Классы Reader и Writer</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.98.D1.81.D1.82.D0.BE.D1.87.D0.BD.D0.B8.D0.BA.D0.B8_.D0.B8_.D0.BF.D1.80.D0.B8.D0.B5.D0.BC.D0.BD.D0.B8.D0.BA.D0.B8_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.7</span> <span class="toctext">Источники и приемники данных</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.98.D0.B7.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0"><span class="tocnumber">1.8</span> <span class="toctext">Изменение поведения потока</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D0.B0.D1.81.D1.81.D1.8B.2C_.D0.BE.D1.81.D1.82.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B1.D0.B5.D0.B7_.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B9"><span class="tocnumber">1.9</span> <span class="toctext">Классы, оставленные без изменений</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#RandomAccessFile:_.D1.81.D0.B0.D0.BC_.D0.BF.D0.BE_.D1.81.D0.B5.D0.B1.D0.B5"><span class="tocnumber">1.10</span> <span class="toctext">RandomAccessFile: сам по себе</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A2.D0.B8.D0.BF.D0.B8.D1.87.D0.BD.D0.BE.D0.B5_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.B2_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0"><span class="tocnumber">1.11</span> <span class="toctext">Типичное использование потоков ввода/вывода</span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.91.D1.83.D1.84.D0.B5.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B5_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0"><span class="tocnumber">1.11.1</span> <span class="toctext">Буферизованное чтение из файла</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D0.B8"><span class="tocnumber">1.11.2</span> <span class="toctext">Чтение из памяти</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A4.D0.BE.D1.80.D0.BC.D0.B0.D1.82.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B5_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D0.B8"><span class="tocnumber">1.11.3</span> <span class="toctext">Форматированное чтение из памяти</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.92.D1.8B.D0.B2.D0.BE.D0.B4_.D0.B2_.D1.84.D0.B0.D0.B9.D0.BB"><span class="tocnumber">1.11.4</span> <span class="toctext">Вывод в файл</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D0.BA.D1.80.D0.B0.D1.89.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.D1.84.D0.BE.D1.80.D0.BC.D0.B0_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0"><span class="tocnumber">1.11.5</span> <span class="toctext">Сокращенная форма вывода текстового файла</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D1.85.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8_.D0.B2.D0.BE.D1.81.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.11.6</span> <span class="toctext">Сохранение и восстановление данных</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5.2F.D0.B7.D0.B0.D0.BF.D0.B8.D1.81.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2_.D1.81_.D0.BF.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.BB.D1.8C.D0.BD.D1.8B.D0.BC_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.BE.D0.BC"><span class="tocnumber">1.11.7</span> <span class="toctext">Чтение/запись файлов с произвольным доступом</span></a></li>
<li class="toclevel-3 tocsection-25"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9A.D0.B0.D0.BD.D0.B0.D0.BB.D1.8B"><span class="tocnumber">1.11.8</span> <span class="toctext">Каналы</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-26"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B0_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B8_.D0.B7.D0.B0.D0.BF.D0.B8.D1.81.D0.B8_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2"><span class="tocnumber">1.12</span> <span class="toctext">Средства чтения и записи файлов</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.D0.B2.D0.B2.D0.BE.D0.B4.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4"><span class="tocnumber">1.13</span> <span class="toctext">Стандартный ввод/вывод</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D1.81.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0"><span class="tocnumber">1.13.1</span> <span class="toctext">Чтение из стандартного потока ввода</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.97.D0.B0.D0.BC.D0.B5.D0.BD.D0.B0_System.out_.D0.BD.D0.B0_PrintWriter"><span class="tocnumber">1.13.2</span> <span class="toctext">Замена System.out на PrintWriter</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.BD.D0.B0.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0"><span class="tocnumber">1.13.3</span> <span class="toctext">Перенаправление стандартного ввода/вывода</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9D.D0.BE.D0.B2.D1.8B.D0.B9_.D0.B2.D0.B2.D0.BE.D0.B4.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4_.28nio.29"><span class="tocnumber">1.14</span> <span class="toctext">Новый ввод/вывод (nio)</span></a>
<ul>
<li class="toclevel-3 tocsection-32"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.14.1</span> <span class="toctext">Преобразование данных</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.98.D0.B7.D0.B2.D0.BB.D0.B5.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.BE.D0.B2"><span class="tocnumber">1.14.2</span> <span class="toctext">Извлечение примитивов</span></a></li>
<li class="toclevel-3 tocsection-34"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B1.D1.83.D1.84.D0.B5.D1.80.D0.BE.D0.B2"><span class="tocnumber">1.14.3</span> <span class="toctext">Представления буферов</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9E_.D0.BF.D0.BE.D1.80.D1.8F.D0.B4.D0.BA.D0.B5_.D0.B1.D0.B0.D0.B9.D1.82.D0.BE.D0.B2"><span class="tocnumber">1.14.4</span> <span class="toctext">О порядке байтов</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.91.D1.83.D1.84.D0.B5.D1.80.D1.8B_.D0.B8_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.81_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.BC.D0.B8"><span class="tocnumber">1.14.5</span> <span class="toctext">Буферы и операции с данными</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D0.B4.D1.80.D0.BE.D0.B1.D0.BD.D0.BE_.D0.BE_.D0.B1.D1.83.D1.84.D0.B5.D1.80.D0.B5"><span class="tocnumber">1.14.6</span> <span class="toctext">Подробно о буфере</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9E.D1.82.D0.BE.D0.B1.D1.80.D0.B0.D0.B6.D0.B0.D0.B5.D0.BC.D1.8B.D0.B5_.D0.B2_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D1.8B"><span class="tocnumber">1.14.7</span> <span class="toctext">Отображаемые в память файлы</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><span class="tocnumber">1.14.8</span> <span class="toctext">Производительность</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.91.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2"><span class="tocnumber">1.14.9</span> <span class="toctext">Блокировка файлов</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.91.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.87.D0.B0.D1.81.D1.82.D0.B8_.D0.BE.D1.82.D0.BE.D0.B1.D1.80.D0.B0.D0.B6.D0.B0.D0.B5.D0.BC.D0.BE.D0.B3.D0.BE_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0"><span class="tocnumber">1.14.10</span> <span class="toctext">Блокирование части отображаемого файла</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-42"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B6.D0.B0.D1.82.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">1.15</span> <span class="toctext">Сжатие данных</span></a>
<ul>
<li class="toclevel-3 tocsection-43"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.BE.D0.B5_.D1.81.D0.B6.D0.B0.D1.82.D0.B8.D0.B5_.D0.B2_.D1.84.D0.BE.D1.80.D0.BC.D0.B0.D1.82.D0.B5_GZIP"><span class="tocnumber">1.15.1</span> <span class="toctext">Простое сжатие в формате <i>GZIP</i></span></a></li>
<li class="toclevel-3 tocsection-44"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9C.D0.BD.D0.BE.D0.B3.D0.BE.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B0.D1.80.D1.85.D0.B8.D0.B2.D1.8B_ZIP"><span class="tocnumber">1.15.2</span> <span class="toctext">Многофайловые архивы <i>ZIP</i></span></a></li>
<li class="toclevel-3 tocsection-45"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.90.D1.80.D1.85.D0.B8.D0.B2.D1.8B_Java_ARchives_.28.D1.84.D0.B0.D0.B9.D0.BB.D1.8B_JAR.29"><span class="tocnumber">1.15.3</span> <span class="toctext">Архивы <i>Java</i> ARchives (файлы <i>JAR</i>)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-46"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B5.D1.80.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.BE.D0.B2"><span class="tocnumber">1.16</span> <span class="toctext">Сериализация объектов</span></a>
<ul>
<li class="toclevel-3 tocsection-47"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B1.D0.BD.D0.B0.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0"><span class="tocnumber">1.16.1</span> <span class="toctext">Обнаружение класса</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.B5.D1.80.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B5.D0.B9"><span class="tocnumber">1.16.2</span> <span class="toctext">Управление сериализацией</span></a></li>
<li class="toclevel-3 tocsection-49"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_transient"><span class="tocnumber">1.16.3</span> <span class="toctext">Ключевое слово transient</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.90.D0.BB.D1.8C.D1.82.D0.B5.D1.80.D0.BD.D0.B0.D1.82.D0.B8.D0.B2.D0.B0_.D0.B4.D0.BB.D1.8F_Externalizable"><span class="tocnumber">1.16.4</span> <span class="toctext">Альтернатива для Externalizable</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.94.D0.BE.D0.BB.D0.B3.D0.BE.D0.B2.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D0.BE.D0.B5_.D1.85.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.16.5</span> <span class="toctext">Долговременное хранение</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-52"><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><span class="tocnumber">1.17</span> <span class="toctext">Резюме</span></a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>
<h1><span class="mw-headline" id=".D0.A1.D0.98.D0.A1.D0.A2.D0.95.D0.9C.D0.90_.D0.92.D0.92.D0.9E.D0.94.D0.90.2F.D0.92.D0.AB.D0.92.D0.9E.D0.94.D0.90_JAVA"><b>СИСТЕМА ВВОДА/ВЫВОДА JAVA</b></span></h1>
<p>Создание хорошей системы ввода/вывода является одной из труднейших 
задач разработчика языка. Доказательством этого утверждения служит 
множество подходов, используемых при разработке систем ввода/вывода.
Основная сложность состоит в том, что необходимо учесть все возможные 
ситуации. Это не только наличие множества источников и приемников 
данных, с которыми необходимо поддерживать связь (файлы, консоль, 
сетевые соединения), но и реализации различных форм этой связи 
(последовательный доступ, произвольный, буферизованный, двоичный, 
символьный, построчный, пословный и т. д.).
</p><p>Разработчики библиотеки <i>Java</i> решили начать с создания огромного количества классов. Вообще говоря, в библиотеке ввода/вывода <i>Java</i> так много классов, что потеряться в них проще простого (парадоксально, но сама система ввода/вывода <i>Java</i> в действительности не нуждается в таком количестве классов). Потом, после выхода первой версии языка <i>Java</i>,
 в библиотеке ввода/вывода последовали значительные изменения: к 
ориентированным на посылку и прием байтов классам добавились основанные 
на Юникод классы, работающие с символами. В <i>JDK</i>-1.4 классы <i><b>nіо</b></i> (от сочетания «<i>new I/O</i>», «новый ввод/вывод») призваны улучшить производительность и функциональность.
</p><p>В результате, чтобы понять общую картину ввода/вывода в <i>Java</i>
 и начать использовать ее, вам придется изучить порядочный ворох 
классов. Вдобавок не менее важно понять и изучить эволюцию библиотеки 
ввода/вывода, несмотря на вашу очевидную реакцию: «Избавьте меня от 
истории! Просто покажите, как работать с библиотекой!» Если не уяснить 
причины изменений, проведенных в библиотеке ввода/вывода, вскоре мы 
запутаемся в ней и не сможем твердо аргументировать сделанный нами выбор
 в пользу того или иного класса.
В этой главе мы познакомимся с различными классами, отвечающими за 
ввод/вывод в библиотеке <i>Java</i>, а также научимся использовать их.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D0.B0.D1.81.D1.81_File">Класс File</span></h2>
<p>Перед тем как перейти к классам, которые осуществляют реальные запись
 и чтение данных, мы рассмотрим вспомогательные инструменты библиотеки, 
предназначенные для работы с файлами и каталогами.
Имя класса <i><b>File</b></i> весьма обманчиво: легко подумать, что оно всегда ссылается на файл, но это не так. Класс <i><b>File</b></i>
 может представлять как имя определенного файла, так, имена группы 
файлов, находящихся в каталоге. Если класс представляет каталог, его 
метод <i><b>list()</b></i> возвращает массив строк с именами всех 
файлов. Использовать в данной ситуации массив (а не более гибкий 
контейнер) очень удобно: количество файлов в каталоге фиксировано, как и
 размер массива, а если понадобится узнать имена файлов в другом 
каталоге, достаточно создать еще один объект <i><b>File</b></i>. Следующий раздел покажет, как использовать этот класс в совокупности с тесно связанным с ним интерфейсом <i><b>FilenameFilter</b></i>.
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.BF.D0.B8.D1.81.D0.BE.D0.BA_.D0.BA.D0.B0.D1.82.D0.B0.D0.BB.D0.BE.D0.B3.D0.BE.D0.B2">Список каталогов</span></h3>
<p>Предположим, вы хотите получить содержимое каталога. Объект File 
позволяет получить этот список двумя способами. Если вызвать метод <i><b>list()</b></i>
 без аргументов, то результатом будет полный список файлов и каталогов 
(точнее, их названий), содержащихся в данном каталоге. Но, если вам 
нужен ограниченный список — например, список всех файлов с расширением <i><b>.java</b></i>, — используйте «фильтр», то есть класс, который описывает критерии отбора объектов <i><b>File</b></i>.
Рассмотрим пример. Заметьте, что полученный список без всяких дополнительных усилий сортируется (по алфавиту) с помощью метода <i><b>java.util.Array.sort()</b></i> и объекта <i><b>String.CASE_INSENSITIVE_ORDER</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/DirList.java</span>
<span class="co1">// Вывод списка каталогов с использованием регулярных выражений.</span>
<span class="co1">// {Args: "D.*\.java"}</span>
<span class="kw2">import</span> <span class="co2">java.util.regex.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DirList <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw20">File</span> path = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"."</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> list<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">0</span><span class="br0">)</span>
      list = path.<span class="me1">list</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
      list = path.<span class="me1">list</span><span class="br0">(</span><span class="kw2">new</span> DirFilter<span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>list, <span class="kw21">String</span>.<span class="me1">CASE_INSENSITIVE_ORDER</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> dirItem&nbsp;: list<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>dirItem<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> DirFilter <span class="kw2">implements</span> <span class="kw20">FilenameFilter</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw53">Pattern</span> pattern<span class="sy0">;</span>
  <span class="kw2">public</span> DirFilter<span class="br0">(</span><span class="kw21">String</span> regex<span class="br0">)</span> <span class="br0">{</span>
    pattern = <span class="kw53">Pattern</span>.<span class="me1">compile</span><span class="br0">(</span>regex<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">boolean</span> accept<span class="br0">(</span><span class="kw20">File</span> dir, <span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> pattern.<span class="me1">matcher</span><span class="br0">(</span>name<span class="br0">)</span>.<span class="me1">matches</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>DirectoryDemo.java
DirList.java
DirList2.java
DirList3.java
</pre>
<p>&lt;/spoiler&gt;
Это показывает, что данный тип объекта должен поддерживать метод с именем <i><b>accept()</b></i>, который вызывается методом <i><b>list()</b></i>
 с целью определения того, какие имена файлов должны включаться в 
выходной список, а какие нет. Перед нами один из примеров паттерна 
«стратегия»: <i><b>list()</b></i> реализует базовую функциональность, a <i><b>FilenameFilter</b></i> предоставляет алгоритм, необходимый для работы <i><b>list()</b></i>. Так как метод <i><b>list()</b></i> принимает в качестве аргумента объект <i><b>FilenameFilter</b></i>, ему можно передать любой объект любого класса, лишь бы он реализовывал интерфейс <i><b>FilenameFilter</b></i> (даже во время выполнения). Таким образом легко изменять результат работы метода <i><b>list()</b></i>. Целью данного паттерна является обеспечение гибкости в поведении кода.
</p><p>Метод <i><b>accept()</b></i> получает объект <i><b>File</b></i>, представляющий собой каталог, в котором был найден данный файл, и строку с именем файла. Помните, что метод <i><b>list()</b></i> вызывает <i><b>accept()</b></i>
 для каждого файла, обнаруженного в каталоге, чтобы определить, какие из
 них следует включить в выходной список — в зависимости от возвращаемого
 значения <i><b>accept()</b></i> (значение типа <i><b>boolean</b></i>).
</p><p>Метод <i><b>accept()</b></i> использует объект регулярного выражения <i><b>matcher</b></i>, чтобы посмотреть, соответствует ли имя файла выражению <i><b>regex</b></i>. Метод <i><b>list()</b></i> возвращает массив.
</p>
<h3><span class="mw-headline" id=".D0.91.D0.B5.D0.B7.D1.8B.D0.BC.D1.8F.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B">Безымянные внутренние классы</span></h3>
<p>Описанный пример идеально подходит для демонстрации преимуществ 
внутренних классов (описанных в главе 10). Для начала создадим метод <i><b>filter()</b></i>, который возвращает ссылку на объект <i><b>FilenameFilter</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/DirList2.java</span>
<span class="co1">// Использование безымянных внутренних классов.</span>
<span class="co1">// {Args: "D.*\.java"}</span>
<span class="kw2">import</span> <span class="co2">java.util.regex.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DirList2 <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw20">FilenameFilter</span> filter<span class="br0">(</span><span class="kw2">final</span> <span class="kw21">String</span> regex<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Creation of anonymous inner class:</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw20">FilenameFilter</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">private</span> <span class="kw53">Pattern</span> pattern = <span class="kw53">Pattern</span>.<span class="me1">compile</span><span class="br0">(</span>regex<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">public</span> <span class="kw3">boolean</span> accept<span class="br0">(</span><span class="kw20">File</span> dir, <span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">return</span> pattern.<span class="me1">matcher</span><span class="br0">(</span>name<span class="br0">)</span>.<span class="me1">matches</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span> <span class="co1">// End of anonymous inner class</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw20">File</span> path = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"."</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> list<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">0</span><span class="br0">)</span>
      list = path.<span class="me1">list</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
      list = path.<span class="me1">list</span><span class="br0">(</span>filter<span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>list, <span class="kw21">String</span>.<span class="me1">CASE_INSENSITIVE_ORDER</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> dirItem&nbsp;: list<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>dirItem<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>DirectoryDemo.java
DirList.java
DirList2.java
DirList3.java
</pre>
<p>&lt;/spoiler&gt;
Заметьте, что аргумент метода <i><b>filter()</b></i> должен быть неизменным (<i><b>final</b></i>). Это необходимо для того, чтобы внутренний класс смог получить к нему доступ даже за пределами области определения аргумента.
Несомненно, структура программы улучшилась хотя бы потому, что объект <i><b>FilenameFilter</b></i> теперь неразрывно связан с внешним классом <i><b>DirList2</b></i>. Впрочем, можно сделать следующий шаг и определить безымянный внутренний класс как аргумент метода <i><b>list()</b></i>, в результате чего программа станет еще более компактной:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/DirList3.java</span>
<span class="co1">// Создание безымянного внутреннего класса "на месте".</span>
<span class="co1">// {Args: "D.*\.java"}</span>
<span class="kw2">import</span> <span class="co2">java.util.regex.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> DirList3 <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw2">final</span> <span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw20">File</span> path = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"."</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> list<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">0</span><span class="br0">)</span>
      list = path.<span class="me1">list</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span>
      list = path.<span class="me1">list</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">FilenameFilter</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">private</span> <span class="kw53">Pattern</span> pattern = <span class="kw53">Pattern</span>.<span class="me1">compile</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw2">public</span> <span class="kw3">boolean</span> accept<span class="br0">(</span><span class="kw20">File</span> dir, <span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
          <span class="kw2">return</span> pattern.<span class="me1">matcher</span><span class="br0">(</span>name<span class="br0">)</span>.<span class="me1">matches</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Arrays</span>.<span class="me1">sort</span><span class="br0">(</span>list, <span class="kw21">String</span>.<span class="me1">CASE_INSENSITIVE_ORDER</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> dirItem&nbsp;: list<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>dirItem<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>DirectoryDemo.java
DirList.java
DirList2.java
DirList3.java
</pre>
<p>&lt;/spoiler&gt;
На этот раз неизменным (<i><b>final</b></i>) объявлен аргумент метода <i><b>main()</b></i>, так как безымянный внутренний класс использует параметр командной строки (<i><b>args[0]</b></i>)
 напрямую.
Именно так безымянные внутренние классы позволяют быстро создать 
«одноразовый» класс, полезный только для решения одной конкретной 
задачи. Одно из преимуществ такого подхода состоит в том, что весь код, 
решающий некоторую задачу, находится в одном месте. С другой стороны, 
полученный код не слишком хорошо читается, поэтому при их использовании 
необходимо действовать осмотрительно.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B2.D0.B5.D1.80.D0.BA.D0.B0_.D1.81.D1.83.D1.89.D0.B5.D1.81.D1.82.D0.B2.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D0.B8_.D1.81.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.B0.D1.82.D0.B0.D0.BB.D0.BE.D0.B3.D0.BE.D0.B2">Проверка существования и создание каталогов</span></h3>
<p>Класс <i><b>File</b></i> не ограничивается представлением 
существующих файлов или каталогов, он способен на большее. Он также 
может использоваться для создания нового каталога или даже дерева 
каталогов, если последние не существуют. Можно также узнать свойства 
файлов (размер, дату последнего изменения, режим чтения (записи)), 
определить, файл или каталог представляет объект <i><b>File</b></i>, удалить файл. Следующая программа демонстрирует некоторые методы класса <i><b>File</b></i> (за полной информацией обращайтесь к документации JDК, доступной для загрузки с сайта java.sun.com):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/MakeDirectories.java</span>
<span class="co1">// Использование класса File для создания </span>
<span class="co1">// каталогов и выполнения операций с файлами. </span>
<span class="co1">// {Параметры: MakeDirectoriesTest} import java io.-*;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> MakeDirectories <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">void</span> usage<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span>
      <span class="st0">"Usage:MakeDirectories path1 ...<span class="es0">\n</span>"</span> +
      <span class="st0">"Creates each path<span class="es0">\n</span>"</span> +
      <span class="st0">"Usage:MakeDirectories -d path1 ...<span class="es0">\n</span>"</span> +
      <span class="st0">"Deletes each path<span class="es0">\n</span>"</span> +
      <span class="st0">"Usage:MakeDirectories -r path1 path2<span class="es0">\n</span>"</span> +
      <span class="st0">"Renames from path1 to path2"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">void</span> fileData<span class="br0">(</span><span class="kw20">File</span> f<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>
      <span class="st0">"Absolute path: "</span> + f.<span class="me1">getAbsolutePath</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> Can read: "</span> + f.<span class="me1">canRead</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> Can write: "</span> + f.<span class="me1">canWrite</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> getName: "</span> + f.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> getParent: "</span> + f.<span class="me1">getParent</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> getPath: "</span> + f.<span class="me1">getPath</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> length: "</span> + f.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"<span class="es0">\n</span> lastModified: "</span> + f.<span class="me1">lastModified</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>f.<span class="me1">isFile</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"It's a file"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">else</span> <span class="kw1">if</span><span class="br0">(</span>f.<span class="me1">isDirectory</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"It's a directory"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">&lt;</span> <span class="nu0">1</span><span class="br0">)</span> usage<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">equals</span><span class="br0">(</span><span class="st0">"-r"</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">!</span>= <span class="nu0">3</span><span class="br0">)</span> usage<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw20">File</span>
        old = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>,
        rname = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      old.<span class="me1">renameTo</span><span class="br0">(</span>rname<span class="br0">)</span><span class="sy0">;</span>
      fileData<span class="br0">(</span>old<span class="br0">)</span><span class="sy0">;</span>
      fileData<span class="br0">(</span>rname<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">return</span><span class="sy0">;</span> <span class="co1">// Exit main</span>
    <span class="br0">}</span>
    <span class="kw3">int</span> count = <span class="nu0">0</span><span class="sy0">;</span>
    <span class="kw3">boolean</span> del = <span class="kw4">false</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">equals</span><span class="br0">(</span><span class="st0">"-d"</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      count++<span class="sy0">;</span>
      del = <span class="kw4">true</span><span class="sy0">;</span>
    <span class="br0">}</span>
    count--<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>++count <span class="sy0">&lt;</span> args.<span class="me1">length</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw20">File</span> f = <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>args<span class="br0">[</span>count<span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>f.<span class="me1">exists</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>f + <span class="st0">" exists"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>del<span class="br0">)</span> <span class="br0">{</span>
          <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"deleting..."</span> + f<span class="br0">)</span><span class="sy0">;</span>
          f.<span class="me1">delete</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
      <span class="kw1">else</span> <span class="br0">{</span> <span class="co1">// Doesn't exist</span>
        <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>del<span class="br0">)</span> <span class="br0">{</span>
          f.<span class="me1">mkdirs</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
          <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"created "</span> + f<span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span>
      fileData<span class="br0">(</span>f<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (80% match)
</p>
<pre>created MakeDirectoriesTest
Absolute path: d:\aaa-TIJ4\code\io\MakeDirectoriesTest
Can read: true
Can write: true
getName: MakeDirectoriesTest
getParent: null
getPath: MakeDirectoriesTest
length: 0
lastModified: 1101690308831
It's a directory
</pre>
<p>&lt;/spoiler&gt;
В методе <i><b>fileData()</b></i> продемонстрированы различные методы, предназначенные для получения информации о файлах и каталогах.
Сначала в методе <i><b>main()</b></i> вызывается метод <i><b>renameTo()</b></i>, который позволяет переименовывать (или перемещать) файлы, используя для этого второй аргумент — еще один объект <i><b>File</b></i>,
 который указывает на новое местоположение или имя.
Если вы поэкспериментируете с этой программой, то увидите, что создать 
пути произвольной сложности очень просто, поскольку всю работу за вас 
фактически делает метод <i><b>mkdirs()</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D0.B2.D0.BE.D0.B4_.D0.B8_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4">Ввод и вывод</span></h2>
<p>В библиотеках ввода/вывода часто используется абстрактное понятие потока (<i>stream</i>)
 — произвольного источника или приемника данных, который способен 
производить или получать некоторую информацию. Поток скрывает детали 
низкоуровневых процессов, происходящих с данными непосредственно в 
устройствах ввода/вывода.
</p><p>Классы библиотеки ввода/вывода <i>Java</i> разделены на две части — одни осуществляют ввод, другие вывод. В этом можно убедиться, просмотрев документацию <i>JDK</i>. Все классы, производные от базовых классов <i><b>InputStream</b></i> или <i><b>Reader</b></i>, имеют методы с именами <i><b>read()</b></i> для чтения одиночных байтов или массива байтов. Аналогично, все классы, производные от базовых классов <i><b>OutputStream</b></i> или <i><b>Writer</b></i>, имеют методы с именами <i><b>write()</b></i>
 для записи одиночных байтов или массива байтов. Впрочем, вы вряд ли 
станете использовать эти методы напрямую — они в основном предназначены 
для других классов, предоставляющих более полные возможности. Таким 
образом, заключение объекта-потока в один класс — занятие довольно 
неэффективное, обычно несколько объектов «наслаиваются» друг на друга 
для получения необходимой функциональности. Необходимость построения 
потока на основе нескольких объектов — главная причина трудностей в 
освоении библиотеки ввода/вывода <i>Java</i>.
</p><p>Классы ввода/вывода удобно разделить по категориям, в зависимости от их функций. В <i>Java</i> 1.0 разработчики решили, что все, связанное с вводом данных, должно быть производным от базового класса <i><b>InputStream</b></i>, а все, имеющее отношение к выводу данных, — от класса <i><b>OutputStream</b></i>.
</p><p>Как обычно, я постараюсь привести общий обзор этих классов, но за
 полными описаниями и списками методов каждого класса следует обращаться
 к документации <i>JDK</i>.
</p>
<h3><span class="mw-headline" id=".D0.A2.D0.B8.D0.BF.D1.8B_InputStream">Типы InputStream</span></h3>
<p>Назначение базового класса <i><b>InputStream</b></i> — представлять классы, которые получают данные из различных источников. Такими источниками могут быть:
</p>
<hr>
<ul>
<li><span style="color:#800000">массив байтов;</span>
</li>
<li><span style="color:#800000">строка (<i><b>String</b></i>);</span>
</li>
<li><span style="color:#800000">файл;</span>
</li>
<li><span style="color:#800000">«канал» (<i>pipe</i>): данные помещаются с одного «конца» и извлекаются с другого;</span>
</li>
<li><span style="color:#800000">последовательность различных потоков, которые можно объединить в одном потоке;</span>
</li>
<li><span style="color:#800000">другие источники (например, подключение к Интернету).</span>
</li>
</ul>
<hr>
<p>С каждым из перечисленных источников связывается некоторый подкласс базового класса <i><b>InputStream</b></i> (табл. 16.1). Существует еще класс <i><b>FilterInputStream</b></i>, который также является производным классом <i><b>InputStream</b></i>
 и представляет собой основу для классов-«надстроек», наделяющих входные
 потоки полезными свойствами и интерфейсами. Его мы обсудим чуть позже.
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0490.png" class="image"><img alt="P0490.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0490.png" height="856" width="792"></a>
</p>
<h3><span class="mw-headline" id=".D0.A2.D0.B8.D0.BF.D1.8B_OutputStream">Типы OutputStream</span></h3>
<p>В данную категорию (табл. 16.2) попадают классы, определяющие, куда направляются ваши данные: в массив байтов (но не напрямую в <i><b>String</b></i>; предполагается, что вы сможете создать их из массива байтов), в файл или в канал. Вдобавок класс <i><b>FilterOutputStream</b></i>
 предоставляет базовый класс для классов-«надстроек», которые способны 
наделять существующие потоки новыми полезными атрибутами и интерфейсами.
 Подробности мы отложим на потом.
<a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0491.png" class="image"><img alt="P0491.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0491.png" height="581" width="792"></a>
</p>
<h2><span class="mw-headline" id=".D0.94.D0.BE.D0.B1.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B0.D1.82.D1.80.D0.B8.D0.B1.D1.83.D1.82.D0.BE.D0.B2_.D0.B8_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.BE.D0.B2">Добавление атрибутов и интерфейсов</span></h2>
<p>«Наслаивание» дополнительных объектов для получения новых свойств и 
функций у определенных объектов называется надстройкой, или декораторомВ
 библиотеке ввода/вывода <i>Java</i> постоянно требуется совмещение нескольких свойств, поэтому в ней и используются надстройки. Существование
</p>
<dl>
<dd>Все употребляемые далее термины: «настраивание», «наслаивание», 
«фильтрация» или «декорирование» — по сути, означают одно и то же — 
перегрузку всех методов <i><b>InputStream</b></i> для придания до­полнительной функциональности при работе с данными потоков. При этом класс <i><b>FilterInputStream</b></i> осуществляет перегрузку без посторонней помощи, а данные соответствующим образом трансфор­мируются. Подклассы <i><b>FilterInputStream</b></i> могут, в свою очередь, перегрузить эти же методы и добавить дополнительные методы и поля. — <i>Примеч. ред.</i>
</dd>
</dl>
<p>в библиотеке ввода/вывода <i>Java</i> классов-фильтров объясняется 
тем, что абстрактный класс фильтра является базвовым классом для всех 
существующих надстроек. (Надстройка должна включать в себя интерфейс 
«декорируемого» объекта, но расширение этого интерфейса также не 
запрещено и практикуется некоторыми классами-«фильтрами».)
Однако у такого подхода есть свои недостатки. Надстройки предоставляют 
дополнительную гибкость при написании программы (можно легко совмещать 
различные атрибуты), но при этом код получается излишне сложным. 
Некоторое неудобство библиотеки ввода/вывода <i>Java</i> объясняется 
тем, что для получения желаемого объекта приходится создавать много 
дополнительных объектов — «ядро» ввода/вывода и несколько надстроек.
Интерфейс для надстроек предоставляют классы <i><b>FilterInputStream</b></i> (для входных потоков) и <i><b>FilterOutputStream</b></i> (для выходных потоков). Это абстрактные классы, производные от основных базовых классов библиотеки ввода/вывода <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>.
 Наследование от этих классов — основное требование к классу-надстройке 
(поскольку таким образом обеспечивается общий интерфейс для 
«наслаиваемых» объектов).
</p>
<h2><span class="mw-headline" id=".D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_InputStream_.D1.81_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC_FilterInputStream">Чтение из InputStream с использованием FilterInputStream</span></h2>
<p>Классы, производные от <i><b>FilterInputStream</b></i> (табл. 16.3), выполняют две различные миссии. <i><b>DataInputStream</b></i>
 позволяет читать из потока различные типы простейших данных и строки. 
(Все методы этого класса начинаются с префикса read — например, <i><b>readByte(), readFloat()</b></i> и т. п.) Этот класс, вместе с «парным» классом <i><b>DataOutputStream</b></i>,
 предоставляет возможность направленной передачи простейших данных 
посредством потоков. Место доставки определяется классами, описанными в 
табл. 16.1.
</p><p>Другие классы изменяют внутренние механизмы входного потока: 
применение буферизации, подсчет количества прочитанных строк (что 
позволяет запросить или задать номер строки), возможность возврата в 
поток только что прочитанных символов. Вероятно, последние два класса 
создавались в основном для построения компиляторов (то есть их добавили в
 библиотеку в процессе написания компилятора <i>Java</i>), и прока в повседневном программировании от них немного.
</p><p>Ввод данных почти всегда осуществляется с буферизацией, вне 
зависимости от присоединенного устройства ввода/вывода, поэтому имеет 
смысл сделать отдельный класс (или просто специальный метод) не для 
буферизованного ввода данных, а, наоборот, для прямого.
</p><p><b>Таблица 16.3. Разновидности надстроек FilterInputStream</b>
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0493.png" class="image"><img alt="P0493.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0493.png" height="508" width="784"></a>
</p><p>(целые (<i><b>int, long</b></i>), символы (<i><b>char</b></i>) и 
т. д.) из потока, без привязки к внутреннему представлению Используется 
для предотвращения физического обращения к устройству при каждом новом 
запросе данных
</p><p>Следит за количеством считанных из потока строк; вы можете узнать их число, вызвав метод <i><b>getLineNumber()</b></i>, а также перейти к определенной строке с помощью метода <i><b>setLineNumber(int)</b></i> Имеет односимвольный буфер, который позволяет вернуть в поток только что прочитанный символ
</p><p>Входной поток <i><b>InputStream</b></i>, размер буфера 
(необязательно). По существу, никакого интерфейса этот класс не 
предоставляет, он просто присоединяет к потоку буфер. Добавьте 
дополнительно объект, предоставляющий интерфейс Входной поток <i><b>InputStream</b></i>. Этот класс просто считывает строки, поэтому к нему стоит добавить еще одну, более полезную, надстройку
</p><p>Входной поток <i><b>InputStream</b></i>. Обычно используется при сканировании файлов для компилятора. Скорее всего, вам он не понадобится
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D0.BF.D0.B8.D1.81.D1.8C_.D0.B2_OutputStream_.D1.81_.D0.BF.D0.BE.D0.BC.D0.BE.D1.89.D1.8C.D1.8E_FilterOutputStream">Запись в OutputStream с помощью FilterOutputStream</span></h2>
<p>У класса <i><b>DataInputStream</b></i> существует «парный» класс <i><b>DataOutputStream</b></i>
 (табл. 16.4), который позволяет форматировать и записывать в поток 
примитивы и строки таким образом, что на любой машине и на любой 
платформе их сможет прочитать и правильно обработать <i><b>DataInputStream</b></i>. Все его методы начинаются с префикса <i>write</i> (запись): <i><b>writeByte(), writeFloat()</b></i> и т. п.
Класс <i><b>PrintStream</b></i> изначально был предназначен для вывода значений в формате, понятном для человека. В данном аспекте он отличается от класса <i><b>DataOutputStream</b></i>, потому что цель последнего — разместить данные в потоке так, чтобы DataInputStream смог их правильно распознать.
Основные методы класса <i><b>PrintStream — print()</b></i> и <i><b>println()</b></i>,
 они перегружены для наиболее часто используемых типов. После вывода 
значения метод println() осуществляет перевод на новую строку, в то 
время как метод <i><b>print()</b></i> этого не делает.
На практике класс PrintStream довольно-таки неудобен, поскольку он 
перехватывает и скрывает все возбуждаемые исключения. (Приходится явно 
вызывать метод <i><b>checkError()</b></i>, который возвращает <i><b>true</b></i>,
 если во время исполнения какого-либо из методов класса произошла 
ошибка.) К тому же этот класс как следует не интернационализован и не 
выполняет перевод строки платформно-независимым способом (все эти 
проблемы решены в классе <i><b>PrintWriter</b></i>, описанном ниже).
Класс <i><b>BufferedOutputStream</b></i> модифицирует поток так, чтобы 
использовалась буферизация при записи данных, которая предотвращает 
слишком частые обращения к физическому устройству. Вероятно, именно его 
следует порекомендовать для вывода в поток каких-либо данных.
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0494.png" class="image"><img alt="P0494.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0494.png" height="557" width="792"></a>
</p><p>Используется в сочетании с классом <i><b>DataInputStream</b></i>,
 позволяет записывать в поток примитивы (целые, символы и т. д.) 
независимо от платформы При записи форматирует данные. Если класс <i><b>DataOutputStream</b></i>
 отвечает за хранение данных, то этот класс отвечает за отображение 
данных
Используется для буферизации вывода, то есть для предотвращения прямой 
записи в устройство каждый раз при записи данных. Для записи содержимого
 буфера в устройство используется метод <i><b>flush()</b></i>
Выходной поток <i><b>OutputStream</b></i>. Содержит все необходимое для записи простейших типов данных
Выходной поток <i><b>OutputStream</b></i>, а также необязательный логический (<i><b>boolean</b></i>) аргумент, показывающий, нужно ли очищать буфер записи при переходе на новую строку.
Должен быть последним в «наслоении» объектов для выходного потока <i><b>OutputStream</b></i>. Вероятно, вы будете часто его использовать Выходной поток <i><b>OutputStream</b></i>,
 а также размер буфера записи (необязательно). Не предоставляет 
интерфейса как такового, просто указывает, что при выводе необходимо 
использовать буферизацию. К классу следует присоединить более 
содержательный класс-«фильтр»
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D0.B0.D1.81.D1.81.D1.8B_Reader_.D0.B8_Writer">Классы Reader и Writer</span></h2>
<p>При выпуске <i>Java</i> версии 1.1 в библиотеке ввода/вывода были 
сделаны значительные изменения. Когда в первый раз видишь новые классы, 
основанные на базовых классах <i><b>Reader</b></i> и <i><b>Writer</b></i>, возникает мысль, что они пришли на замену классам <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>.
 Тем не менее это не так. Хотя некоторые аспекты изначальной библиотеки 
ввода/вывода, основанной на потоках, объявлены устаревшими (и при их 
использовании компилятор выдаст соответствующее предупреждение), классы <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>
 все еще предоставляют достаточно полезные возможности для проведения 
байт-ориентированного ввода/ вывода. Одновременно с этим классы <i><b>Reader</b></i> и <i><b>Writer</b></i> позволяют проводить операции символьно ориентированного ввода/вывода, в кодировке Юникод. Дополнительно:
</p>
<hr>
<ul>
<li><span style="color:#800000">В <i>Java</i> 1.1 в иерархию потоков, основанную на классах <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>, были добавлены новые классы. Очевидно, эта иерархия не должна была уйти в прошлое.</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">В некоторых ситуациях для решения задачи
 используются как «байтовые», так и «символьные» классы. Для этого в 
библиотеке появились классы-адаптеры: <i><b>InputStreamReader</b></i> конвертирует <i><b>InputStream</b></i> в <i><b>Reader</b></i>, a <i><b>OutputStreamWriter</b></i> трансформирует <i><b>OutputStream</b></i> в <i><b>Writer</b></i>.</span>
</li>
</ul>
<hr>
<p>Основной причиной появления иерархий классов <i><b>Reader</b></i> и <i><b>Writer</b></i>
 стала интернационализация. Старая библиотека ввода/вывода поддерживала 
только 8-битовые символы и зачастую неверно обращалась с 16-битовыми 
символами Юникода. Именно благодаря символам Юникода возможна 
интернационализация программ (простейший тип <i>Java</i> <i><b>char</b></i>
 (символ) также основан на Юникоде), поэтому новые классы отвечают за их
 правильное использование в операциях ввода/вывода. Вдобавок новые 
средства спроектированы так, что работают быстрее старых классов.
</p>
<h2><span class="mw-headline" id=".D0.98.D1.81.D1.82.D0.BE.D1.87.D0.BD.D0.B8.D0.BA.D0.B8_.D0.B8_.D0.BF.D1.80.D0.B8.D0.B5.D0.BC.D0.BD.D0.B8.D0.BA.D0.B8_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Источники и приемники данных</span></h2>
<p>Практически у всех изначальных потоковых классов имеются соответствующие классы <i><b>Reader</b></i> и <i><b>Writer</b></i>
 со схожими функциями, однако работающие с символами Юникода. Впрочем, 
во многих ситуациях правильным (а зачастую и единствен­ным) выбором 
становятся классы, ориентированные на прием и посылку байтов; в 
особенности это относится к библиотекам сжатия данных <i><b>java.util.zip</b></i>. Поэтому лучше всего будет такая тактика: пытаться использовать классы <i><b>Reader</b></i> и <i><b>Writer</b></i> где только возможно. Обнаружить место, где эти классы неприменимы, будет нетрудно — компилятор выдаст вам сообщение об ошибке.
</p><p>В табл. 16.5 показано соответствие между источниками и получателями информации двух иерархий библиотеки ввода/вывода <i>Java</i>.
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0495.png" class="image"><img alt="P0495.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0495.png" height="401" width="780"></a>
</p><p>основном интерфейсы соответствующих друг другу классов из двух разных иерархий очень сходны, если не совпадают.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D0.B7.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B2.D0.B5.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0">Изменение поведения потока</span></h2>
<p>Для потоков <i><b>InputStream</b></i> и <i><b>OutputStream</b></i> существуют классы-«декораторы» на основе классов <i><b>FilterInputStream</b></i> и <i><b>FilterOutputStream</b></i>.
 Они позволяют модифицировать изначальный поток ввода/вывода так, как 
это необходимо в данной ситуации. Иерархия на основе классов <i><b>Reader</b></i> и <i><b>Writer</b></i> также взяла на вооружение данный подход, но по-другому.
</p><p>В табл. 16.6 соответствие классов уже не такое точное, как это 
было в предыдущей таблице. Причина — организация классов: в то время как
 <i><b>BufferedOutputStream</b></i> является подклассом <i><b>FilterOutputStream</b></i>, класс <i><b>BufferedWriter</b></i> не наследует от базового класса <i><b>FilterWriter</b></i>
 (от него вообще не происходит ни одного класса, хотя он и является 
абстрактным — видимо, его поместили в библиотеку просто для полноты 
картины). Впрочем, интерфейсы классов очень похожи.
</p><p><br>
<a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0496.png" class="image"><img alt="P0496.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0496.png" height="431" width="782"></a>
</p><p>Один совет очевиден: для чтения строк больше не следует употреблять класс <i><b>DataInputStream</b></i> (при такой попытке компилятор сообщит вам, что этот метод для чтения строк устарел), вместо него используйте класс <i><b>BufferedReader</b></i>. Во всех других ситуациях класс <i><b>DataInputStream</b></i> остается выбором «номер один» из всего многообразия библиотеки ввода/вывода.
</p><p>Чтобы облегчить переход к классу <i><b>PrintWriter</b></i>, в 
него добавили конструктор, который принимает в качестве аргумента 
выходной поток OutputStream (обычный конструктор принимает класс <i><b>Writer</b></i>). Интерфейс форматирования <i><b>PrintWriter</b></i> практически идентичен интерфейсу <i><b>PrintStream</b></i>.
</p><p>В <i>Java</i> <i>SE5</i> были добавлены конструкторы <i><b>PrintWriter</b></i>, упрощающие создание файлов при выводе (см. далее).
</p><p>Кроме того, в конструкторе класса <i><b>PrintWriter</b></i> можно указать дополнительный флаг, чтобы содержимое буфера каждый раз сбрасывалось при записи новой строки (методом <i><b>println()</b></i>).
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D0.B0.D1.81.D1.81.D1.8B.2C_.D0.BE.D1.81.D1.82.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B1.D0.B5.D0.B7_.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.B5.D0.BD.D0.B8.D0.B9">Классы, оставленные без изменений</span></h2>
<p>Некоторые классы избежали перемен и остались в версии <i>Java</i> 1.1 в том же виде, что и в версии 1.0:
</p>
<pre>• DataOutputStream;
• File;
• RandomAccessFile;
• SequenceInputStream.
</pre>
<p>Обращает на себя внимание тот факт, что изменения не коснулись класса <i><b>DataOutputStream</b></i>,
 используемого для пересылки данных независимым от платформы и машины 
способом, поэтому для передачи данных между компьютерами по-прежнему 
остаются актуальными иерархии <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>.
</p>
<h2><span class="mw-headline" id="RandomAccessFile:_.D1.81.D0.B0.D0.BC_.D0.BF.D0.BE_.D1.81.D0.B5.D0.B1.D0.B5">RandomAccessFile: сам по себе</span></h2>
<p>Класс <i><b>RandomAccessFile</b></i> предназначен для работы с файлами, содержащими записи известного размера, между которыми можно перемещаться методом <i><b>seek()</b></i>,
 а также выполнять операции чтения и модификации. Записи не обязаны 
иметь фиксированную длину; вы просто должны уметь определить их размер и
 то, где они располагаются в файле.
</p><p>Поначалу с трудом верится, что класс <i><b>RandomAccessFile</b></i> не является полноценным представителем иерархии потоков ввода/вывода на основе классов <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>. Но тем не менее никаких связей с этими классами и их иерархиями у него нет, разве что он реализует интерфейсы <i><b>DataInput</b></i> и <i><b>DataOutput</b></i> (также реализуемые классами <i><b>DataInputStream</b></i> и <i><b>DataOutputStream</b></i>). Он не использует функциональность существующих классов из иерархии <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>
 — это полностью независимый класс, написанный «с чистого листа», со 
своими собственными методами. Причина кроется, скорее всего, в том, что 
класс <i><b>RandomAccessFile</b></i> позволяет свободно перемещаться по 
файлу как в прямом, так и в обратном направлении, что для других типов 
ввода/вывода невозможно. Так или иначе, он стоит особняком и напрямую 
наследует от корневого класса <i><b>Object</b></i>.
</p><p>По сути, класс <i><b>RandomAccessFile</b></i> похож на пару совмещенных в одном классе потоков <i><b>DataInputStream</b></i> и <i><b>DataOutputStream</b></i>, к которым на всем «протяжении» применимы: метод <i><b>getFilePointer()</b></i>, показывающий, где вы «находитесь» в данный момент; метод <i><b>seek()</b></i>, позволяющий перемещаться на заданную позицию файла; и метод <i><b>length()</b></i>, определяющий максимальный размер файла. Вдобавок, конструктор этого класса требует второй аргумент (схоже с методом <i><b>fopen()</b></i> в С), устанавливающий режим использования файла: только для чтения (строка «<i><b>r</b></i>») или для чтения и для записи (строка «<i><b>rw</b></i>»). Поддержки файлов только для записи нет, поэтому разумно предположить, что класс <i><b>RandomAccessFile</b></i> можно было бы унаследовать от <i><b>DataInputStream</b></i> без потери функциональности.
</p><p>Прямое позиционирование допустимо только для класса <i><b>RandomAccessFile</b></i>, и работает оно только в случае файлов. Класс <i><b>BufferedInputStream</b></i> позволяет вам пометить некоторую позицию потока методом <i><b>mark()</b></i>, а затем вернуться к ней методом <i><b>reset()</b></i>.
 Однако эта возможность ограничена (позиция запоминается в единственной 
внутренней переменной) и потому нечасто востребована.Большая часть (если
 не вся) функциональности класса <i><b>RandomAccessFile</b></i> в <i>JDK</i>-1.4 также реализуется отображаемыми в память файлами (<i>memory-mapped files</i>) из нового пакета <i><b>nio</b></i>. Мы обсудим их чуть позже.
</p>
<h2><span class="mw-headline" id=".D0.A2.D0.B8.D0.BF.D0.B8.D1.87.D0.BD.D0.BE.D0.B5_.D0.B8.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.B2_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0">Типичное использование потоков ввода/вывода</span></h2>
<p>Хотя из классов библиотеки ввода/вывода, реализующих потоки, можно 
составить множество разнообразных конфигураций, обычно используется 
несколько наиболее употребимых. Следующие примеры можно рассматривать 
как простое руководство по созданию типичных сочетаний классов для 
организации ввода/вывода и координации их взаимодействия.
В этих примерах используется упрощенная обработка исключений с передачей
 их на консоль, но такой способ подойдет только для небольших программ и
 утилит. В реальном коде следует использовать более совершенные средства
 обработки ошибок.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.91.D1.83.D1.84.D0.B5.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B5_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0">Буферизованное чтение из файла</span></h3>
<p>Чтобы открыть файл для посимвольного чтения, используется класс <i><b>FileInputReader</b></i>; имя файла задается в виде строки (<i><b>String</b></i>) или объекта <i><b>File</b></i>. Ускорить процесс чтения помогает буферизация ввода, для этого полученная ссылка передается в конструктор класса <i><b>BufferedReader</b></i>. Так как в интерфейсе класса- имеется метод <i><b>readLine()</b></i>, все необходимое для чтения имеется в вашем распоряжении. При достижении конца файла метод <i><b>readLine()</b></i> возвращает ссылку <i><b>null</b></i>.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/BufferedInputFile.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BufferedInputFile <span class="br0">{</span>
  <span class="co1">// Throw exceptions to console:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw21">String</span>
  read<span class="br0">(</span><span class="kw21">String</span> filename<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="co1">// Reading input by lines:</span>
    <span class="kw20">BufferedReader</span> in = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileReader</span><span class="br0">(</span>filename<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw21">StringBuilder</span> sb = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = in.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span>
      sb.<span class="me1">append</span><span class="br0">(</span>s + <span class="st0">"<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
    in.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> sb.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>read<span class="br0">(</span><span class="st0">"BufferedInputFile.java"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Объект <i><b>StringBuilder sb</b></i> служит для объединения всего прочитанного текста (включая переводы строк, поскольку метод <i><b>readLine()</b></i> их отбрасывает). В завершение файл закрывается методом <i><b>close()</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D0.B8">Чтение из памяти</span></h3>
<p>В этой секции результат <i><b>String</b></i> файла <i><b>BufferedInputFile.read()</b></i> используется для создания <i><b>StringReader</b></i>. Затем символы последовательно читаются методом <i><b>read()</b></i>, и каждый следующий символ посылается на консоль.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/MemoryInput.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> MemoryInput <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">StringReader</span> in = <span class="kw2">new</span> <span class="kw20">StringReader</span><span class="br0">(</span>
      BufferedInputFile.<span class="me1">read</span><span class="br0">(</span><span class="st0">"MemoryInput.java"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> c<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>c = in.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= -<span class="nu0">1</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>c<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Обратите внимание: метод <i><b>read()</b></i> возвращает следующий символ в формате <i><b>int</b></i>, и для правильного вывода его необходимо предварительно преобразовать в <i><b>char</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A4.D0.BE.D1.80.D0.BC.D0.B0.D1.82.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D0.BE.D0.B5_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D0.B8">Форматированное чтение из памяти</span></h3>
<p>Для чтения «форматированных» данных применяется класс <i><b>DataInputStream</b></i>, ориентированный на ввод/вывод байтов, а не символов. В данном случае необходимо использовать классы иерархии <i><b>InputStream</b></i>, а не их аналоги на основе класса <i><b>Reader</b></i>. Конечно, можно прочитать все, что угодно (например, файл), через <i><b>InputStream</b></i>, но здесь используется тип <i><b>String</b></i>.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/FormattedMemoryInput.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FormattedMemoryInput <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw166">DataInputStream</span> in = <span class="kw2">new</span> <span class="kw166">DataInputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">ByteArrayInputStream</span><span class="br0">(</span>
         BufferedInputFile.<span class="me1">read</span><span class="br0">(</span>
          <span class="st0">"FormattedMemoryInput.java"</span><span class="br0">)</span>.<span class="me1">getBytes</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="kw4">true</span><span class="br0">)</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>in.<span class="me1">readByte</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">EOFException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">err</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"End of stream"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Для преобразования строки в массив байтов, пригодный для помещения в поток <i><b>ByteArrayInputStream</b></i>, в классе <i><b>String</b></i> предусмотрен метод <i><b>getBytes()</b></i>. Полученный <i><b>ByteArrayInputStream</b></i> представляет собой поток <i><b>InputStream</b></i>, подходящий для передачи <i><b>DataInputStream</b></i>.
При побайтовом чтении символов из форматированного потока <i><b>DataInputStream</b></i> методом <i><b>readByte()</b></i>
 любое полученное значение будет считаться действительным, поэтому 
возвращаемое значение неприменимо для идентификации конца потока. Вместо
 этого можно использовать метод <i><b>available()</b></i>, который сообщает, сколько еще осталось символов. В следующем примере показано, как читать файл побайтно:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/TestEOF.java</span>
<span class="co1">// Проверка достижения конца файла одновременно</span>
<span class="co1">// с чтением из него по байту.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> TestEOF <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw166">DataInputStream</span> in = <span class="kw2">new</span> <span class="kw166">DataInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">BufferedInputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"TestEOF.java"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>in.<span class="me1">available</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>in.<span class="me1">readByte</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Заметьте, что метод <i><b>available()</b></i> работает по-разному в 
зависимости от источника данных; дословно его функция описывается 
следующим образом: «количество байтов, которые можно прочитать без 
блокировки». При чтении из файла это означает весь файл, но для другого 
рода потоков это не обязательно верно, поэтому используйте этот метод 
разумно.
</p><p>Определить конец входного потока можно и с помощью перехвата 
исключения. Впрочем, применение исключений в таких целях считается 
злоупотреблением.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.92.D1.8B.D0.B2.D0.BE.D0.B4_.D0.B2_.D1.84.D0.B0.D0.B9.D0.BB">Вывод в файл</span></h3>
<p>Объект <i><b>FileWriter</b></i> записывает данные в файл. При 
вводе/выводе практически всегда применяется буферизация (попробуйте 
прочитать файл без нее, и вы увидите, насколько ее отсутствие влияет на 
производительность — скорость чтения уменьшится в несколько раз), 
поэтому мы присоединяем надстройку <i><b>BufferedWriter</b></i>. После этого подключается <i><b>PrintWriter</b></i>,
 чтобы выполнять форматированный вывод. Файл данных, созданный такой 
конфигурацией ввода/вывода, можно прочитать как обычный текстовый файл.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/BasicFileOutput.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BasicFileOutput <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw21">String</span> file = <span class="st0">"BasicFileOutput.out"</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">BufferedReader</span> in = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">StringReader</span><span class="br0">(</span>
        BufferedInputFile.<span class="me1">read</span><span class="br0">(</span><span class="st0">"BasicFileOutput.java"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">PrintWriter</span> out = <span class="kw2">new</span> <span class="kw20">PrintWriter</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">BufferedWriter</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">FileWriter</span><span class="br0">(</span>file<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> lineCount = <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = in.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span> <span class="br0">)</span>
      out.<span class="me1">println</span><span class="br0">(</span>lineCount++ + <span class="st0">": "</span> + s<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Вывод содержимого файла</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>BufferedInputFile.<span class="me1">read</span><span class="br0">(</span>file<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>При записи строк в файл к ним добавляются их номера. Заметьте, что 
надстройка LineNumberInputStream для этого не применяется, поскольку 
этот класс тривиален, да и вообще не нужен. Как и показано в 
рассматриваемом примере, своя собственная нумерация ничуть не сложнее.
</p><p>Когда данные входного потока исчерпываются, метод <i><b>readLine()</b></i> возвращает <i><b>null</b></i>. Для потока <i><b>out</b></i> явно вызывается метод <i><b>close()</b></i>; если не вызвать его для всех выходных файловых потоков, в буферах могут остаться данные, и файл получится неполным.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.BE.D0.BA.D1.80.D0.B0.D1.89.D0.B5.D0.BD.D0.BD.D0.B0.D1.8F_.D1.84.D0.BE.D1.80.D0.BC.D0.B0_.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0">Сокращенная форма вывода текстового файла</span></h3>
<p>В <i>Java</i> <i>SE5</i> у <i><b>PrintWriter</b></i> появился 
вспомогательный конструктор. Благодаря ему вам не придется вручную 
выполнять всю работу каждый раз, когда вам потребуется создать текстовый
 файл и записать в него данные. Вот как выглядит пример <i><b>BasicFileOutput.java</b></i> в обновленном виде:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/FileOutputShortcut.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> FileOutputShortcut <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw21">String</span> file = <span class="st0">"FileOutputShortcut.out"</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">BufferedReader</span> in = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">StringReader</span><span class="br0">(</span>
       BufferedInputFile.<span class="me1">read</span><span class="br0">(</span><span class="st0">"FileOutputShortcut.java"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Сокращенная запись:</span>
    <span class="kw20">PrintWriter</span> out = <span class="kw2">new</span> <span class="kw20">PrintWriter</span><span class="br0">(</span>file<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> lineCount = <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = in.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span> <span class="br0">)</span>
      out.<span class="me1">println</span><span class="br0">(</span>lineCount++ + <span class="st0">": "</span> + s<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Вывод содержимого файла:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>BufferedInputFile.<span class="me1">read</span><span class="br0">(</span>file<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Буферизация по-прежнему обеспечена, но вам не приходится включать ее 
самостоятельно. К сожалению, для других распространенных операций 
сокращенной записи не предусмотрено, поэтому типичный код ввода/вывода 
по-прежнему содержит немало избыточного текста.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.BE.D1.85.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8_.D0.B2.D0.BE.D1.81.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Сохранение и восстановление данных</span></h3>
<p><i><b>PrintWriter</b></i> форматирует данные так, чтобы их мог 
прочитать человек. Однако для вывода информации, предназначенной для 
другого потока, следует использовать классы <i><b>DataOutputStream</b></i> (для записи данных) и <i><b>DataInputStream</b></i>
 (для чтения данных). Конечно, природа этих потоков может быть любой, но
 в нашем случае открывается файл, буферизованный как для чтения, так и 
для записи. Надстройки <i><b>DataOutputStream</b></i> и <i><b>DataInputStream</b></i> ориентированы на посылку байтов, поэтому для них требуются потоки <i><b>OutputStream</b></i> и <i><b>InputStream</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/StoringAndRecoveringData.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> StoringAndRecoveringData <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw166">DataOutputStream</span> out = <span class="kw2">new</span> <span class="kw166">DataOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">BufferedOutputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"Data.txt"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeDouble</span><span class="br0">(</span><span class="nu0">3.14159</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeUTF</span><span class="br0">(</span><span class="st0">"That was pi"</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeDouble</span><span class="br0">(</span><span class="nu0">1.41413</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeUTF</span><span class="br0">(</span><span class="st0">"Square root of 2"</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">DataInputStream</span> in = <span class="kw2">new</span> <span class="kw166">DataInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">BufferedInputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"Data.txt"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>in.<span class="me1">readDouble</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Только readUTF() нормально читает </span>
    <span class="co1">// строки в кодировке UTF для Java:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>in.<span class="me1">readUTF</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>in.<span class="me1">readDouble</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>in.<span class="me1">readUTF</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>3.14159
That was pi
1.41413
Square root of 2
</pre>
<p>&lt;/spoiler&gt;
Если данные записываются в выходной поток <i><b>DataOutputStream</b></i>, язык <i>Java</i> гарантирует, что эти данные в точно таком же виде будут восстановлены входным потоком <i><b>DataInputStream</b></i>
 — невзирая на платформу, на которой производится запись или чтение. Это
 чрезвычайно ценно, и это знает любой, так или иначе соприкасавшийся с 
вопросами переносимости программ. Если <i>Java</i> поддерживается на обеих платформах, проблема исчезает сама собой.
</p><p>Единственным надежным способом записать в поток <i><b>DataOutputStream</b></i> строку (<i><b>String</b></i>) так, чтобы ее можно было потом правильно считать потоком <i><b>DataInputStream</b></i>, является кодирование <i>UTF-8</i>, реализуемое методами <i><b>readUTF()</b></i> и <i><b>writeUTF()</b></i>. <i>UTF-8</i>
 — это разновидность кодировки Юникод, в которой каждый символ хранится в
 двух байтах. Если вы работаете только с кодировкой ASCII, «удвоение» 
данных в Юникоде приводит к неоправданным затратам дискового 
пространства и (или) нагрузке на сеть. Поэтому <i>UTF-8</i> кодирует 
символы ASCII одним байтом, а символы из других кодировок записывает 
двумя или тремя байтами. Вдобавок в первых двух байтах строки хранится 
ее длина. Впрочем, методы <i><b>readUTF()</b></i> и <i><b>writeUTF()</b></i> используют специальную модификацию <i>UTF-8</i> для <i>Java</i> (она описана в документации <i>JDK</i>), и для правильного считывания из другой программы (не на <i>Java</i>) строки, записанной методом <i><b>writeUTF()</b></i>, вам придется добавить в нее специальный код, позволяющий верно ее считать.
</p><p>Методы <i><b>readUTF()</b></i> и <i><b>writeUTF()</b></i> позволяют смешивать строки и другие типы данных, записываемые потоком <i><b>DataOutputStream</b></i>, так как вы знаете, что строки будут правильно сохранены в Юникоде и их будет просто воспроизвести потоком <i><b>DataInputStream</b></i>.
</p><p>Метод <i><b>writeDouble()</b></i> записывает число <i><b>double</b></i> в поток, а соответствующий ему метод <i><b>readDouble()</b></i>
 затем восстанавливает его (для других типов также существуют подобные 
методы). Но, чтобы правильно интерпретировать любые данные, вы должны 
точно знать их расположение в потоке; при наличии такой информации 
прочитать число <i><b>double</b></i> как какую-то последовательность 
байтов или символов не представляет сложности. Поэтому данные в файле 
должны иметь определенный формат, или вам придется использовать 
дополнительную информацию, показывающую, какие именно данные находятся в
 определенных местах. Заметьте, что сериализация объектов (описанная в 
этой главе чуть позже) часто предоставляет простейший способ записи и 
восстановления сложных структур данных.
</p>
<h3><span class="mw-headline" id=".D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5.2F.D0.B7.D0.B0.D0.BF.D0.B8.D1.81.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2_.D1.81_.D0.BF.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.BB.D1.8C.D0.BD.D1.8B.D0.BC_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D0.BE.D0.BC">Чтение/запись файлов с произвольным доступом</span></h3>
<p>Как уже было замечено, работа с классом <i><b>RandomAccessFile</b></i> напоминает использование совмещенных в одном классе потоков <i><b>DataInputStream</b></i> и <i><b>DataOutputStream</b></i> (они реализуют те же интерфейсы <i><b>DataInput</b></i> и <i><b>DataOutput</b></i>). Кроме того, метод <i><b>seek()</b></i> позволяет переместиться к определенной позиции и изменить хранящееся там значение.
</p><p>При использовании <i><b>RandomAccessFile</b></i> необходимо знать структуру файла, чтобы правильно работать с ним. Класс <i><b>RandomAccessFile</b></i> содержит методы для чтения и записи примитивов и строк <i>UTF-8</i>. Пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/UsingRandomAccessFile.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UsingRandomAccessFile <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw21">String</span> file = <span class="st0">"rtest.dat"</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">void</span> display<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">RandomAccessFile</span> rf = <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span>file, <span class="st0">"r"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">7</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>
        <span class="st0">"Value "</span> + i + <span class="st0">": "</span> + rf.<span class="me1">readDouble</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>rf.<span class="me1">readUTF</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">RandomAccessFile</span> rf = <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span>file, <span class="st0">"rw"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">7</span><span class="sy0">;</span> i++<span class="br0">)</span>
      rf.<span class="me1">writeDouble</span><span class="br0">(</span>i<span class="sy0">*</span><span class="nu0">1.414</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">writeUTF</span><span class="br0">(</span><span class="st0">"The end of the file"</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    display<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    rf = <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span>file, <span class="st0">"rw"</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">seek</span><span class="br0">(</span><span class="nu0">5</span><span class="sy0">*</span><span class="nu0">8</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">writeDouble</span><span class="br0">(</span><span class="nu0">47.0001</span><span class="br0">)</span><span class="sy0">;</span>
    rf.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    display<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Value 0: 0.0
Value 1: 1.414
Value 2: 2.828
Value 3: 4.242
Value 4: 5.656
Value 5: 7.069999999999999
Value 6: 8.484
The end of the file
Value 0: 0.0
Value 1: 1.414
Value 2: 2.828
Value 3: 4.242
Value 4: 5.656
Value 5: 47.0001
Value 6: 8.484
The end of the file
</pre>
<p>&lt;/spoiler&gt;
Метод <i><b>display()</b></i> открывает файл и выводит семь значений в формате <i><b>double</b></i>. Метод <i><b>main()</b></i> создает файл, открывает и модифицирует его. Поскольку значение <i><b>double</b></i> всегда занимает <i>8</i> байт, для перехода к пятому числу методу <i><b>seek()</b></i> следует передать смещение <i>5*8</i>.
Как упоминалось ранее, класс <i><b>RandomAccessFile</b></i> отделен от остальных классов иерархии ввода/вывода, если не считать того факта, что он реализует интерфейсы <i><b>DataInput</b></i> и <i><b>DataOutput</b></i>. Приходится предполагать, что для этого <i><b>RandomAccessFile</b></i> правильно организована буферизация, потому что включить ее в программе не удастся.
Некоторая свобода выбора предоставляется только со вторым аргументом конструктора: <i><b>RandomAccessFile</b></i> может открываться в режиме чтения ("<i><b>r</b></i>") или чтения/записи ("<i><b>rw</b></i>").
Также стоит рассмотреть возможность употребления вместо класса <i><b>RandomAccessFile</b></i> механизма отображаемых в память файлов.
</p>
<h3><span class="mw-headline" id=".D0.9A.D0.B0.D0.BD.D0.B0.D0.BB.D1.8B">Каналы</span></h3>
<p>В этой главе были коротко упомянуты классы каналов <i><b>PipedInputStream, PipedOutputStream, PipedReader</b></i> и <i><b>PipedWriter</b></i>.
 Это не значит, что они редко используются или не слишком полезны, 
просто их смысл и действие нельзя донести до по­нимания до тех пор, пока
 не объяснена многозадачность: каналы предназначены для связи между 
отдельными потоками программы. Они будут описаны позднее.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A1.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B2.D0.B0_.D1.87.D1.82.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B8_.D0.B7.D0.B0.D0.BF.D0.B8.D1.81.D0.B8_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2">Средства чтения и записи файлов</span></h2>
<p>Очень часто в программировании производится такая цепочка действий: 
файл считывается в память, там он изменяется, а потом снова записывается
 на диск. Одна из проблем при работе с библиотекой ввода/вывода <i>Java</i>
 состоит в том, что для выполнения таких достаточно типичных операций 
вам придется написать некоторое количество кода — не существует 
вспомогательных функций, на которые можно переложить такую деятельность.
 Что еще хуже, с надстройками вообще трудно запомнить, как открываются 
файлы. Поэтому имеет смысл добавить в вашу библиотеку вспомогательные 
классы, которые легко сделают нужное за вас. В <i>Java</i> <i>SE5</i> у <i><b>PrintWriter</b></i>
 появился вспомогательный конструктор, позволяющий легко открыть 
текстовый файл для чтения. Тем не менее существует много других типичных
 задач, часто выполняемых в повседневной работе, и было бы разумно 
избавиться от лишнего кода, связанного с их выполнением. Ниже показан 
такой класс <i><b>TextFile</b></i> с набором статических методов, построчно считывающих и записывающих текстовые файлы. Вдобавок можно создать экземпляр класса <i><b>TextFile</b></i>, который будет хранить содержимое файла в списке <i><b>ArrayList</b></i> (и функциональность списка <i><b>ArrayList</b></i> станет доступной при работе, с содержимым файла):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/TextFile.java</span>
<span class="co1">// Статические функции для построчного считывания и записи</span>
<span class="co1">// текстовых файлов,- а также манипуляции файлом как списком ArrayList</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TextFile <span class="kw2">extends</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="co1">// Read a file as a single string:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw21">String</span> read<span class="br0">(</span><span class="kw21">String</span> fileName<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">StringBuilder</span> sb = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw20">BufferedReader</span> in= <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">FileReader</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>fileName<span class="br0">)</span>.<span class="me1">getAbsoluteFile</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="kw21">String</span> s<span class="sy0">;</span>
        <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = in.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span> <span class="br0">{</span>
          sb.<span class="me1">append</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
          sb.<span class="me1">append</span><span class="br0">(</span><span class="st0">"<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
      <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
        in.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">return</span> sb.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Write a single file in one method call:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> write<span class="br0">(</span><span class="kw21">String</span> fileName, <span class="kw21">String</span> text<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw20">PrintWriter</span> out = <span class="kw2">new</span> <span class="kw20">PrintWriter</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>fileName<span class="br0">)</span>.<span class="me1">getAbsoluteFile</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        out.<span class="me1">print</span><span class="br0">(</span>text<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
        out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// Read a file, split by any regular expression:</span>
  <span class="kw2">public</span> TextFile<span class="br0">(</span><span class="kw21">String</span> fileName, <span class="kw21">String</span> splitter<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">asList</span><span class="br0">(</span>read<span class="br0">(</span>fileName<span class="br0">)</span>.<span class="me1">split</span><span class="br0">(</span>splitter<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Regular expression split() often leaves an empty</span>
    <span class="co1">// String at the first position:</span>
    <span class="kw1">if</span><span class="br0">(</span>get<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span>.<span class="me1">equals</span><span class="br0">(</span><span class="st0">""</span><span class="br0">)</span><span class="br0">)</span> remove<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Normally read by lines:</span>
  <span class="kw2">public</span> TextFile<span class="br0">(</span><span class="kw21">String</span> fileName<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span><span class="br0">(</span>fileName, <span class="st0">"<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> write<span class="br0">(</span><span class="kw21">String</span> fileName<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw20">PrintWriter</span> out = <span class="kw2">new</span> <span class="kw20">PrintWriter</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span>fileName<span class="br0">)</span>.<span class="me1">getAbsoluteFile</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> item&nbsp;: <span class="kw2">this</span><span class="br0">)</span>
          out.<span class="me1">println</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
        out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// Simple test:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">String</span> file = read<span class="br0">(</span><span class="st0">"TextFile.java"</span><span class="br0">)</span><span class="sy0">;</span>
    write<span class="br0">(</span><span class="st0">"test.txt"</span>, file<span class="br0">)</span><span class="sy0">;</span>
    TextFile text = <span class="kw2">new</span> TextFile<span class="br0">(</span><span class="st0">"test.txt"</span><span class="br0">)</span><span class="sy0">;</span>
    text.<span class="me1">write</span><span class="br0">(</span><span class="st0">"test2.txt"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Break into unique sorted list of words:</span>
    <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> words = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span>
      <span class="kw2">new</span> TextFile<span class="br0">(</span><span class="st0">"TextFile.java"</span>, <span class="st0">"<span class="es0">\\</span>W+"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Display the capitalized words:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>words.<span class="me1">headSet</span><span class="br0">(</span><span class="st0">"a"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[0, ArrayList, Arrays, Break, BufferedReader, BufferedWriter, Clean, 
Display, File, FileReader, FileWriter, IOException, Normally, Output,
PrintWriter, Read, Regular, RuntimeException, Simple, Static, String,
StringBuilder, System, TextFile, Tools, TreeSet, W, Write]
</pre>
<p>&lt;/spoiler&gt;
Метод <i><b>read()</b></i> присоединяет каждую строку к <i><b>StringBuilder</b></i>, а за ней присоединяется перевод строки, удаленный при чтении. Затем возвращается объект <i><b>String</b></i>, содержащий весь файл. Метод <i><b>write()</b></i> открывает файл и записывает в него текст.
Обратите внимание: к каждой операции открытия файла добавляется парный вызов <i><b>close()</b></i> в секции <i><b>finally</b></i>. Тем самым обеспечивается гарантированное закрытие файла после завершения работы.
Конструктор использует метод <i><b>read()</b></i> для превращения файла в <i><b>String</b></i>, после чего он вызывает метод <i><b>String.split(</b></i>),
 чтобы разбить результат на строки. В качестве разделителя используются 
символы новой строки (если вы будете часто использовать этот класс, то, 
возможно, захотите переписать этот конструктор, чтобы он работал 
эффективнее). К сожалению, аналогичного метода для соединения строк нет,
 так что для записи строк придется обойтись нестатическим методом <i><b>write()</b></i>.
Так как класс должен упростить процесс чтения и записи файлов, все исключения <i><b>IOException</b></i> преобразуются в <i><b>RuntimeException</b></i>, чтобы пользователю не пришлось создавать блоки <i><b>try/catch</b></i>. Возможно, вы предпочтете создать другую версию, которая возвращает <i><b>IOException</b></i> вызывающей стороне.
</p><p>В методе <i><b>main()</b></i> выполняется небольшой тест, 
позволяющий удостовериться в правильной работе методов. Несмотря на то 
что кода в этом классе немного, его применение позволит сэкономить вам 
уйму времени и сделать вашу жизнь проще, в чем вы еще будете иметь 
возможность убедиться чуть позже.
</p>
<h2><span class="mw-headline" id=".D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.D0.B2.D0.B2.D0.BE.D0.B4.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4">Стандартный ввод/вывод</span></h2>
<p>Термин «стандартный ввод/вывод» возник еще в эпоху UNIX (и в 
некоторой форме имеется и в Windows, и во многих других операционных 
системах). Он означает единственный поток информации, используемый 
программой. Вся информация программы приходит из стандартного ввода (<i>standard input</i>), все данные записываются в стандартный вывод (<i>standard output</i>), а все ошибки программы передаются в стандартный поток для ошибок (<i>standard error</i>).
 Значение стандартного ввода/вывода состоит в том, что программы легко 
соединять в цепочку, где стандартный вывод одной программы становится 
стандартным вводом другой программы. Это мощный инструмент.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A7.D1.82.D0.B5.D0.BD.D0.B8.D0.B5_.D0.B8.D0.B7_.D1.81.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D0.BF.D0.BE.D1.82.D0.BE.D0.BA.D0.B0_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0">Чтение из стандартного потока ввода</span></h3>
<p>Следуя модели стандартного ввода/вывода, <i>Java</i> определяет необходимые потоки для стандартного ввода, вывода и ошибок: <i><b>System.in, System.out</b></i> и <i><b>System.err</b></i>. На многих страницах книги вы не раз могли наблюдать процесс записи в стандартный вывод <i><b>System.out</b></i>, для которого уже надстроен класс форматирования данных <i><b>PrintStream</b></i>. Поток для ошибок <i><b>System.err</b></i> схож со стандартным выводом, а стандартный ввод <i><b>System.in</b></i> представляет собой «низкоуровневый» поток <i><b>InputStream</b></i> без дополнительных надстроек. Это значит, что потоки <i><b>System.out</b></i> и <i><b>System.err</b></i> можно использовать напрямую, в то время как стандартный ввод <i><b>System.in</b></i> желательно надстраивать.
</p><p>Обычно чтение осуществляется построчно, методом <i><b>readLine()</b></i>, поэтому имеет смысл буферизовать стандартный ввод <i><b>System.in</b></i> посредством <i><b>BufferedReader</b></i>. Чтобы сделать это, предварительно следует конвертировать поток <i><b>System.in</b></i> в считывающее устройство <i><b>Reader</b></i> посредством класса-преобразователя <i><b>InputStreamReader</b></i>. Следующий пример просто отображает на экране последнюю строку, введенную пользователем (эхо-вывод):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Echo.java</span>
/ Чтение из стандартного ввода.
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Echo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">BufferedReader</span> stdin = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">InputStreamReader</span><span class="br0">(</span><span class="kw21">System</span>.<span class="me1">in</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = stdin.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span> <span class="sy0">&amp;&amp;</span> s.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// An empty line or Ctrl-Z terminates the program</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Присутствие спецификации исключений объясняется тем, что метод <i><b>readLine()</b></i> может возбуждать исключение <i><b>IOException</b></i>. Снова обратите внимание, что поток <i><b>System.in</b></i> обычно буферизуется, впрочем, как и большинство потоков.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.97.D0.B0.D0.BC.D0.B5.D0.BD.D0.B0_System.out_.D0.BD.D0.B0_PrintWriter">Замена System.out на PrintWriter</span></h3>
<p>Стандартный вывод <i><b>System.out</b></i> является объектом <i><b>PrintStream</b></i>, который, в свою очередь, наследует от базового класса <i><b>OutputStream</b></i>. В классе <i><b>PrintWriter</b></i> имеется конструктор, который принимает в качестве аргумента выходной поток <i><b>OutputStream</b></i>. Таким образом, вы можете преобразовать поток стандартного вывода <i><b>System.out</b></i> в символьно-ориентированный поток <i><b>PrintWriter</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/ChangeSystemOut.java</span>
<span class="co1">// Преобразование System out в символьный поток PrintWriter.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ChangeSystemOut <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw20">PrintWriter</span> out = <span class="kw2">new</span> <span class="kw20">PrintWriter</span><span class="br0">(</span><span class="kw21">System</span>.<span class="me1">out</span>, <span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Hello, world"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Hello, world
</pre>
<p>&lt;/spoiler&gt;
Важно использовать конструктор класса <i><b>PrintWriter</b></i> с двумя аргументами, и передать во втором аргументе <i><b>true</b></i>, чтобы обеспечить автоматический сброс буфера на печать, иначе можно вовсе не увидеть никакого вывода.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BD.D0.B0.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B2.D0.B2.D0.BE.D0.B4.D0.B0.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4.D0.B0">Перенаправление стандартного ввода/вывода</span></h3>
<p>Класс <i><b>System</b></i> позволяет вам перенаправить стандартный ввод, вывод и поток ошибок. Для этого предусмотрены простые статические методы: <i><b>setIn(InputStream)</b></i>; <i><b>setOut(PrintStream)</b></i>; <i><b>setErr(PrintStream)</b></i>.
Перенаправление стандартного вывода особенно полезно тогда, когда ваша 
программа выдает слишком много сообщений сразу и вы попросту не 
успеваете читать их, поскольку они заменяются новыми сообщениями. 
Перенаправление ввода удобно для программ, работающих с командной 
строкой, в которых необходимо поддержать некоторую последовательность 
введенных пользователем данных. Вот простой пример, показывающий, как 
использовать эти методы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Redirecting.java</span>
<span class="co1">// Перенаправление стандартного ввода/вывода.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Redirecting <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">PrintStream</span> console = <span class="kw21">System</span>.<span class="me1">out</span><span class="sy0">;</span>
    <span class="kw20">BufferedInputStream</span> in = <span class="kw2">new</span> <span class="kw20">BufferedInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"Redirecting.java"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">PrintStream</span> out = <span class="kw2">new</span> <span class="kw20">PrintStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">BufferedOutputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"test.out"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">setIn</span><span class="br0">(</span>in<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">setOut</span><span class="br0">(</span>out<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">setErr</span><span class="br0">(</span>out<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">BufferedReader</span> br = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">InputStreamReader</span><span class="br0">(</span><span class="kw21">System</span>.<span class="me1">in</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = br.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Remember this!</span>
    <span class="kw21">System</span>.<span class="me1">setOut</span><span class="br0">(</span>console<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Программа присоединяет стандартный ввод к файлу и перенаправляет, 
стандартный ввод и поток для ошибок в другие файлы. Обратите внимание на
 сохранение ссылки на исходный объект <i><b>System.out</b></i> в начале 
программы и его восстановление в конце. Перенаправление основано на 
байтовом, а не на символьном вводе/выводе, поэтому в примере 
используются <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>, а не их символьно-ориентированные эквиваленты <i><b>Reader</b></i> и <i><b>Writer</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9D.D0.BE.D0.B2.D1.8B.D0.B9_.D0.B2.D0.B2.D0.BE.D0.B4.2F.D0.B2.D1.8B.D0.B2.D0.BE.D0.B4_.28nio.29">Новый ввод/вывод (nio)</span></h2>
<p>При создании библиотеки «нового ввода/вывода» <i>Java</i>, появившейся в <i>JDK</i>-1.4 в пакетах <i><b>java.nio.*</b></i>, ставилась единственная цель: скорость. Более того, «старые» пакеты ввода/вывода были переписаны с учетом достижений <i><b>nio</b></i>,
 с намерением использовать преимущества повышенного быстродействия, 
поэтому улучшения вы получите, даже если не будете писать явный <i><b>nіо</b></i>-код.
 Подъем производительности просматривается как в файловом вводе/выводе, 
который мы здесь рассматриваем, так и в сетевом вводе/выводе.
</p><p>Увеличения скорости удалось достичь с помощью структур, близких к средствам самой операционной системы: каналов[30] (<i>channels</i>) и буферов (<i>buffers</i>).
 Канал можно сравнить с угольной шахтой, вырытой на угольном пласте 
(данные), а буфер — с вагонеткой, которую вы посылаете в шахту. Тележка 
возвращается доверху наполненная углем, который вы из нее выгружаете. 
Таким образом, прямого взаимодействия с каналом у вас нет, вы работаете с
 буфером и «посылаете» его в канал. Канал либо извлекает данные из 
буфера, либо помещает их в него.
</p><p>Напрямую взаимодействует с каналом только буфер <i><b>ByteBuffer</b></i>, то есть буфер, хранящий простые байты. Если вы просмотрите документацию <i>JDK</i> для класса <i><b>java.nio.ByteBuffer</b></i>,
 то увидите что он достаточно прост: вы создаете его, указывая, сколько 
места надо выделить под данные. Класс содержит набор методов для 
получения и помещения данных в виде последовательности байтов или в виде
 примитивов. Однако возможности записать в него объект или даже простую 
строку нет. Буфер работает на достаточно низком уровне, поскольку 
обеспечивается более эффективная совместимость с большинством 
операционных систем.
</p><p>Три класса из «старой» библиотеки ввода/вывода были изменены так, чтобы они позволяли получить канал <i><b>FileChannel</b></i>: это <i><b>FileInputStream</b></i>, <i><b>FileOutputStream</b></i> и <i><b>RandomAccessFile</b></i>. Заметьте, что эти классы манипулируют байтами, что согласуется с низкоуровневой направленностью <i><b>nio</b></i>. Классы для символьных данных <i><b>Reader</b></i> и <i><b>Writer</b></i> не образуют каналов, однако вспомогательный класс <i><b>java.nio.channels.Channels</b></i> имеет набор методов, позволяющих получить объекты <i><b>Reader</b></i> и <i><b>Writer</b></i> для каналов.
</p><p>Простой пример использования всех трех типов потоков. Создаваемые каналы поддерживают запись, чтение/запись и только чтение:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/GetChannel.java</span>
<span class="co1">// Получение каналов из потоков</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GetChannel <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> BSIZE = <span class="nu0">1024</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="co1">// Write a file:</span>
    <span class="kw30">FileChannel</span> fc =
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"data.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">write</span><span class="br0">(</span><span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span><span class="st0">"Some text "</span>.<span class="me1">getBytes</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Add to the end of the file:</span>
    fc =
      <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span><span class="st0">"data.txt"</span>, <span class="st0">"rw"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">position</span><span class="br0">(</span>fc.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Move to the end</span>
    fc.<span class="me1">write</span><span class="br0">(</span><span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span><span class="st0">"Some more"</span>.<span class="me1">getBytes</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Read the file:</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"data.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">ByteBuffer</span> buff = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>BSIZE<span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">read</span><span class="br0">(</span>buff<span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>buff.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>buff.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Some text Some more
</pre>
<p>&lt;/spoiler&gt;
Для любого из рассмотренных выше классов потоков метод <i><b>getChannel()</b></i> выдает канал <i><b>FileChannel</b></i>. Канал довольно прост: ему передается байтовый буфер <i><b>ByteBuffer</b></i>
 для чтения и записи, и вы можете заблокировать некоторые участки файла 
для монопольного доступа (этот процесс будет описан чуть позже).
</p><p>Для помещения байтов в буфер <i><b>ByteBuffer</b></i> используется один из нескольких методов для записи данных (<i>put</i>);
 данные записываются в виде одного или нескольких байтов или значений 
примитивов. Впрочем, как было показано в примере, можно «заворачивать» 
уже существующий байтовый массив в буфер <i><b>ByteBuffer</b></i>, используя метод <i><b>wrap()</b></i>. Когда вы так делаете, байтовый массив не копируется, а используется как хранилище для полученного буфера <i><b>ByteBuffer</b></i>. В таких случаях говорят, что буфер <i><b>ByteBuffer</b></i> создается на базе массива.
</p><p>Файл <i><b>data.txt</b></i> заново открывается с помощью класса <i><b>RandomAccessFile</b></i>. Заметьте, что канал <i><b>FileChannel</b></i>
 может перемещаться внутри файла; в нашем примере он сдвигается в конец 
файла так, чтобы дополнительные записи присоединялись за существующим 
содержимым.
</p><p>Чтобы доступ к файлу ограничивался только чтением, следует явно получить байтовый буфер <i><b>ByteBuffer</b></i> статическим методом <i><b>allocate()</b></i>. Предназначение <i><b>nio</b></i>
 — быстрое перемещение большого количества данных, поэтому размер буфера
 имеет значение: на самом деле установленный в примере размер в 1 
килобайт меньше, чем обычно требуется (поэкспериментируйте с работающим 
приложением, чтобы найти оптимальное решение).
</p><p>Можно получить еще большее быстродействие, используя вместо метода <i><b>allocate()</b></i> метод <i><b>allocateDirect()</b></i>.
 Он производит буфер «прямого доступа», еще теснее привязанный к 
низкоуровневой работе операционной системы. Однако такой буфер требует 
больше ресурсов, а реализация его различается в различных операционных 
системах. Опять же, поэкспериментируйте со своим приложением и выясните,
 дадут ли буферы прямого доступа лучшую производительность.
</p><p>После вызова метода <i><b>read()</b></i> буфера <i><b>FileChannel</b></i> для сохранения байтов в буфере <i><b>ByteBuffer</b></i> также необходимо вызвать для буфера метод <i><b>flip()</b></i>,
 позволяющий впоследствии извлечь из буфера его данные (да, все это 
выглядит немного неудобно, но помните, что расчет делался на высокое 
быстродействие, поэтому все делается на низком уровне). И если затем нам
 снова понадобится буфер для чтения, придется вызывать перед каждым 
методом <i><b>read()</b></i> метод <i><b>clear()</b></i>. В этом нетрудно убедиться на примере простой программы копирования файлов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/ChannelCopy.java</span>
<span class="co1">// Копирование файла с использованием каналов и буферов</span>
<span class="co1">// {Параметры Channel Copy java test txt}</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ChannelCopy <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> BSIZE = <span class="nu0">1024</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">!</span>= <span class="nu0">2</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"arguments: sourcefile destfile"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw30">FileChannel</span>
      in = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span>,
      out = <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">ByteBuffer</span> buffer = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>BSIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>in.<span class="me1">read</span><span class="br0">(</span>buffer<span class="br0">)</span> <span class="sy0">!</span>= -<span class="nu0">1</span><span class="br0">)</span> <span class="br0">{</span>
      buffer.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Prepare for writing</span>
      out.<span class="me1">write</span><span class="br0">(</span>buffer<span class="br0">)</span><span class="sy0">;</span>
      buffer.<span class="me1">clear</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// Prepare for reading</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>В программе создаются два канала <i><b>FileChannel</b></i>: для чтения и для записи. Выделяется буфер <i><b>ByteBuffer</b></i>, а когда метод <i><b>FileChannel.read()</b></i> возвращает <i>-1</i>, это значит, что мы достигли конца входных данных (без сомнения, пережиток UNIX и С). После каждого вызова метода <i><b>read()</b></i>, помещающего данные в буфер, метод <i><b>flip()</b></i> подготавливает буфер так, чтобы информация из него могла быть извлечена методом <i><b>write()</b></i>. После вызова <i><b>write()</b></i> информация все еще хранится в буфере, поэтому метод <i><b>clear()</b></i> перемещает все его внутренние указатели, чтобы буфер снова был способен принимать данные в методе <i><b>read(</b></i>). Впрочем, рассмотренная программа не лучшим образом выполняет копирование файлов. Специальные методы, <i><b>transferTo()</b></i> и <i><b>transferFrom()</b></i>, позволяют напрямую присоединить один канал к другому:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/TransferTo.java</span>
<span class="co1">// Использование метода transferToO для соединения каналов </span>
<span class="co1">// {Параметры TransferTo java TransferTo txt} </span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TransferTo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> <span class="sy0">!</span>= <span class="nu0">2</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"arguments: sourcefile destfile"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw30">FileChannel</span>
      in = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span>,
      out = <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    in.<span class="me1">transferTo</span><span class="br0">(</span><span class="nu0">0</span>, in.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span>, out<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Or:</span>
    <span class="co1">// out.transferFrom(in, 0, in.size());</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Часто такую операцию выполнять вам не придется, но знать о ней полезно.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Преобразование данных</span></h3>
<p>Если вы вспомните программу <i><b>GetChannel.java</b></i>, то 
увидите, что для вывода информации из файла нам приходилось считывать из
 буфера по одному байту и преобразовывать его от типа <i><b>byte</b></i> к типу <i><b>char</b></i>. Такой подход явно примитивен — если вы посмотрите на класс <i><b>java.nio.CharBuffer</b></i>, то увидите, что в нем есть метод <i><b>toString()</b></i>, который возвращает строку из символов, находящихся в данном буфере. Байтовый буфер <i><b>ByteBuffer</b></i> можно рассматривать как символьный буфер <i><b>CharBuffer</b></i>, как это делается в методе <i><b>asCharBuffer()</b></i>, почему бы так и не поступить? Как вы увидите уже из первого предложения <i><b>expect()</b></i>, это не сработает:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/BufferToText.java</span>
<span class="co1">// Получение текста из буфера ByteBuffers и обратно</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.charset.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BufferToText <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> BSIZE = <span class="nu0">1024</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw30">FileChannel</span> fc =
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">write</span><span class="br0">(</span><span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span><span class="st0">"Some text"</span>.<span class="me1">getBytes</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">ByteBuffer</span> buff = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>BSIZE<span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">read</span><span class="br0">(</span>buff<span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Doesn't work:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>buff.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Decode using this system's default Charset:</span>
    buff.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> encoding = <span class="kw21">System</span>.<span class="me1">getProperty</span><span class="br0">(</span><span class="st0">"file.encoding"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Decoded using "</span> + encoding + <span class="st0">": "</span>
      + <span class="kw32">Charset</span>.<span class="me1">forName</span><span class="br0">(</span>encoding<span class="br0">)</span>.<span class="me1">decode</span><span class="br0">(</span>buff<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Or, we could encode with something that will print:</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">write</span><span class="br0">(</span><span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span>
      <span class="st0">"Some text"</span>.<span class="me1">getBytes</span><span class="br0">(</span><span class="st0">"UTF-16BE"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now try reading again:</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">clear</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">read</span><span class="br0">(</span>buff<span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>buff.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Use a CharBuffer to write through:</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    buff = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span><span class="nu0">24</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// More than needed</span>
    buff.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="st0">"Some text"</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">write</span><span class="br0">(</span>buff<span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Read and display:</span>
    fc = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"data2.txt"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">clear</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    fc.<span class="me1">read</span><span class="br0">(</span>buff<span class="br0">)</span><span class="sy0">;</span>
    buff.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>buff.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>????
Decoded using Cp1252: Some text
Some text
Some text
</pre>
<p>&lt;/spoiler&gt;
Буфер содержит обычные байты, следовательно, для превращения их в 
символы мы должны либо кодировать их по мере помещения в буфер, либо 
декодировать их при извлечении из буфера. Это можно сделать с помощью 
класса <i><b>java.nio.charset.Charset</b></i>, который предоставляет инструменты для преобразования многих различных типов в наборы символов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/AvailableCharSets.java</span>
<span class="co1">// Перечисление кодировок и их символических имен</span>
<span class="kw2">import</span> <span class="co2">java.nio.charset.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> AvailableCharSets <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">SortedMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw32">Charset</span><span class="sy0">&gt;</span> charSets =
      <span class="kw32">Charset</span>.<span class="me1">availableCharsets</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Iterator</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> it = charSets.<span class="me1">keySet</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">iterator</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>it.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">String</span> csName = it.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      printnb<span class="br0">(</span>csName<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw46">Iterator</span> aliases =
        charSets.<span class="me1">get</span><span class="br0">(</span>csName<span class="br0">)</span>.<span class="me1">aliases</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">iterator</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">if</span><span class="br0">(</span>aliases.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
        printnb<span class="br0">(</span><span class="st0">": "</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span>aliases.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        printnb<span class="br0">(</span>aliases.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">if</span><span class="br0">(</span>aliases.<span class="me1">hasNext</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
          printnb<span class="br0">(</span><span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Big5: csBig5
Big5-HKSCS: big5-hkscs, big5hk, big5-hkscs:unicode3.0, big5hkscs, Big5_HKSCS
EUC-JP: eucjis, x-eucjp, csEUCPkdFmtjapanese, eucjp, 
Extended_UNIX_Code_Packed_Format_for_Japanese,  x-euc-jp, euc_jp
EUC-KR: ksc5601, 5601, ksc5601_1987, ksc_5601, ksc5601-1987, euc_kr, 
ks_c_5601-1987, euckr, csEUCKR
GB18030: gb18030-2000
GB2312: gb2312-1980, gb2312, EUC_CN, gb2312-80, euc-cn, euccn, x-EUC-CN
GBK: windows-936, CP936
</pre>
<p>&lt;/spoiler&gt;
Вернемся к программе <i><b>BufferToText.java</b></i>. Если вы вызовете для буфера метод <i><b>rewind()</b></i> (чтобы вернуться к его началу), а затем используете кодировку по умолчанию в методе <i><b>decode()</b></i>, данные буфера <i><b>CharBuffer</b></i> будут правильно выведены на консоль. Чтобы узнать кодировку по умолчанию вызовите метод <i><b>System.getProperty("fiLe.encoding")</b></i>, который возвращает строку с названием кодировки. Передавая эту строку методу <i><b>Charset.forName()</b></i>, вы получите объект <i><b>Charset</b></i>, с помощью которого и декодируете строку.
</p><p>Другой подход — кодировать данные методом <i><b>encode()</b></i> так, чтобы при чтении файла выводились данные, пригодные для вывода на печать (пример представлен в программе <i><b>BufferToText.java</b></i>). Здесь для записи текста в файл используется кодировка <i>UTF-16BE</i>, и при последующем чтении вам остается лишь преобразовать данные в буфер <i><b>CharBuffer</b></i> и вывести его содержимое. Наконец, мы видим, что происходит, когда вы записываете в буфер <i><b>ByteBuffer</b></i> через <i><b>CharBuffer</b></i>
 (мы узнаем об этом чуть позже). Заметьте, что для байтового буфера 
выделяется 24 байта. На каждый символ (char) отводится два байта, 
соответственно, буфер вместит 12 символов, а у нас в строке Some Text их
 только девять. Оставшиеся нулевые байты все равно отображаются в 
строке, образуемой методом <i><b>toString()</b></i> класса <i><b>CharBuffer</b></i>, что и показывают результаты.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.98.D0.B7.D0.B2.D0.BB.D0.B5.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D1.80.D0.B8.D0.BC.D0.B8.D1.82.D0.B8.D0.B2.D0.BE.D0.B2">Извлечение примитивов</span></h3>
<p>Несмотря на то что в буфере <i><b>ByteBuffer</b></i> хранятся только 
байты, он поддерживает методы для выборки любых значений примитивных 
типов из этих байтов. Следующий пример демонстрирует вставку и выборку 
из буфера разнообразных значений примитивных типов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/GetData.java</span>
<span class="co1">//Получение различных данных из буфера ByteBuffer</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GetData <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> BSIZE = <span class="nu0">1024</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw29">ByteBuffer</span> bb = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>BSIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Allocation automatically zeroes the ByteBuffer:</span>
    <span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>i++ <span class="sy0">&lt;</span> bb.<span class="me1">limit</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw1">if</span><span class="br0">(</span>bb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span>
        print<span class="br0">(</span><span class="st0">"nonzero"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"i = "</span> + i<span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read a char array:</span>
    bb.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="st0">"Howdy!"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">char</span> c<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>c = bb.<span class="me1">getChar</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="nu0">0</span><span class="br0">)</span>
      printnb<span class="br0">(</span>c + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read a short:</span>
    bb.<span class="me1">asShortBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">short</span><span class="br0">)</span><span class="nu0">471142</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>bb.<span class="me1">getShort</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read an int:</span>
    bb.<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="nu0">99471142</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>bb.<span class="me1">getInt</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read a long:</span>
    bb.<span class="me1">asLongBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="nu0">99471142</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>bb.<span class="me1">getLong</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read a float:</span>
    bb.<span class="me1">asFloatBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="nu0">99471142</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>bb.<span class="me1">getFloat</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store and read a double:</span>
    bb.<span class="me1">asDoubleBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="nu0">99471142</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>bb.<span class="me1">getDouble</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>i = 1025
H o w d y&nbsp;!
12390
99471142
99471142
9.9471144E7
9.9471142E7
</pre>
<p>&lt;/spoiler&gt;
После выделения байтового буфера мы убеждаемся в том, что его содержимое
 действительно заполнено нулями. Проверяются все 1024 значения, хранимые
 в буфере (вплоть до последнего, индекс которого (размер буфера) 
возвращается методом <i><b>limit()</b></i>), и все они оказываются нулями.
</p><p>Простейший способ вставить примитив в <i><b>ByteBuffer</b></i> основан на получении подходящего «представления» этого буфера методами <i><b>asCharBuffer()</b></i>, <i><b>asShortBuffer()</b></i>
 и т. п., и последующем занесении в это представление значения методом 
put(). В примере мы так поступаем для каждого из простейших типов. 
Единственным исключением из этого ряда является использование буфера <i><b>ShortBuffer</b></i>,
 требующего приведения типов (которое усекает и изменяет результирующее 
значение). Все остальные представления не нуждаются в преобразовании 
типов.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.B4.D1.81.D1.82.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D1.8F_.D0.B1.D1.83.D1.84.D0.B5.D1.80.D0.BE.D0.B2">Представления буферов</span></h3>
<p>«Представления буферов» дают вам возможность взглянуть на 
соответствующий байтовый буфер «через призму» некоторого примитивного 
типа. Байтовый буфер все так же хранит действительные данные и 
одновременно поддерживает представление, поэтому все изменения, которые 
вы сделаете в представлении, отразятся на содержимом байтового буфера. 
Как было показано в предыдущем' примере, это удобно для вставки значений
 примитивов в байтовый буфер. Представления также позволяют читать 
значения примитивов из буфера, по одному (раз он «байтовый» буфер) или 
пакетами (в массивы). Следующий пример манипулирует целыми числами (<i><b>int</b></i>) в буфере <i><b>ByteBuffer</b></i> с помощью класса <i><b>IntBuffer</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/IntBufferDemo.java</span>
<span class="co1">// Работа с целыми числами в буфере ByteBuffer </span>
<span class="co1">// посредством буфера IntBuffer </span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> IntBufferDemo <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> BSIZE = <span class="nu0">1024</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw29">ByteBuffer</span> bb = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>BSIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">IntBuffer</span> ib = bb.<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Store an array of int:</span>
    ib.<span class="me1">put</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span> <span class="nu0">11</span>, <span class="nu0">42</span>, <span class="nu0">47</span>, <span class="nu0">99</span>, <span class="nu0">143</span>, <span class="nu0">811</span>, <span class="nu0">1016</span> <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Absolute location read and write:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ib.<span class="me1">get</span><span class="br0">(</span><span class="nu0">3</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    ib.<span class="me1">put</span><span class="br0">(</span><span class="nu0">3</span>, <span class="nu0">1811</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Setting a new limit before rewinding the buffer.</span>
    ib.<span class="me1">flip</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>ib.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw3">int</span> i = ib.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>99
11
42
47
1811
143
811
1016
</pre>
<p>&lt;/spoiler&gt;
Перегруженный метод <i><b>put()</b></i> первый раз вызывается для помещения в буфер массива целых чисел int. Последующие вызовы <i><b>put()</b></i> и <i><b>get()</b></i> обращаются к конкретному числу <i><b>int</b></i> из байтового буфера <i><b>ByteBuffer</b></i>. Заметьте, что такие обращения к простейшим типам по абсолютной позиции также можно осуществить напрямую через буфер <i><b>ByteBuffer</b></i>.
</p><p>Как только байтовый буфер <i><b>ByteBuffer</b></i> будет заполнен
 целыми числами или другими примитивами через представление, его можно 
передать для непосредственной записи в канал. Настолько же просто 
считать данные из канала и исполь­зовать представление для 
преобразования данных к конкретному простейшему типу. Вот пример, 
который трактует одну и ту же последовательность байтов как числа <i><b>short, int, float, long</b></i> и  <i><b>double</b></i>, создавая для одного байтового буфера <i><b>ByteBuffer</b></i> различные представления:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/ViewBuffers.java</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ViewBuffers <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw29">ByteBuffer</span> bb = <span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw3">byte</span><span class="br0">[</span><span class="br0">]</span><span class="br0">{</span> <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span>, <span class="st0">'a'</span> <span class="br0">}</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Byte Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>bb.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>bb.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + bb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">CharBuffer</span> cb =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Char Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>cb.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>cb.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" -&gt; "</span> + cb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">FloatBuffer</span> fb =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asFloatBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Float Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>fb.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>fb.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + fb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">IntBuffer</span> ib =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Int Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>ib.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>ib.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + ib.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">LongBuffer</span> lb =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asLongBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Long Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>lb.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>lb.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + lb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">ShortBuffer</span> sb =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asShortBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Short Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>sb.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>sb.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + sb.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">DoubleBuffer</span> db =
      <span class="br0">(</span><span class="br0">(</span><span class="kw29">ByteBuffer</span><span class="br0">)</span>bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">asDoubleBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    printnb<span class="br0">(</span><span class="st0">"Double Buffer "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>db.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      printnb<span class="br0">(</span>db.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span>+ <span class="st0">" -&gt; "</span> + db.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Byte Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 0, 4 -&gt; 0, 5 -&gt; 0, 6 -&gt; 0, 7 -&gt; 97,
Char Buffer 0 -&gt;  , 1 -&gt;  , 2 -&gt;  , 3 -&gt; a,
Float Buffer 0 -&gt; 0.0, 1 -&gt; 1.36E-43,
Int Buffer 0 -&gt; 0, 1 -&gt; 97,
Long Buffer 0 -&gt; 97,
Short Buffer 0 -&gt; 0, 1 -&gt; 0, 2 -&gt; 0, 3 -&gt; 97,
Double Buffer 0 -&gt; 4.8E-322,
</pre>
<p>&lt;/spoiler&gt;
Байтовый буфер <i><b>ByteBuffer</b></i> создается как «обертка» для 
массива из восьми байтов, который затем и просматривается с помощью 
представлений для различных простейших типов.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9E_.D0.BF.D0.BE.D1.80.D1.8F.D0.B4.D0.BA.D0.B5_.D0.B1.D0.B0.D0.B9.D1.82.D0.BE.D0.B2">О порядке байтов</span></h3>
<p>Различные компьютеры могут хранить данные с различным порядком следования байтов. Прямой порядок <i>big_endian</i> располагает старший байт по младшему адресу памяти, а для обратного порядка <i>little_endian</i> старший байт помещается по высшему адресу памяти. При хранении значения, занимающего более одного байта, такого как число <i><b>int, float</b></i> и т. п., вам, возможно, придется учитывать различные варианты следования байтов в памяти. Буфер <i><b>ByteBuffer</b></i> укладывает данные в порядке <i>big_endian</i>,
 такой же способ всегда используется для данных, пересылаемых по сети. 
Порядок следования байтов в буфере можно изменить методом <i><b>order()</b></i>, передав ему аргумент <i><b>ByteOrder.BIG_ENDIAN</b></i> или <i><b>ByteOrder. LITTLE_ENDIAN</b></i>.
Рассмотрим двоичное представление байтового буфера, содержащего следующие два байта:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0519.png" class="image"><img alt="P0519.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0519.png" height="289" width="516"></a>
</p><p>Если прочитать эти данные как тип <i><b>short</b></i> (<i><b>ByteBuffer.asShortBuffer()</b></i>),
 то получите число 97 (00000000 01100001), но при другом порядке 
следования байтов будет получено число 24 832 (01100001 00000000).
</p><p>Следующий пример показывает, как порядок следования байтов отражается на символах в зависимости от настроек буфера:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Endians.java</span>
<span class="co1">// Endian differences and data storage.</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Endians <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw29">ByteBuffer</span> bb = <span class="kw29">ByteBuffer</span>.<span class="me1">wrap</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw3">byte</span><span class="br0">[</span><span class="nu0">12</span><span class="br0">]</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="st0">"abcdef"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>bb.<span class="me1">array</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">order</span><span class="br0">(</span><span class="kw29">ByteOrder</span>.<span class="me1">BIG_ENDIAN</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="st0">"abcdef"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>bb.<span class="me1">array</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">order</span><span class="br0">(</span><span class="kw29">ByteOrder</span>.<span class="me1">LITTLE_ENDIAN</span><span class="br0">)</span><span class="sy0">;</span>
    bb.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span><span class="st0">"abcdef"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>bb.<span class="me1">array</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]
[0, 97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102]
[97, 0, 98, 0, 99, 0, 100, 0, 101, 0, 102, 0]
</pre>
<p>&lt;/spoiler&gt;
В буфере <i><b>ByteBuffer</b></i> достаточно места для хранения всех байтов символьного массива, поэтому для вывода байтов подходит метод <i><b>аrrау()</b></i>. Метод <i><b>аrrау()</b></i>
 является необязательным, и вызывать его следует только для буфера, 
созданного на базе существующего массива; в противном случае произойдет 
исключение <i><b>UnsupportedOperationException</b></i>. Символьный массив помещается в буфер <i><b>ByteBuffer</b></i> посредством представления <i><b>CharBuffer</b></i>. При выводе содержащихся в буфере байтов мы видим, что настройка по умолчанию совпадает с режимом <i>big_endian</i>, в то время как атрибут <i>little_endian</i> переставляет байты в обратном порядке.
</p>
<h3><span class="mw-headline" id=".D0.91.D1.83.D1.84.D0.B5.D1.80.D1.8B_.D0.B8_.D0.BE.D0.BF.D0.B5.D1.80.D0.B0.D1.86.D0.B8.D0.B8_.D1.81_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.BC.D0.B8">Буферы и операции с данными</span></h3>
<p>Следующая диаграмма демонстрирует отношения между классами пакета <i><b>nio</b></i>;
 она поможет вам разобраться, как можно перемещать и преобразовывать 
данные. Например, если вы захотите записать в файл байтовый массив, то 
сначала вложите его в буфер методом <i><b>ByteBuffer.wrap()</b></i>, затем получите из потока <i><b>FileOutputStream</b></i> канал методом <i><b>getChannel()</b></i>, а потом запишите данные буфера <i><b>ByteBuffer</b></i> в полученный канал <i><b>FileChannel</b></i>.
</p><p><br>
<a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0521b.png" class="image"><img alt="P0521b.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0521b.png" height="1017" width="709"></a>
</p><p>Отметьте, что перемещать данные каналов («из» и «в») допустимо только с помощью байтовых буферов <i><b>ByteBuffer</b></i>,
 а для остальных простейших типов можно либо создать отдельный буфер 
этого типа, либо получить такой буфер из байтового буфера посредством 
метода с префиксом <i>as</i>. Таким образом, буфер с примитивными 
данными нельзя преобразовать к байтовому буферу. Впрочем, вы можете 
помещать примитивы в байтовый буфер и извлекать их оттуда с помощью 
представлений, это не такое уж строгое ограничение.
</p>
<h3><span class="mw-headline" id=".D0.9F.D0.BE.D0.B4.D1.80.D0.BE.D0.B1.D0.BD.D0.BE_.D0.BE_.D0.B1.D1.83.D1.84.D0.B5.D1.80.D0.B5">Подробно о буфере</span></h3>
<p>Буфер (<i>Buffer</i>) состоит из данных и четырех индексов, 
используемых для доступа к данным и эффективного манипулирования ими. К 
этим индексам относятся метка (<i>mark</i>), позиция (<i>position</i>), предельное значение (limit) и вместимость (<i>capacity</i>). Есть методы, предназначенные для установки и сброса значений этих индексов, также можно узнать их значение (табл. 16.7).
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0522.png" class="image"><img alt="P0522.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0522.png" height="415" width="782"></a>
</p><p>Методы, вставляющие данные в буфер и считывающие их оттуда, 
обновляют эти индексы в соответствии с внесенными изменениями.
Следующий пример использует очень простой алгоритм (перестановка смежных
 символов) для смешивания и восстановления символов в буфере <i><b>CharBuffer</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/UsingBuffers.java</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UsingBuffers <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">void</span> symmetricScramble<span class="br0">(</span><span class="kw29">CharBuffer</span> buffer<span class="br0">)</span><span class="br0">{</span>
    <span class="kw1">while</span><span class="br0">(</span>buffer.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      buffer.<span class="me1">mark</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">char</span> c1 = buffer.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">char</span> c2 = buffer.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      buffer.<span class="me1">reset</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      buffer.<span class="me1">put</span><span class="br0">(</span>c2<span class="br0">)</span>.<span class="me1">put</span><span class="br0">(</span>c1<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">char</span><span class="br0">[</span><span class="br0">]</span> data = <span class="st0">"UsingBuffers"</span>.<span class="me1">toCharArray</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">ByteBuffer</span> bb = <span class="kw29">ByteBuffer</span>.<span class="me1">allocate</span><span class="br0">(</span>data.<span class="me1">length</span> <span class="sy0">*</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">CharBuffer</span> cb = bb.<span class="me1">asCharBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    cb.<span class="me1">put</span><span class="br0">(</span>data<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>cb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    symmetricScramble<span class="br0">(</span>cb<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>cb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    symmetricScramble<span class="br0">(</span>cb<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>cb.<span class="me1">rewind</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>UsingBuffers
sUniBgfuefsr
UsingBuffers
</pre>
<p>&lt;/spoiler&gt;
Хотя получить буфер <i><b>CharBuffer</b></i> можно и напрямую, вызвав для символьного массива метод <i><b>wrap()</b></i>, здесь сначала выделяется служащий основой байтовый буфер <i><b>ByteBuffer</b></i>, а символьный буфер <i><b>CharBuffer</b></i>
 создается как представление байтового. Это подчеркивает, что в конечном
 счете все манипуляции производятся с байтовым буфером, поскольку именно
 он взаимодействует с каналом. На входе в метод <i><b>symmetricScramble()</b></i> буфер выглядит следующим образом:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0523a.png" class="image"><img alt="P0523a.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0523a.png" height="151" width="407"></a>
</p><p>Позиция (<i>pos</i>) указывает на первый элемент буфера, вместительность (<i>cap</i>) и предельное значение (<i>lim</i>) — на последний. В методе <i><b>symmetricScramble()</b></i> цикл <i><b>while</b></i>
 выполняется до тех пор, пока позиция не станет равной предельному 
значению. Позиция буфера изменяется при вызове для него «относительных» 
методов <i><b>put()</b></i> или <i><b>get()</b></i>. Можно также использовать «абсолютные» версии методов <i><b>put()</b></i> и <i><b>get()</b></i>, которым передается аргумент-индекс, указывающий, с какого места начнет работу метод <i><b>put()</b></i> или метод <i><b>get()</b></i>. Эти методы не изменяют значение позиции буфера.
Когда управление переходит в цикл <i><b>while</b></i>, вызывается метод <i><b>mark()</b></i> для установки значения метки (<i>mar</i>). Состояние буфера в этот момент таково:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0523b.png" class="image"><img alt="P0523b.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0523b.png" height="149" width="405"></a>
</p><p>Два вызова «относительных» методов <i><b>get()</b></i> сохраняют значение первых двух символов в переменных <i><b>с1</b></i> и <i><b>с2</b></i>. После этих вызовов буфер выглядит так:
</p><p><br>
<a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0524a.png" class="image"><img alt="P0524a.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0524a.png" height="150" width="400"></a>
</p><p>Для смешивания символов нам нужно записать символ <i><b>с2</b></i> в позицию <i>0</i>, a <i><b>c1</b></i> в позицию <i>1</i>. Для этого можно обратиться за .«абсолютной» версией метода <i><b>put()</b></i>, но мы приравняем позицию метке, что и делает метод <i><b>reset()</b></i>:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0524b.png" class="image"><img alt="P0524b.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0524b.png" height="150" width="400"></a>
</p><p>Два вызова метода <i><b>put()</b></i> записывают <i><b>с2</b></i>, а затем <i><b>c1</b></i>:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0524c.png" class="image"><img alt="P0524c.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0524c.png" height="150" width="400"></a>
</p><p>На следующей итерации значение метки приравнивается позиции:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0524d.png" class="image"><img alt="P0524d.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0524d.png" height="150" width="400"></a>
</p><p>Процесс продолжается до тех пор, пока не будет просмотрен весь буфер. В конце цикла <i><b>while</b></i>
 позиция находится в конце буфера. При выводе буфера на печать 
распечатываются только символы, находящиеся между позицией и предельным 
значением. Поэтому, если вы хотите распечатать буфер целиком, придется 
установить позицию на начало буфера, используя для этого метод <i><b>rewind()</b></i>. Вот в каком состоянии находится буфер после вызова метода <i><b>rewind()</b></i> (значение метки стало неопределенным):
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0524e.png" class="image"><img alt="P0524e.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0524e.png" height="150" width="400"></a>
</p><p>При следующем вызове <i><b>symmetricScramble()</b></i> процесс повторяется, и буфер <i><b>CharBuffer</b></i> возвращается к своему изначальному состоянию.
</p>
<h3><span class="mw-headline" id=".D0.9E.D1.82.D0.BE.D0.B1.D1.80.D0.B0.D0.B6.D0.B0.D0.B5.D0.BC.D1.8B.D0.B5_.D0.B2_.D0.BF.D0.B0.D0.BC.D1.8F.D1.82.D1.8C_.D1.84.D0.B0.D0.B9.D0.BB.D1.8B">Отображаемые в память файлы</span></h3>
<p>Механизм отображения файлов в память позволяет создавать и изменять 
файлы, размер которых слишком велик для прямого размещения в памяти. В 
таком случае вы считаете, что файл целиком находится в памяти, и 
работаете с ним как с очень большим массивом. Такой подход значительно 
упрощает код изменения файла. Небольшой пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/LargeMappedFiles.java</span>
<span class="co1">// Создание очень большого файла, отображаемого в память.</span>
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> LargeMappedFiles <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">int</span> length = 0x8FFFFFF<span class="sy0">;</span> <span class="co1">// 128 MB</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw29">MappedByteBuffer</span> out =
      <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span><span class="st0">"test.dat"</span>, <span class="st0">"rw"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span>
      .<span class="me1">map</span><span class="br0">(</span><span class="kw30">FileChannel.<span class="me1">MapMode</span></span>.<span class="me1">READ_WRITE</span>, <span class="nu0">0</span>, length<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> length<span class="sy0">;</span> i++<span class="br0">)</span>
      out.<span class="me1">put</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">byte</span><span class="br0">)</span><span class="st0">'x'</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Finished writing"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = length/<span class="nu0">2</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> length/<span class="nu0">2</span> + <span class="nu0">6</span><span class="sy0">;</span> i++<span class="br0">)</span>
      printnb<span class="br0">(</span><span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span>out.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Чтобы одновременно выполнять чтение и запись, мы начинаем с создания объекта <i><b>RandomAccessFile</b></i>, получаем для этого файла канал, а затем вызываем метод <i><b>mар()</b></i>, чтобы получить буфер <i><b>MappedByteBuffer</b></i>,
 который представляет собой разновидность буфера прямого доступа. 
Заметьте, что необходимо указать начальную точку и длину участка, 
который будет проецироваться, то есть у вас есть возможность отображать 
маленькие участки больших файлов.
Класс <i><b>MappedByteBuffer</b></i> унаследован от буфера <i><b>ByteBuffer</b></i>, поэтому он содержит все методы последнего. Здесь представлены только простейшие вызовы методов <i><b>put()</b></i> и <i><b>get()</b></i>, но вы также можете использовать такие возможности, как метод <i><b>asCharBuffer()</b></i>
 и т. п.
Программа напрямую создает файл размером 128 Мбайт; скорее всего, это 
превышает ограничения вашей операционной системы на размер блока данных,
 находящегося в памяти. Однако создается впечатление, что весь файл 
доступен сразу, поскольку только часть его подгружается в память, в то 
время как остальные части выгружены. Таким образом можно работать с 
очень большими (размером до 2 Гбайт) файлами. Заметьте, что для 
достижения максимальной производительности используются низкоуровневые 
механизмы отображения файлов используемой операционной системы.
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D1.81.D1.82.D1.8C">Производительность</span></h3>
<p>Хотя быстродействие «старого» ввода/вывода было улучшено за счет 
переписывания его с учетом новых библиотек nio, техника отображения 
файлов качественно эффективнее. Следующая программа выполняет простое 
сравнение производительности:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/MappedIO.java</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> MappedIO <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> numOfInts = <span class="nu0">4000000</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> numOfUbuffInts = <span class="nu0">200000</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">abstract</span> <span class="kw2">static</span> <span class="kw2">class</span> Tester <span class="br0">{</span>
    <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
    <span class="kw2">public</span> Tester<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">name</span> = name<span class="sy0">;</span> <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> runTest<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>name + <span class="st0">": "</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="kw3">long</span> start = <span class="kw21">System</span>.<span class="me1">nanoTime</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        test<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw3">double</span> duration = <span class="kw21">System</span>.<span class="me1">nanoTime</span><span class="br0">(</span><span class="br0">)</span> - start<span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">format</span><span class="br0">(</span><span class="st0">"%.2f<span class="es0">\n</span>"</span>, duration/1.0e9<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">static</span> Tester<span class="br0">[</span><span class="br0">]</span> tests = <span class="br0">{</span>
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Stream Write"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw166">DataOutputStream</span> dos = <span class="kw2">new</span> <span class="kw166">DataOutputStream</span><span class="br0">(</span>
          <span class="kw2">new</span> <span class="kw20">BufferedOutputStream</span><span class="br0">(</span>
            <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"temp.tmp"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> numOfInts<span class="sy0">;</span> i++<span class="br0">)</span>
          dos.<span class="me1">writeInt</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
        dos.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>,
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Mapped Write"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw30">FileChannel</span> fc =
          <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span><span class="st0">"temp.tmp"</span>, <span class="st0">"rw"</span><span class="br0">)</span>
          .<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw29">IntBuffer</span> ib = fc.<span class="me1">map</span><span class="br0">(</span>
          <span class="kw30">FileChannel.<span class="me1">MapMode</span></span>.<span class="me1">READ_WRITE</span>, <span class="nu0">0</span>, fc.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
          .<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> numOfInts<span class="sy0">;</span> i++<span class="br0">)</span>
          ib.<span class="me1">put</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
        fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>,
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Stream Read"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw166">DataInputStream</span> dis = <span class="kw2">new</span> <span class="kw166">DataInputStream</span><span class="br0">(</span>
          <span class="kw2">new</span> <span class="kw20">BufferedInputStream</span><span class="br0">(</span>
            <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"temp.tmp"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> numOfInts<span class="sy0">;</span> i++<span class="br0">)</span>
          dis.<span class="me1">readInt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        dis.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>,
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Mapped Read"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw30">FileChannel</span> fc = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span>
          <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"temp.tmp"</span><span class="br0">)</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw29">IntBuffer</span> ib = fc.<span class="me1">map</span><span class="br0">(</span>
          <span class="kw30">FileChannel.<span class="me1">MapMode</span></span>.<span class="me1">READ_ONLY</span>, <span class="nu0">0</span>, fc.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
          .<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">while</span><span class="br0">(</span>ib.<span class="me1">hasRemaining</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
          ib.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>,
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Stream Read/Write"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw20">RandomAccessFile</span> raf = <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span>
          <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"temp.tmp"</span><span class="br0">)</span>, <span class="st0">"rw"</span><span class="br0">)</span><span class="sy0">;</span>
        raf.<span class="me1">writeInt</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> numOfUbuffInts<span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
          raf.<span class="me1">seek</span><span class="br0">(</span>raf.<span class="me1">length</span><span class="br0">(</span><span class="br0">)</span> - <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
          raf.<span class="me1">writeInt</span><span class="br0">(</span>raf.<span class="me1">readInt</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
        raf.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>,
    <span class="kw2">new</span> Tester<span class="br0">(</span><span class="st0">"Mapped Read/Write"</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">void</span> test<span class="br0">(</span><span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
        <span class="kw30">FileChannel</span> fc = <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span>
          <span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">"temp.tmp"</span><span class="br0">)</span>, <span class="st0">"rw"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw29">IntBuffer</span> ib = fc.<span class="me1">map</span><span class="br0">(</span>
          <span class="kw30">FileChannel.<span class="me1">MapMode</span></span>.<span class="me1">READ_WRITE</span>, <span class="nu0">0</span>, fc.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
          .<span class="me1">asIntBuffer</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        ib.<span class="me1">put</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> numOfUbuffInts<span class="sy0">;</span> i++<span class="br0">)</span>
          ib.<span class="me1">put</span><span class="br0">(</span>ib.<span class="me1">get</span><span class="br0">(</span>i - <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        fc.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span>Tester test&nbsp;: tests<span class="br0">)</span>
      test.<span class="me1">runTest</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (90% match)
</p>
<pre>Stream Write: 0.56
Mapped Write: 0.12
Stream Read: 0.80
Mapped Read: 0.07
Stream Read/Write: 5.32
Mapped Read/Write: 0.02
</pre>
<p>&lt;/spoiler&gt;
Как уже было видно из предыдущих примеров книги, <i><b>runTest()</b></i> — не что иное как метод шаблона, предоставляющий тестовую инфраструктуру для различных реализаций метода <i><b>test()</b></i>, определенного в безымянных внутренних подклассах. Каждый из этих подклассов выполняет свой вид теста, таким образом, методы <i><b>test()</b></i> также являются прототипами для выполнения различных действий, связанных с вводом/выводом.
Хотя кажется, что для отображаемой записи следует использовать поток <i><b>FileOutputStream</b></i>, на самом деле любые операции отображаемого вывода должны проходить через класс <i><b>RandomAccessFile</b></i> так же, как выполняется чтение/запись в рассмотренном примере.
Отметьте, что в методах <i><b>test()</b></i> также учитывается 
инициализация различных объектов для работы с вводом/выводом, и, 
несмотря на то что настройка отображаемых файлов может быть затратной, 
общее преимущество по сравнению с потоковым вводом/выводом все равно 
получается весьма значительным.
</p>
<h3><span class="mw-headline" id=".D0.91.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.BA.D0.B0_.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2">Блокировка файлов</span></h3>
<p>Блокировка файлов позволяет синхронизировать доступ к файлу как к 
совместно используемому ресурсу. Впрочем, потоки, претендующие на один и
 тот же файл, могут принадлежать различным виртуальным машинам <i>JVM</i>, или один поток может быть <i>Java</i>-потоком,
 а другой представлять собой обычный поток операционной системы. 
Блокированные файлы видны другим процессам операционной системы, 
поскольку механизм блокировки <i>Java</i> напрямую связан со средствами операционной системы. Вот простой пример блокировки файла:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/FileLocking.java</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FileLocking <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw20">FileOutputStream</span> fos= <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"file.txt"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw30">FileLock</span> fl = fos.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">tryLock</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>fl <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Locked File"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw47">TimeUnit</span>.<span class="me1">MILLISECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
      fl.<span class="me1">release</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Released Lock"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    fos.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Locked File
Released Lock
</pre>
<p>&lt;/spoiler&gt;
Блокировать файл целиком позволяет объект <i><b>FileLock</b></i>, который вы получаете, вызывая метод <i><b>tryLock()</b></i> или <i><b>lock()</b></i> класса <i><b>FileChannel</b></i>. (Сетевые каналы <i><b>SocketChannel</b></i>, <i><b>DatagramChannel</b></i> и <i><b>ServerSocketChannel</b></i>
 не нуждаются в блокировании, так как они доступны в пределах одного 
процесса. Вряд ли сокет будет использоваться двумя процессами 
совместно.) Метод <i><b>tryLock()</b></i> не приостанавливает программу.
 Он пытается овладеть объектом блокировки, но если ему это не удается 
(если другой процесс уже владеет этим объектом или файл не является 
разделяемым), то он просто возвращает управление. Метод <i><b>lock()</b></i>
 ждет до тех пор, пока не удастся получить объект блокировки, или поток,
 в котором этот метод был вызван, не будет прерван, или же пока не будет
 закрыт канал, для которого был вызван метод <i><b>lock()</b></i>. Блокировка снимается методом <i><b>FileChannel.release()</b></i>.
</p><p>Также можно заблокировать часть файла вызовом
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> tryLock<span class="br0">(</span><span class="kw3">long</span> position, <span class="kw3">long</span> size, <span class="kw3">boolean</span> shared<span class="br0">)</span></pre></div></div>
<p>или
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> lock <span class="br0">(</span><span class="kw3">long</span> position, <span class="kw3">long</span> size, <span class="kw3">boolean</span> shared<span class="br0">)</span></pre></div></div>
<p>Блокируется участок файла размером <i><b>size</b></i> от позиции <i><b>position</b></i>.
 Третий аргумент указывает, будет ли блокировка совместной.
Методы без аргументов приспосабливаются к изменению размеров файла, в то
 время как методы для блокировки участков не адаптируются к новому 
размеру файла. Если блокировка была наложена на область от позиции <i><b>position</b></i> до <i><b>position + size</b></i>, а затем файл увеличился и стал больше размера <i><b>position + size</b></i>, то часть файла за пределами <i><b>position + size</b></i>
 не блокируется. Методы без аргументов блокируют файл целиком, даже если
 он растет.
Поддержка блокировок с эксклюзивным или разделяемым доступом должна быть
 встроена в операционную систему. Если операционная система не 
поддерживает разделяемые блокировки и был сделан запрос на получение 
такой бло­кировки, используется эксклюзивный доступ. Тип блокировки 
(разделяемая или эксклюзивная) можно узнать при помощи метода <i><b>FileLock.isShared()</b></i>.
</p>
<h3><span class="mw-headline" id=".D0.91.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.87.D0.B0.D1.81.D1.82.D0.B8_.D0.BE.D1.82.D0.BE.D0.B1.D1.80.D0.B0.D0.B6.D0.B0.D0.B5.D0.BC.D0.BE.D0.B3.D0.BE_.D1.84.D0.B0.D0.B9.D0.BB.D0.B0">Блокирование части отображаемого файла</span></h3>
<p>Как уже было упомянуто, отображение файлов обычно используется для 
файлов очень больших размеров. Иногда при работе с таким большим файлом 
требуется заблокировать некоторые его части, в то время как доступные 
части будут изменяться другими процессами. В частности, такой подход 
характерен для баз данных, чтобы несколько пользователей могли работать с
 базой одновременно.
В следующем примере каждый их двух потоков блокирует свою собственную 
часть файла:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/LockingMappedFiles.java</span>
<span class="co1">// Блокирование части отображаемого файла.</span>
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.nio.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.nio.channels.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> LockingMappedFiles <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> LENGTH = 0x8FFFFFF<span class="sy0">;</span> <span class="co1">// 128 MB</span>
  <span class="kw2">static</span> <span class="kw30">FileChannel</span> fc<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    fc =
      <span class="kw2">new</span> <span class="kw20">RandomAccessFile</span><span class="br0">(</span><span class="st0">"test.dat"</span>, <span class="st0">"rw"</span><span class="br0">)</span>.<span class="me1">getChannel</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw29">MappedByteBuffer</span> out =
      fc.<span class="me1">map</span><span class="br0">(</span><span class="kw30">FileChannel.<span class="me1">MapMode</span></span>.<span class="me1">READ_WRITE</span>, <span class="nu0">0</span>, LENGTH<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> LENGTH<span class="sy0">;</span> i++<span class="br0">)</span>
      out.<span class="me1">put</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">byte</span><span class="br0">)</span><span class="st0">'x'</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> LockAndModify<span class="br0">(</span>out, <span class="nu0">0</span>, <span class="nu0">0</span> + LENGTH/<span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> LockAndModify<span class="br0">(</span>out, LENGTH/<span class="nu0">2</span>, LENGTH/<span class="nu0">2</span> + LENGTH/<span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">class</span> LockAndModify <span class="kw2">extends</span> <span class="kw21">Thread</span> <span class="br0">{</span>
    <span class="kw2">private</span> <span class="kw29">ByteBuffer</span> buff<span class="sy0">;</span>
    <span class="kw2">private</span> <span class="kw3">int</span> start, end<span class="sy0">;</span>
    LockAndModify<span class="br0">(</span><span class="kw29">ByteBuffer</span> mbb, <span class="kw3">int</span> start, <span class="kw3">int</span> end<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">this</span>.<span class="me1">start</span> = start<span class="sy0">;</span>
      <span class="kw2">this</span>.<span class="me1">end</span> = end<span class="sy0">;</span>
      mbb.<span class="me1">limit</span><span class="br0">(</span>end<span class="br0">)</span><span class="sy0">;</span>
      mbb.<span class="me1">position</span><span class="br0">(</span>start<span class="br0">)</span><span class="sy0">;</span>
      buff = mbb.<span class="me1">slice</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      start<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> run<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">try</span> <span class="br0">{</span>
        <span class="co1">// Exclusive lock with no overlap:</span>
        <span class="co1">// Монопольная блокировка без перекрытия:</span>
        <span class="kw30">FileLock</span> fl = fc.<span class="me1">lock</span><span class="br0">(</span>start, end, <span class="kw4">false</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Locked: "</span>+ start +<span class="st0">" to "</span>+ end<span class="br0">)</span><span class="sy0">;</span>
        <span class="co1">// Perform modification:</span>
        <span class="co1">// Модификация:</span>
        <span class="kw1">while</span><span class="br0">(</span>buff.<span class="me1">position</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">&lt;</span> buff.<span class="me1">limit</span><span class="br0">(</span><span class="br0">)</span> - <span class="nu0">1</span><span class="br0">)</span>
          buff.<span class="me1">put</span><span class="br0">(</span><span class="br0">(</span><span class="kw3">byte</span><span class="br0">)</span><span class="br0">(</span>buff.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span> + <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
        fl.<span class="me1">release</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Released: "</span>+start+<span class="st0">" to "</span>+ end<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw20">IOException</span> e<span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Класс потока <i><b>LockAndModify</b></i> устанавливает область буфера и получает его для модификации методом <i><b>slice()</b></i>. В методе <i><b>run()</b></i>
 для файлового канала устанавливается блокировка (вы не вправе запросить
 блокировку для буфера, это позволено только для канала). Вызов <i><b>lock()</b></i>
 напоминает механизм синхронизации доступа потоков к объектам, у вас 
появляется некая «критическая секция» с монопольным доступом к данной 
части файла.
Блокировки автоматически снимаются при завершении работы <i>JVM</i>, закрытии канала, для которого они были получены, но можно также явно вызвать метод <i><b>release()</b></i> объекта <i><b>FileLock</b></i>, что здесь и показано.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B6.D0.B0.D1.82.D0.B8.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85">Сжатие данных</span></h2>
<p>Библиотека ввода/вывода <i>Java</i> содержит классы, поддерживающие 
ввод/вывод в сжатом формате (табл. 16.8). Они базируюся на уже 
существующих потоках ввода/вывода.
</p><p>Эти классы не являются частью иерархии символьно-ориентированных 
потоков Reader и Writer, они надстроены над байт-ориентированными 
классами <i><b>InputStream</b></i> и <i><b>OutputStream</b></i>, так как
 библиотека сжатия работает не с символами, а с байтами. Впрочем, никто 
не запрещает смешивать потоки. (Помните, как легко преобразовать потоки 
из байтовых в символьные — достаточно использовать классы <i><b>InputStreamReader</b></i> и <i><b>OutputStreamWriter</b></i>.)
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A4%D0%B0%D0%B9%D0%BB:P0531.png" class="image"><img alt="P0531.png" src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/P0531.png" height="393" width="782"></a>
</p><p>Хотя существует великое количество различных программ сжатия данных, форматы <i>ZIP</i> и <i>GZIP</i>
 используются, пожалуй, чаще всего. Таким образом, вы можете легко 
манипулировать своими сжатыми данными с помощью многочисленных программ,
 предназначенных для чтения и записи этих форматов.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.BE.D0.B5_.D1.81.D0.B6.D0.B0.D1.82.D0.B8.D0.B5_.D0.B2_.D1.84.D0.BE.D1.80.D0.BC.D0.B0.D1.82.D0.B5_GZIP">Простое сжатие в формате <i>GZIP</i></span></h3>
<p>Интерфейс сжатия данных в формате <i>GZIP</i> является наиболее 
простым и идеально подходит для ситуаций, где имеется один поток данных,
 который необходимо уплотнить (а не разрозненные фрагменты данных). В 
следующем примере сжимается файл:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/GZIPcompress.java</span>
<span class="co1">// {Args: GZIPcompress.java}</span>
<span class="kw2">import</span> <span class="co2">java.util.zip.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GZIPcompress <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">0</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>
        <span class="st0">"Usage: <span class="es0">\n</span>GZIPcompress file<span class="es0">\n</span>"</span> +
        <span class="st0">"<span class="es0">\t</span>Uses GZIP compression to compress "</span> +
        <span class="st0">"the file to test.gz"</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">exit</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw20">BufferedReader</span> in = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileReader</span><span class="br0">(</span>args<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">BufferedOutputStream</span> out = <span class="kw2">new</span> <span class="kw20">BufferedOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw54">GZIPOutputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"test.gz"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Writing file"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> c<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>c = in.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= -<span class="nu0">1</span><span class="br0">)</span>
      out.<span class="me1">write</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
    in.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Reading file"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">BufferedReader</span> in2 = <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">InputStreamReader</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw54">GZIPInputStream</span><span class="br0">(</span>
        <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"test.gz"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = in2.<span class="me1">readLine</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Работать с классами сжатия данных очень просто: вы просто надстраиваете их для своего потока данных (<i><b>GZIPOutputStream</b></i> или <i><b>ZipOutputStream</b></i> для сжатия, <i><b>GZIPInputStream</b></i> или <i><b>ZipInputStream</b></i>
 для распаковки данных). Дальнейшее сводится к элементарным операциям 
ввода/вывода. В примере продемонстрированы смешанные байтовые и 
символьные потоки: поток <i><b>in</b></i> основан на <i><b>Reader</b></i>, тогда как конструктор класса <i><b>GZIPOutputStream</b></i> использует только потоки на основе <i><b>OutputStream</b></i>, но не <i><b>Writer</b></i>. Поэтому при открытии файла поток <i><b>GZIPInputStream</b></i> преобразуется в символьный поток <i><b>Reader</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9C.D0.BD.D0.BE.D0.B3.D0.BE.D1.84.D0.B0.D0.B9.D0.BB.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B0.D1.80.D1.85.D0.B8.D0.B2.D1.8B_ZIP">Многофайловые архивы <i>ZIP</i></span></h3>
<p>Библиотека, поддерживающая формат сжатия данных <i>ZIP</i>, обладает 
гораздо более широкими возможностями. С ее помощью можно легко 
упаковывать произвольное количество файлов, а для чтения файлов в 
формате <i>ZIP</i> даже определен отдельный класс. В библиотеке поддержан стандартный <i>ZIP</i>-формат,
 поэтому сжатые ею данные будут восприниматься практически любым 
упаковщиком. Структура следующего примера совпадает со структурой 
предыдущего, но количество файлов, указываемых в командной строке, не 
ограничено. Вдобавок демонстрируется применение класса <i><b>Checksum</b></i> для получения и проверки контрольной суммы. Таких типов контрольных сумм в <i>Java</i> два: один представлен классом <i><b>Adler32</b></i>(этот алгоритм быстрее), а другой — классом <i><b>CRC32</b></i> (медленнее, но точнее).
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/ZipCompress.java</span>
<span class="co1">// Использование формата ZIP для сжатия любого</span>
<span class="co1">// количества файлов, указанных в командной строке.</span>
<span class="co1">// {Параметры. ZipCompress java}</span>
<span class="kw2">import</span> <span class="co2">java.util.zip.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ZipCompress <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    <span class="kw20">FileOutputStream</span> f = <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"test.zip"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw54">CheckedOutputStream</span> csum =
      <span class="kw2">new</span> <span class="kw54">CheckedOutputStream</span><span class="br0">(</span>f, <span class="kw2">new</span> <span class="kw54">Adler32</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
     <span class="kw54">ZipOutputStream</span> zos = <span class="kw2">new</span> <span class="kw54">ZipOutputStream</span><span class="br0">(</span>csum<span class="br0">)</span><span class="sy0">;</span>
     <span class="kw20">BufferedOutputStream</span> out =
      <span class="kw2">new</span> <span class="kw20">BufferedOutputStream</span><span class="br0">(</span>zos<span class="br0">)</span><span class="sy0">;</span>
    zos.<span class="me1">setComment</span><span class="br0">(</span><span class="st0">"A test of Java Zipping"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// No corresponding getComment(), though.</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> arg&nbsp;: args<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Writing file "</span> + arg<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw20">BufferedReader</span> in =
        <span class="kw2">new</span> <span class="kw20">BufferedReader</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">FileReader</span><span class="br0">(</span>arg<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      zos.<span class="me1">putNextEntry</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw54">ZipEntry</span><span class="br0">(</span>arg<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">int</span> c<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>c = in.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= -<span class="nu0">1</span><span class="br0">)</span>
        out.<span class="me1">write</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
      in.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      out.<span class="me1">flush</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Checksum valid only after the file has been closed!</span>
    print<span class="br0">(</span><span class="st0">"Checksum: "</span> + csum.<span class="me1">getChecksum</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getValue</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now extract the files:</span>
    print<span class="br0">(</span><span class="st0">"Reading file"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">FileInputStream</span> fi = <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"test.zip"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw54">CheckedInputStream</span> csumi =
      <span class="kw2">new</span> <span class="kw54">CheckedInputStream</span><span class="br0">(</span>fi, <span class="kw2">new</span> <span class="kw54">Adler32</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw54">ZipInputStream</span> in2 = <span class="kw2">new</span> <span class="kw54">ZipInputStream</span><span class="br0">(</span>csumi<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">BufferedInputStream</span> bis = <span class="kw2">new</span> <span class="kw20">BufferedInputStream</span><span class="br0">(</span>in2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw54">ZipEntry</span> ze<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>ze = in2.<span class="me1">getNextEntry</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"Reading file "</span> + ze<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw3">int</span> x<span class="sy0">;</span>
      <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>x = bis.<span class="me1">read</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= -<span class="nu0">1</span><span class="br0">)</span>
        <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">write</span><span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw1">if</span><span class="br0">(</span>args.<span class="me1">length</span> == <span class="nu0">1</span><span class="br0">)</span>
    print<span class="br0">(</span><span class="st0">"Checksum: "</span> + csumi.<span class="me1">getChecksum</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getValue</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    bis.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Alternative way to open and read Zip files:</span>
    <span class="kw54">ZipFile</span> zf = <span class="kw2">new</span> <span class="kw54">ZipFile</span><span class="br0">(</span><span class="st0">"test.zip"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Enumeration</span> e = zf.<span class="me1">entries</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span>e.<span class="me1">hasMoreElements</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw54">ZipEntry</span> ze2 = <span class="br0">(</span><span class="kw54">ZipEntry</span><span class="br0">)</span>e.<span class="me1">nextElement</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      print<span class="br0">(</span><span class="st0">"File: "</span> + ze2<span class="br0">)</span><span class="sy0">;</span>
      <span class="co1">// ... and extract the data as before</span>
    <span class="br0">}</span>
    <span class="coMULTI">/* if(args.length == 1) */</span>
  <span class="br0">}</span>
<span class="br0">}</span> <span class="coMULTI">/* (Execute to see output) */</span><span class="co1">//:~</span></pre></div></div>
<p>Для каждого файла, добавляемого в архив, необходимо вызвать метод <i><b>putNextEntry()</b></i> с соответствующим объектом <i><b>ZipEntry</b></i>. Класс <i><b>ZipEntry</b></i> содержит все необходимое для добавления к отдельной записи <i>ZIP</i>-файла дополнительной информации: имени файла, размера в сжатом и обычном виде, контрольной суммы <i>CRC</i>, дополнительных данных, комментариев, метода сжатия, признака каталога. В исходном формате <i>ZIP</i> также можно задать пароли, но библиотека <i>Java</i> не поддерживает эту возможность. Аналогичное ограничение встречается и при использовании контрольных сумм: потоки <i><b>CheckedInputStream</b></i> и <i><b>CheckedOutputStream </b></i>поддерживают оба вида контрольных сумм — и <i><b>Adler32</b></i>, и <i><b>CRC32</b></i>, однако в классе <i><b>ZipEntry</b></i> поддерживается только <i>CRC</i>. Это ограничение вынужденное, поскольку продиктовано требованиями формата <i>ZIP</i>, однако при этом быстрая контрольная сумма <i>Adler32</i> оказывается в неравных условиях с <i>CRC</i>.
</p><p>Для извлечения файлов в классе <i><b>ZipInputStream</b></i> предусмотрен метод <i><b>getNextEntry()</b></i>,
 который возвращает очередной элемент архива ZipEntry. Для получения 
более компактной записи можно использовать для архива объект <i><b>ZipFile</b></i>, чей ме­тод <i><b>entries()</b></i> возвращает итератор <i><b>Enumeration</b></i>, с помощью которого можно перемещаться по доступным элементам архивного файла.
</p><p>Чтобы Иметь доступ к контрольной сумме, необходимо каким-либо образом хранить представляющий ее объект <i><b>Checksum</b></i>. В нашем случае сохраняются ссылки на потоки <i><b>CheckedInputStream</b></i> и <i><b>CheckedOutputStream</b></i>, хотя можно было бы просто сохранить ссылки на объекты <i><b>Checksum</b></i>.
</p><p>Неясно, зачем в библиотеку сжатия <i>ZIP</i> был добавлен метод <i><b>setComment()</b></i>,
 вставляющий в архивный файл комментарий. Как указано в примере, 
добавить комментарий при получении архивного файла можно, но 
восстановить его при чтении архива потоком <i><b>ZipInputStream</b></i> нельзя. Полноценные комментарии поддерживаются только для отдельных вхождений <i>ZIP</i>-архива, объектов <i><b>ZipEntry</b></i>.
</p><p>Конечно, уплотняемые данные не ограничены файлами; пользуясь библиотеками <i>ZIP</i> и <i>GZIP</i>, вы можете сжимать все, что угодно, даже данные сетевых потоков.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.90.D1.80.D1.85.D0.B8.D0.B2.D1.8B_Java_ARchives_.28.D1.84.D0.B0.D0.B9.D0.BB.D1.8B_JAR.29">Архивы <i>Java</i> ARchives (файлы <i>JAR</i>)</span></h3>
<p>Формат <i>ZIP</i> также применяется в файлах <i>JAR</i> (архивы <i>Java ARchive</i>), предназначенных для упаковки группы файлов в один сжатый файл. Как и все в языке <i>Java</i>, файлы <i>JAR</i>
 являются кросс-платформенными, поэтому не нужно заботиться о 
совместимости платформ. Наравне с файлами классов, в них могут 
содержаться также любые файлы — например, графические и мультимедийные.
</p><p>Файлы <i>JAR</i> особенно полезны при работе с Интернетом. До их 
появления веб-браузерам приходилось выдавать отдельный запрос к серверу 
для каждого файла, необходимого для запуска апплета. Вдобавок все эти 
файлы не сжимались. Объединение всех нужных для запуска апплета файлов в
 одном сжатом файле сокращает время запроса к серверу, при этом 
уменьшается и загрузка сервера. Кроме того, каждый элемент архива <i>JAR</i> можно снабдить цифровой подписью.
</p><p>Файл <i>JAR</i> представляет собой файл, в котором хранится набор сжатых файлов вместе с манифестом (<i>manifest</i>), который их описывает. (Вы можете создать манифест самостоятельно или же поручить эту работу программе <i><b>jar</b></i>.) За подробной информацией о манифестах <i>JAR</i> обращайтесь к документации <i>JDK</i>.
</p><p>Инструмент <i><b>jar</b></i>, который поставляется вместе с пакетом разработки программ <i>JDK</i>, автоматически сжимает файлы по вашему выбору. Запускается эта программа из командной строки:
</p>
<pre>jar [параметры] место_назначения [манифест] список_файлов
</pre>
<p>Параметры запуска — просто набор букв (дефисы или другие служебные 
символы не нужны). Пользователи систем UNIX/Linux сразу заметят сходство
 с программой <i><b>tar</b></i>. Допустимы следующие параметры:
</p>
<pre>с    - Создание нового или пустого архива
t    - Вывод содержимого архива
х    - Извлечение всех файлов
х    - файл Извлечение файла с заданным именем
f    - Признак имени файла. Если не использовать этот параметр, jar решит, что входные
      данные поступают из стандартного ввода, или при создании файла выходные данные будут
      направляться в стандартный поток вывода 
m    - Означает, что первый аргумент содержит имя файла, содержащего манифест
v    - Выводит краткое описание действий, выполняемых программой jar
о    - Сохранение файлов без сжатия (для создания файлов <i>JAR</i>, которые можно указать
      в переменной окружения CLASSPATH) 
М    - Отказ от автоматического создания манифеста
</pre>
<p>Если в списке файлов имеется каталог, то его содержимое вместе с подкаталогами и всеми файлами автоматически помещается в файл <i>JAR</i>. Информация о пути файлов также сохраняется.
</p><p>Несколько примеров наиболее распространенных вариантов запуска программы <i><b>jar</b></i>:
</p>
<pre>jar cf myJarFile.jar *.class
</pre>
<p>Команда создает файл <i>JAR</i> с именем myJarFile.jar, в котором содержатся все файлы классов из текущего каталога, с автоматически созданным манифестом:
</p>
<pre>jar cmf myJarFile.jar myManifestFile.mf *.class
</pre>
<p>Почти идентична предыдущей команде, за одним исключением — в полученный файл <i>JAR</i> включается пользовательский манифест из файла <i><b>myManifestFile.mf</b></i>:
</p>
<pre>jar tf myJarFile.jar
</pre>
<p>Вывод содержимого (списка файлов) архива <i><b>myJarFile.jar</b></i>:
</p>
<pre>jar tvf myJarFile.jar
</pre>
<p>К предыдущей команде добавлен параметр <i><b>v</b></i> для получения более подробной информации о файлах, содержащихся в архиве <i><b>myJarFile.jar</b></i>:
</p>
<pre>jar cvf myApp.jar audio classes image
</pre>
<p><br>
Предполагается, что <i><b>audio, classes</b></i> и <i><b>image</b></i> — это каталоги, содержимое которых включается в файл <i><b>myApp.jar</b></i>. Благодаря параметру <i><b>v</b></i> в процессе сжатия выводится дополнительная информация об упаковываемых файлах.
Инструмент <i><b>jar</b></i> не обладает возможностями архиватора <i><b>zip</b></i>. Например, он не позволяет добавлять или обновлять файлы в уже существующем архиве <i>JAR</i>. Также нельзя перемещать файлы и удалять их после перемещения. Но при этом созданный файл <i>JAR</i> всегда читается инструментом <i><b>jar</b></i> на другой платформе (архиваторы <i><b>zip</b></i> о такой совместимости могут только мечтать).
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B5.D1.80.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D0.BE.D0.B2">Сериализация объектов</span></h2>
<p>Сериализация (<i>serialization</i>) объектов <i>Java</i> позволяет вам взять любой объект, реализующий интерфейс <i><b>Serializable</b></i>,
 и превратить его в последовательность байтов, из которой затем можно 
полностью восстановить исходный объект. Сказанное справедливо и для 
сетевых соединений, а это значит, что механизм сериализации 
автоматически компенсирует различия между операционными системами. То 
есть можно создать объект на машине с ОС Windows, превратить его в 
последовательность байтов, а затем послать их по сети на машину с ОС 
UNIX, где объект будет корректно воссоздан. Вам не надо думать о 
различных форматах данных, порядке следования байтов или других деталях.
</p><p>Сама по себе сериализация объектов интересна потому, что с ее помощью можно осуществить легковесное долговременное хранение (<i>lightweight persistence</i>).
 Вспомните: это означает, что время жизни объекта определяется не только
 вре­менем выполнения программы — объект существует и между запусками 
программы. Можно взять объект и записать его на диск, а после, при 
другом запуске программы, восстановить его в первоначальном виде и таким
 образом получить эффект «живучести». Причина использования добавки 
«легковесное» такова: объект нельзя определить как «постоянный» при 
помощи некоторого ключевого слова, то есть долговременное хранение 
напрямую не поддерживается языком (хотя вероятно, такая возможность 
появится в будущем). Система выполнения не заботится о деталях 
сериализации — вам приходится собственноручно сериализовывать и 
восстанавливать объекты вашей программы. Если вам необходим более 
серьезный механизм сериализации, попробуйте библиотеку <i>Java JDO</i> или инструмент, подобный <i>Hibernate </i> (<a rel="nofollow" class="external free" href="http://hibernate.sourceforge.net/">http://hibernate.sourceforge.net</a>).
</p><p>Механизм сериализации объектов был добавлен в язык для поддержки двух расширенных возможностей. Удаленный вызов методов <i>Java</i> (<i>RMI</i>)
 позволяет работать с объектами, находящимися на других компьютерах, 
точно так же, как и с теми, что существуют на вашей машине. При посылке 
сообщений удаленным объектам необходимо транспортировать аргументы и 
возвращаемые значения, а для этого используется сериализация объектов.
</p><p>Сериализация объектов также необходима визуальным компонентам <b>JavaBean</b>.
 Информация о состоянии визуальных компонентов обычно изменяется во 
время разработки. Эту информацию о состоянии необходимо сохранить, а 
затем, при запуске программы, восстановить; данную задачу решает 
сериализация объектов.
</p><p>Сериализовать объект достаточно просто, если он реализует интерфейс <i><b>Serializable</b></i>
 (это интерфейс для самоидентификации, в нем нет ни одного метода). 
Когда в язык был добавлен механизм сериализации, во многие классы 
стандартной библиотеки внесли изменения так, чтобы они были готовы к 
сериализации. К таким классам относятся все классы-оболочки для 
простейших типов, все классы контейнеров и многие другие. Даже объекты 
Class, представляющие классы, можно сериализовать.
</p><p>Чтобы сериализовать объект, требуется создать выходной поток <i><b>OutputStream</b></i>, который нужно вложить в объект <i><b>ObjectOutputStream</b></i>. По сути, вызов метода <i><b>writeObject()</b></i> осуществляет сериализацию объекта, и далее вы пересылаете его в выходной поток данных <i><b>OutputStream</b></i>. Для восстановления объекта необходимо надстроить объект <i><b>ObjectInputStream</b></i> для входного потока <i><b>InputStream</b></i>, а затем вызвать метод <i><b>readObject()</b></i>. Как обычно, такой метод возвращает ссылку на обобщенный объект <i><b>Object</b></i>, поэтому после вызова метода следует провести нисходящее преобразование для получения объекта нужного типа.
</p><p>Сериализация объектов проводится достаточно разумно и в отношении
 ссылок, имеющихся в объекте. Сохраняется не только сам образ объекта, 
но и все связанные с ним объекты, все объекты в связанных объектах, и т.
 д. Это часто называют «паутиной объектов», к которой можно присоединить
 одиночный объект, а также массив ссылок на объекты и объекты-члены. 
Если бы вы создавали свой собственный механизм сериализации, 
отслеживание всех присутствующих в объектах ссылок стало бы весьма 
нелегкой задачей. Однако в <i>Java</i> никаких трудностей со ссылками 
нет — судя по всему, в этот язык встроен достаточно эффективный алгоритм
 создания графов объектов. Следующий пример проверяет механизм 
сериализации: мы создаем цепочку связанных объектов, каждый из которых 
связан со следующим сегментом цепочки, а также имеет массив ссылок на 
объекты другого класса с именем <i><b>Data</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Worm.java</span>
<span class="co1">// Тест сериализации объектов.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Data <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> n<span class="sy0">;</span>
  <span class="kw2">public</span> Data<span class="br0">(</span><span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">n</span> = n<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw21">Integer</span>.<span class="me1">toString</span><span class="br0">(</span>n<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Worm <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> Data<span class="br0">[</span><span class="br0">]</span> d = <span class="br0">{</span>
    <span class="kw2">new</span> Data<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span>,
    <span class="kw2">new</span> Data<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span>,
    <span class="kw2">new</span> Data<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span>
  <span class="br0">}</span><span class="sy0">;</span>
  <span class="kw2">private</span> Worm next<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">char</span> c<span class="sy0">;</span>
  <span class="co1">// Value of i == number of segments</span>
  <span class="kw2">public</span> Worm<span class="br0">(</span><span class="kw3">int</span> i, <span class="kw3">char</span> x<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Worm constructor: "</span> + i<span class="br0">)</span><span class="sy0">;</span>
    c = x<span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>--i <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">)</span>
      next = <span class="kw2">new</span> Worm<span class="br0">(</span>i, <span class="br0">(</span><span class="kw3">char</span><span class="br0">)</span><span class="br0">(</span>x + <span class="nu0">1</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> Worm<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Default constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">StringBuilder</span> result = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="st0">":"</span><span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">append</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">append</span><span class="br0">(</span><span class="st0">"("</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Data dat&nbsp;: d<span class="br0">)</span>
      result.<span class="me1">append</span><span class="br0">(</span>dat<span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">append</span><span class="br0">(</span><span class="st0">")"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span>next <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span>
      result.<span class="me1">append</span><span class="br0">(</span>next<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw21">ClassNotFoundException</span>, <span class="kw20">IOException</span> <span class="br0">{</span>
    Worm w = <span class="kw2">new</span> Worm<span class="br0">(</span><span class="nu0">6</span>, <span class="st0">'a'</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"w = "</span> + w<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> out = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"worm.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span><span class="st0">"Worm storage<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span>w<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Also flushes output</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"worm.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Worm w2 = <span class="br0">(</span>Worm<span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>s + <span class="st0">"w2 = "</span> + w2<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ByteArrayOutputStream</span> bout =
      <span class="kw2">new</span> <span class="kw20">ByteArrayOutputStream</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> out2 = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>bout<span class="br0">)</span><span class="sy0">;</span>
    out2.<span class="me1">writeObject</span><span class="br0">(</span><span class="st0">"Worm storage<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
    out2.<span class="me1">writeObject</span><span class="br0">(</span>w<span class="br0">)</span><span class="sy0">;</span>
    out2.<span class="me1">flush</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectInputStream</span> in2 = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">ByteArrayInputStream</span><span class="br0">(</span>bout.<span class="me1">toByteArray</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    s = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>in2.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Worm w3 = <span class="br0">(</span>Worm<span class="br0">)</span>in2.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>s + <span class="st0">"w3 = "</span> + w3<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w =&nbsp;:a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w2 =&nbsp;:a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w3 =&nbsp;:a(853):b(119):c(802):d(788):e(199):f(881)
</pre>
<p>&lt;/spoiler&gt;
Чтобы пример был интереснее, массив объектов <i><b>Data</b></i> в классе <i><b>Worm</b></i>
 инициализируется случайными числами. (Таким образом, нельзя заподозрить
 компилятор в том, что он использует дополнительную информацию для 
хранения объектов.) Каждый объект <i><b>Worm</b></i> помечается порядковым номером-символом (<i><b>char</b></i>), который автоматически генерируется в процессе рекурсивного формирования связанной цепочки объектов <i><b>Worm</b></i>. При создании цепочки ее размер указывается в конструкторе класса <i><b>Worm</b></i>. Для инициализации ссылки <i><b>next</b></i> рекурсивно вызывается конструктор класса <i><b>Worm</b></i>, однако с каждым разом размер цепочки уменьшается на единицу. В последнем сегменте цепочки ссылка <i><b>next</b></i> остается со значением <i><b>null</b></i>, что указывает на конец цепочки.
</p><p>Все это делалось лишь по одной причине: для создания более или 
менее сложной структуры, которая не может быть сериализована тривиальным
 образом. Впрочем, сам акт сериализации проходит проще простого. После 
создания потока <i><b>ObjectOutputStream</b></i> (на основе другого выходного потока), метод <i><b>writeObject()</b></i> записывает в него объект. Заметьте, что в поток также записывается строка (<i><b>String</b></i>). В этот же поток можно поместить все примитивные типы, используя те же методы, что и в классе <i><b>DataOutputStream</b></i> (оба потока реализуют одинаковый интерфейс).
</p><p>В программе есть два похожих фрагмента кода. В первом запись и 
чтение производится в файл, а во втором для разнообразия хранилищем 
служит массив байтов <i><b>ByteArray</b></i>. Чтение и запись объектов посредством сериализации возможна в любые потоки, в том числе и в сетевые соединения.
</p><p>Из выходных данных видно, что восстановленный объект в самом деле содержит все ссылки, которые были в исходном объекте.
</p><p>Заметьте, что в процессе восстановления объекта, реализующего интерфейс <i><b>Serializable</b></i>,
 никакие конструкторы (даже конструктор по умолчанию) не вызываются. 
Объект восстанавливается целиком и полностью из данных, считанных из 
входного потока <i><b>InputStream</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D0.BD.D0.B0.D1.80.D1.83.D0.B6.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0">Обнаружение класса</span></h3>
<p>Вам может быть интересно, что необходимо для восстановления объекта 
после проведения сериализации. Например, предположим, что вы создали 
объект, сериализовали его и отправили в виде файла или через сетевое 
соединение на другой компьютер. Сумеет ли программа на другом компьютере
 реконструировать объект, опираясь только на те данные, которые были 
записаны в файл в процессе сериализации?
</p><p>Самый надежный способ получить ответ на этот вопрос — провести 
эксперимент. Следующий файл располагается в подкаталоге данной главы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Alien.java</span>
<span class="co1">// Сериализуемый класс.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Alien <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span><span class="br0">}</span></pre></div></div>
<p>Файл с программой, создающей и сериализующей объект Alien, находится в том же подкаталоге:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/FreezeAlien.java</span>
<span class="co1">// Создание файла с данными сериализации.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FreezeAlien <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw20">ObjectOutput</span> out = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"X.file"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    Alien quellek = <span class="kw2">new</span> Alien<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span>quellek<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Вместо того чтобы перехватывать и обрабатывать исключения, программа 
идет по простому пути — исключения передаются за пределы main(), поэтому
 сообщения о них будут выдаваться на консоль.
После того как вы скомпилируете и запустите этот код, в каталоге <i><b>с12</b></i> появится файл с именем <i><b>X.file</b></i>. Следующая программа скрыта от чужих глаз в «секретном» подкаталоге <i><b>xfiles</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/xfiles/ThawAlien.java</span>
<span class="co1">// Попытка восстановления сериализованного файла</span>
<span class="co1">// без сохранения класса объекта в зтом файле.</span>
<span class="co1">// {RunByHand}</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ThawAlien <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="kw2">new</span> <span class="kw20">File</span><span class="br0">(</span><span class="st0">".."</span>, <span class="st0">"X.file"</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">Object</span> mystery = in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>mystery.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>class Alien
</pre>
<p>&lt;/spoiler&gt;
Даже открыв файл и прочитав из него данные для восстановления объекта mystery, виртуальная машина <i>Java</i> <i>JVM</i>) не сможет найти файл <i><b>Alien.class</b></i>; объект <i><b>Class</b></i> для объекта <i><b>Alien</b></i> будет в не досягаемости (в примере сознательно не рассматривается возможность обнаружения через переменную окружения <i><b>CLASSPATH</b></i>). Возникнет исключение <i><b>ClassNotFoundException</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A3.D0.BF.D1.80.D0.B0.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.B5.D1.80.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B5.D0.B9">Управление сериализацией</span></h3>
<p>Как вы могли убедиться, стандартный механизм сериализации достаточно 
прост в применении. Но что, если у вас возникли особые требования? 
Возможно, из соображений безопасности вы не хотите сохранять некоторые 
части вашего объекта, или сериализовать какой-либо объект, содержащийся в
 главном объекте, не имеет смысла, так как немного погодя его все равно 
потребуется создать заново.
Вы можете управлять процессом сериализации, реализуя в своем классе 
интерфейс <i><b>Externalizable</b></i> вместо интерфейса <i><b>Serializable</b></i>. Этот интерфейс расширяет оригинальный интерфейс Serializable и добавляет в него два метода, <i><b>writeExternal()</b></i> и <i><b>readExternal()</b></i>,
 которые автоматически вызываются в процессе сериализации и 
восстановления объектов, позволяя вам попутно выполнить специфические 
действия для конкретного объекта.
</p><p>В следующем примере продемонстрирована простая реализация интерфейса <i><b>Externalizable</b></i>. Заметьте также, что классы <i><b>Blip1</b></i> и <i><b>Blip2</b></i> практически одинаковы, если не считать одного малозаметного отличия:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Blips.java</span>
<span class="co1">// Простая реализация интерфейса Externalizable... с проблемами.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Blip1 <span class="kw2">implements</span> <span class="kw20">Externalizable</span> <span class="br0">{</span>
  <span class="kw2">public</span> Blip1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip1 Constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> writeExternal<span class="br0">(</span><span class="kw20">ObjectOutput</span> out<span class="br0">)</span>
      <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip1.writeExternal"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> readExternal<span class="br0">(</span><span class="kw20">ObjectInput</span> in<span class="br0">)</span>
     <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip1.readExternal"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Blip2 <span class="kw2">implements</span> <span class="kw20">Externalizable</span> <span class="br0">{</span>
  Blip2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip2 Constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> writeExternal<span class="br0">(</span><span class="kw20">ObjectOutput</span> out<span class="br0">)</span>
      <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip2.writeExternal"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> readExternal<span class="br0">(</span><span class="kw20">ObjectInput</span> in<span class="br0">)</span>
     <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip2.readExternal"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Blips <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Constructing objects:"</span><span class="br0">)</span><span class="sy0">;</span>
    Blip1 b1 = <span class="kw2">new</span> Blip1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Blip2 b2 = <span class="kw2">new</span> Blip2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"Blips.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Saving objects:"</span><span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">writeObject</span><span class="br0">(</span>b1<span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">writeObject</span><span class="br0">(</span>b2<span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now get them back:</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"Blips.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Recovering b1:"</span><span class="br0">)</span><span class="sy0">;</span>
    b1 = <span class="br0">(</span>Blip1<span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// OOPS! Throws an exception:</span>
<span class="co1">//! print("Recovering b2:");</span>
<span class="co1">//! b2 = (Blip2)in.readObject();</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal
</pre>
<p>&lt;/spoiler&gt;
Итак, объект <i><b>BLip2</b></i> в программе не восстанавливается — попытка приводит к возникновению исключения. Заметили ли вы различие между классами <i><b>Blip1</b></i> и <i><b>Вlip2</b></i>? Конструктор класса <i><b>Blip1</b></i> объявлен открытым (<i><b>public</b></i>), в то время как конструктор класса <i><b>Blip2</b></i> таковым не является, и именно это приводит к исключению в процессе восстановления. Попробуйте объявить конструктор класса <i><b>Blip2</b></i> открытым и удалить комментарии <i><b>//!</b></i>, и вы увидите, что все работает, как и было запланировано.
При восстановлении объекта <i><b>b1</b></i> вызывается конструктор по умолчанию класса <i><b>Blip1</b></i>. Это отличается от восстановления объекта, реализующего интерфейс <i><b>Serializable</b></i>, которое проводится на основе данных сериализации, без вызова конструкторов. В случае с объектом <i><b>Externalizable</b></i> происходит нормальный процесс конструирования (включая инициализацию в точке определения), и далее вызывается метод <i><b>readExternal()</b></i>. Вам следует иметь это в виду при реализации объектов <i><b>Externalizable</b></i> — в особенности обратите внимание на то, что вызывается конструктор по умолчанию.
Следующий пример показывает, что надо сделать для полноты операций сохранения и восстановления объекта <i><b>Externalizable</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Blip3.java</span>
<span class="co1">// Восстановление объекта Externalizable.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Blip3 <span class="kw2">implements</span> <span class="kw20">Externalizable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> s<span class="sy0">;</span> <span class="co1">// No initialization</span>
  <span class="kw2">public</span> Blip3<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip3 Constructor"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// s, i not initialized</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> Blip3<span class="br0">(</span><span class="kw21">String</span> x, <span class="kw3">int</span> a<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip3(String x, int a)"</span><span class="br0">)</span><span class="sy0">;</span>
    s = x<span class="sy0">;</span>
    i = a<span class="sy0">;</span>
    <span class="co1">// s &amp; i initialized only in non-default constructor.</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> s + i<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> writeExternal<span class="br0">(</span><span class="kw20">ObjectOutput</span> out<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip3.writeExternal"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// You must do this:</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeInt</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> readExternal<span class="br0">(</span><span class="kw20">ObjectInput</span> in<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Blip3.readExternal"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// You must do this:</span>
    s = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    i = in.<span class="me1">readInt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Constructing objects:"</span><span class="br0">)</span><span class="sy0">;</span>
    Blip3 b3 = <span class="kw2">new</span> Blip3<span class="br0">(</span><span class="st0">"A String "</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>b3<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"Blip3.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Saving object:"</span><span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">writeObject</span><span class="br0">(</span>b3<span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now get it back:</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"Blip3.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Recovering b3:"</span><span class="br0">)</span><span class="sy0">;</span>
    b3 = <span class="br0">(</span>Blip3<span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>b3<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Constructing objects:
Blip3(String x, int a)
A String 47
Saving object:
Blip3.writeExternal
Recovering b3:
Blip3 Constructor
Blip3.readExternal
A String 47
</pre>
<p>&lt;/spoiler&gt;
Поля <i><b>s</b></i> и <i><b>і</b></i> инициализируются только во втором конструкторе, но не в конструкторе по умолчанию. Это значит, что, если переменные <i><b>s</b></i> и <i><b>і</b></i> не будут инициализированы в методе <i><b>readExternal()</b></i>, <i><b>s</b></i> останется ссылкой <i><b>null</b></i>, а <i><b>і</b></i>
 будет равно нулю (так как при создании объекта его память обнуляется). 
Если вы закомментируете две строки после фраз Необходимо действовать так
 и запустите программу, то обнаружите, что так оно и будет: в 
восстановленном объекте ссылка s имеет значение <i><b>null</b></i>, а целое <i><b>і</b></i> равно нулю.
Если вы наследуете от объекта, реализующего интерфейс <i><b>Externalizable</b></i>, то при выполнении сериализации следует вызывать методы базового класса <i><b>writeExternal()</b></i> и <i><b>readExternal()</b></i>, чтобы правильно сохранить и восстановить свой объект.
Итак, чтобы сериализация выполнялась правильно, нужно не просто записать всю значимую информацию в методе <i><b>writeExternal()</b></i> (для объектов <i><b>Externalizable</b></i> не существует автоматической записи объектов-членов), но и восстановить ее затем в методе <i><b>readExternal()</b></i>.
 Хотя сначала можно запутаться и подумать, что из-за вызова конструктора
 по умолчанию все необходимые действия по записи и восстановлению 
объектов <i><b>Externalizable</b></i> происходят сами по себе. Но это не так.
</p>
<h3><span class="mw-headline" id=".D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_transient">Ключевое слово transient</span></h3>
<p>При управлении процессом сериализации может возникнуть ситуация, при 
которой автоматическое сохранение и восстановление некоторого подобъекта
 нежелательно — например, если в объекте хранится некоторая 
конфиденциальная информация (пароль и т. д.). Даже если информация в 
объекте описана как закрытая (<i><b>private</b></i>), это не спасает ее 
от сериализации, после которой можно извлечь секретные данные из файла 
или из перехваченного сетевого пакета.
</p><p>Первый способ предотвратить сериализацию некоторой важной части объекта — реализовать интерфейс <i><b>Externalizable</b></i>,
 что уже было показано. Тогда автоматически вообще ничего не 
записывается, и управление отдельными элементами находится в ваших руках
 (внутри <i><b>writeExternal</b></i>).
</p><p>Однако работать с объектами <i><b>Serializable</b></i> удобнее, поскольку сериализация для них проходит полностью автоматически. Чтобы запретить запись некоторых полей объекта <i><b>Serializable</b></i>, воспользуйтесь ключевым словом <i><b>transient</b></i>. Фактически оно означает: «Это не нужно ни сохранять, ни восстанавливать — это мое дело».
</p><p>Для примера возьмем объект <i><b>Login</b></i>, который содержит 
информацию о некотором сеансе входа в систему, с вводом пароля и имени 
пользователя. Предположим, что после проверки информации ее необходимо 
сохранить, выборочно, без пароля. Проще всего удовлетворить заявленным 
требованиям, реализуя интерфейс <i><b>Serializable</b></i> и объявляя поле с паролем <i><b>password</b></i> как <i><b>transient</b></i>. Вот как это будет выглядеть:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/Logon.java</span>
<span class="co1">// Ключевое слово "transient".</span>
<span class="kw2">import</span> <span class="co2">java.util.concurrent.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Logon <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">Date</span> date = <span class="kw2">new</span> <span class="kw166">Date</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> username<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">transient</span> <span class="kw21">String</span> password<span class="sy0">;</span>
  <span class="kw2">public</span> Logon<span class="br0">(</span><span class="kw21">String</span> name, <span class="kw21">String</span> pwd<span class="br0">)</span> <span class="br0">{</span>
    username = name<span class="sy0">;</span>
    password = pwd<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"logon info: <span class="es0">\n</span>   username: "</span> + username +
      <span class="st0">"<span class="es0">\n</span>   date: "</span> + date + <span class="st0">"<span class="es0">\n</span>   password: "</span> + password<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    Logon a = <span class="kw2">new</span> Logon<span class="br0">(</span><span class="st0">"Hulk"</span>, <span class="st0">"myLittlePony"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"logon a = "</span> + a<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"Logon.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">writeObject</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">close</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw47">TimeUnit</span>.<span class="me1">SECONDS</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Delay</span>
    <span class="co1">// Now get them back:</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"Logon.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Recovering object at "</span> + <span class="kw2">new</span> <span class="kw166">Date</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    a = <span class="br0">(</span>Logon<span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"logon a = "</span> + a<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>logon a = logon info:
  username: Hulk
  date: Sat Nov 19 15:03:26 MST 2005
  password: myLittlePony
Recovering object at Sat Nov 19 15:03:28 MST 2005
logon a = logon info:
  username: Hulk
  date: Sat Nov 19 15:03:26 MST 2005
  password: null
</pre>
<p>&lt;/spoiler&gt;
Поля <i><b>date</b></i> и <i><b>username</b></i> не имеют модификатора <i><b>transient</b></i>, поэтому сериализация для них проводится автоматически. Однако поле <i><b>password</b></i> описано как <i><b>transient</b></i> и поэтому не сохраняется на диске; механизм сериализации его также игнорирует. При восстановлении объекта поле <i><b>password</b></i> равно <i><b>null</b></i>. Заметьте, что при соединении строки (<i><b>String</b></i>) со ссылкой <i><b>null</b></i> перегруженным оператором + ссылка <i><b>null</b></i> автоматически преобразуется в строку <i><b>null</b></i>.
Также видно, что поле <i><b>date</b></i> сохраняется на диске и при восстановлении его значение не меняется.
Так как объекты <i><b>Externalizable</b></i> по умолчанию не сохраняют полей, ключевое слово <i><b>transient</b></i> для них не имеет смысла. Оно применяется только для объектов <i><b>Serializable</b></i>.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.90.D0.BB.D1.8C.D1.82.D0.B5.D1.80.D0.BD.D0.B0.D1.82.D0.B8.D0.B2.D0.B0_.D0.B4.D0.BB.D1.8F_Externalizable">Альтернатива для Externalizable</span></h3>
<p>Если вас по каким-либо причинам не прельщает реализация интерфейса <i><b>Externalizable</b></i>, существует и другой подход. Вы можете реализовать интерфейс <i><b>Serializable</b></i> и добавить (заметьте, что я сказал «добавить», а не «переопределить» или «реализовать») методы с именами <i><b>writeObject()</b></i> и <i><b>readObject()</b></i>.
 Они автоматически вызываются при сериализации и восстановлении 
объектов. Иначе говоря, эти два метода заменят собой сериализацию по 
умолчанию.
Эти методы должны иметь жестко фиксированную сигнатуру:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">private</span> <span class="kw3">void</span> writeObject<span class="br0">(</span><span class="kw20">ObjectOutputStream</span> stream<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span><span class="sy0">;</span>
 <span class="kw2">private</span> <span class="kw3">void</span> readObject<span class="br0">(</span><span class="kw20">ObjectInputStream</span> stream<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span></pre></div></div>
<p>С точки зрения проектирования программы этот подход вообще непонятен.
 Во-первых, можно подумать, что, раз уж эти методы не являются частью 
базового класса и не определены в интерфейсе <i><b>Serializable</b></i>, у них должен быть свой собственный интерфейс. Но так как методы объявлены закрытыми (<i><b>private</b></i>),
 вызываться они могут лишь членами их собственного класса. Однако члены 
обычных классов их не вызывают, вместо этого вызов исходит из методов <i><b>writeObject()</b></i> и <i><b>readObject()</b></i> классов <i><b>ObjectInputStream</b></i> и <i><b>ObjectOutputStream</b></i>.
 (Я не стану разражаться долгой тирадой о выборе тех же имен методов, а 
скажу лишь одно слово: неразумно.) Интересно, каким образом классы <i><b>ObjectInputStream</b></i> и <i><b>ObjectOutputStream</b></i> обращаются к закрытым членам другого класса? Можно лишь предположить, что это относится к таинству сериализации.
</p><p>Так или иначе, все методы, описанные в интерфейсе, реализуются как открытые (<i><b>public</b></i>), поэтому, если методы <i><b>writeObject()</b></i> и <i><b>readObject()</b></i> должны быть закрытыми (<i><b>private</b></i>),
 они не могут быть частью какого-либо интерфейса. Однако вам необходимо 
строго следовать указанной нотации, и результат очень похож на 
реализацию интерфейса.
</p><p>Судя по всему, при вызове метода <i><b>ObjectOutputStream.writeObject()</b></i> передаваемый ему объект <i><b>Serializable</b></i> тщательно анализируется (вне всяких сомнений, с использованием механизма рефлексии) в поисках его собственного метода <i><b>writeObject()</b></i>. Если такой метод существует, процесс стандартной сериализации пропускается, и вызывается метод объекта <i><b>writeObject(</b></i>). Аналогичные действия происходят и при восстановлении объекта.
</p><p>Существует и еще одна хитрость. В вашем собственном методе <i><b>writeObject()</b></i> можно вызвать используемый в обычной сериализации метод <i><b>writeObject()</b></i>, для этого вызывается метод <i><b>defaultWriteObject()</b></i>. Аналогично, в методе <i><b>readObject()</b></i> можно вызвать метод стандартного восстановления <i><b>defaultReadObject()</b></i>. Следующий пример показывает, как производится пользовательское управление хранением и восстановлением объектов <i><b>Serializable</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/SerialCtl.java</span>
<span class="co1">// Управление сериализацией с определением собственных </span>
<span class="co1">// методов writeObject() и readObject() </span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SerialCtl <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> a<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">transient</span> <span class="kw21">String</span> b<span class="sy0">;</span>
  <span class="kw2">public</span> SerialCtl<span class="br0">(</span><span class="kw21">String</span> aa, <span class="kw21">String</span> bb<span class="br0">)</span> <span class="br0">{</span>
    a = <span class="st0">"Not Transient: "</span> + aa<span class="sy0">;</span>
    b = <span class="st0">"Transient: "</span> + bb<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> a + <span class="st0">"<span class="es0">\n</span>"</span> + b<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">void</span> writeObject<span class="br0">(</span><span class="kw20">ObjectOutputStream</span> stream<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span>
    stream.<span class="me1">defaultWriteObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    stream.<span class="me1">writeObject</span><span class="br0">(</span>b<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">void</span> readObject<span class="br0">(</span><span class="kw20">ObjectInputStream</span> stream<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    stream.<span class="me1">defaultReadObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    b = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>stream.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    SerialCtl sc = <span class="kw2">new</span> SerialCtl<span class="br0">(</span><span class="st0">"Test1"</span>, <span class="st0">"Test2"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Before:<span class="es0">\n</span>"</span> + sc<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ByteArrayOutputStream</span> buf= <span class="kw2">new</span> <span class="kw20">ByteArrayOutputStream</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>buf<span class="br0">)</span><span class="sy0">;</span>
    o.<span class="me1">writeObject</span><span class="br0">(</span>sc<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now get it back:</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">ByteArrayInputStream</span><span class="br0">(</span>buf.<span class="me1">toByteArray</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    SerialCtl sc2 = <span class="br0">(</span>SerialCtl<span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"After:<span class="es0">\n</span>"</span> + sc2<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Before:
Not Transient: Test1
Transient: Test2
After:
Not Transient: Test1
Transient: Test2
</pre>
<p>&lt;/spoiler&gt;
В данном примере одно из строковых полей класса объявлено с ключевым словом <i><b>transient</b></i>, чтобы продемонстрировать, что такие поля при вызове метода <i><b>defaultWriteObject()</b></i>
 не сохраняются. Строка сохраняется и восстанавливается программой явно.
 Поля класса инициализируются в конструкторе, а не в точке определения; 
это демонстрирует, что они не инициализируются каким-либо автоматическим
 механизмом в процессе восстановления. Если вы собираетесь использовать 
встроенный механизм сериализации для записи обычных (He-<i><b>transient</b></i>) составляющих объекта, нужно при записи объекта в первую очередь вызвать метод <i><b>defaultWriteObject()</b></i>, а при восстановлении объекта — метод <i><b>defaultReadObject()</b></i>. Это вообще загадочные методы. Например, если вызвать метод <i><b>defaultWriteObject()</b></i> для потока <i><b>ObjectOutputStream</b></i>
 без передачи аргументов, он все же как-то узнает, какой объект надо 
записать, где находится ссылка на него и как записать все его He-<i><b>transient</b></i> составляющие. Мистика.
</p><p>Сохранение и восстановление <i><b>transient</b></i>-объектов выполняется относительно просто. В методе <i><b>main()</b></i> создается объект <i><b>SerialCtl</b></i>, который затем сериализуется потоком <i><b>ObjectOutputStream</b></i>. (При этом для вывода используется буфер, а не файл — для потока <i><b>ObjectOutputStream</b></i> это несущественно.) Непосредственно сериализация выполняется в строке
</p>
<pre>о.writeObject(sc);
</pre>
<p>Метод <i><b>writeObject()</b></i> должен определить, имеется ли в объекте <i><b>sc</b></i> свой собственный метод <i><b>writeObject()</b></i>.
 (При этом проверка на наличие интерфейса или класса не проводится — их 
нет — поиск метода проводится с помощью рефлексии.) Если поиск успешен, 
найденный метод вовлекается в процедуру сериализации. Примерно такой же 
подход наблюдается и при восстановлении объекта методом <i><b>readObject()</b></i>. Возможно, это единственное решение задачи, но все равно выглядит очень странно.
</p>
<h3><span class="mw-headline" id=".D0.94.D0.BE.D0.BB.D0.B3.D0.BE.D0.B2.D1.80.D0.B5.D0.BC.D0.B5.D0.BD.D0.BD.D0.BE.D0.B5_.D1.85.D1.80.D0.B0.D0.BD.D0.B5.D0.BD.D0.B8.D0.B5">Долговременное хранение</span></h3>
<p>Было бы замечательно привлечь технологию сериализации, чтобы 
сохранить состояние вашей программы для его последующего восстановления.
 Но перед тем как это делать, необходимо ответить на несколько вопросов.
 Что произойдет при сохранении двух объектов, содержащих ссылку на 
некоторый общий третий объект? Когда вы восстановите эти объекты, 
сколько экземпляров третьего объекта появится в программе? А если вы 
сохраните объекты в отдельных файлах, а затем десериализуете их в разных
 частях программы? Следующий пример демонстрирует возможные проблемы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/MyWorld.java</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> House <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Animal <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
  <span class="kw2">private</span> House preferredHouse<span class="sy0">;</span>
  Animal<span class="br0">(</span><span class="kw21">String</span> nm, House h<span class="br0">)</span> <span class="br0">{</span>
    name = nm<span class="sy0">;</span>
    preferredHouse = h<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> name + <span class="st0">"["</span> + <span class="kw2">super</span>.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"], "</span> + preferredHouse + <span class="st0">"<span class="es0">\n</span>"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> MyWorld <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span>, <span class="kw21">ClassNotFoundException</span> <span class="br0">{</span>
    House house = <span class="kw2">new</span> House<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span> animals = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Animal<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    animals.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> Animal<span class="br0">(</span><span class="st0">"Bosco the dog"</span>, house<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    animals.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> Animal<span class="br0">(</span><span class="st0">"Ralph the hamster"</span>, house<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    animals.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> Animal<span class="br0">(</span><span class="st0">"Molly the cat"</span>, house<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"animals: "</span> + animals<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ByteArrayOutputStream</span> buf1 =
      <span class="kw2">new</span> <span class="kw20">ByteArrayOutputStream</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o1 = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>buf1<span class="br0">)</span><span class="sy0">;</span>
    o1.<span class="me1">writeObject</span><span class="br0">(</span>animals<span class="br0">)</span><span class="sy0">;</span>
    o1.<span class="me1">writeObject</span><span class="br0">(</span>animals<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Write a 2nd set</span>
    <span class="co1">// Write to a different stream:</span>
    <span class="kw20">ByteArrayOutputStream</span> buf2 =
      <span class="kw2">new</span> <span class="kw20">ByteArrayOutputStream</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectOutputStream</span> o2 = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>buf2<span class="br0">)</span><span class="sy0">;</span>
    o2.<span class="me1">writeObject</span><span class="br0">(</span>animals<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Now get them back:</span>
    <span class="kw20">ObjectInputStream</span> in1 = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">ByteArrayInputStream</span><span class="br0">(</span>buf1.<span class="me1">toByteArray</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw20">ObjectInputStream</span> in2 = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">ByteArrayInputStream</span><span class="br0">(</span>buf2.<span class="me1">toByteArray</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span>
      animals1 = <span class="br0">(</span><span class="kw166">List</span><span class="br0">)</span>in1.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span>,
      animals2 = <span class="br0">(</span><span class="kw166">List</span><span class="br0">)</span>in1.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span>,
      animals3 = <span class="br0">(</span><span class="kw166">List</span><span class="br0">)</span>in2.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"animals1: "</span> + animals1<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"animals2: "</span> + animals2<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"animals3: "</span> + animals3<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>animals: [Bosco the dog[Animal@addbf1], House@42e816
, Ralph the hamster[Animal@9304b1], House@42e816
, Molly the cat[Animal@190d11], House@42e816
]
</pre>
<p>&lt;/spoiler&gt;
В этом примере стоит обратить внимание на использование механизма 
сериализации и байтового массива для «глубокого копирования» любого 
объекта с интерфейсом <i><b>Serializable</b></i>. (Глубокое копирование — создание дубликата всего графа объектов, а не просто основного объекта и его ссылок.)
</p><p>Объекты <i><b>Animal</b></i> содержат поля типа <i><b>House</b></i>. В методе <i><b>main()</b></i> создается список <i><b>ArrayList</b></i> с несколькими объектами <i><b>Animal</b></i>,
 его дважды записывают в один поток и еще один раз — в отдельный поток. 
Когда эти списки восстанавливают и рас­печатывают, получается 
приведенный ранее результат (объекты при каждом запуске программы будут 
располагаться в различных областях памяти).
</p><p>Конечно, нет ничего удивительного в том, что восстановленные 
объекты и их оригиналы будут иметь разные адреса. Но заметьте тот факт, 
что адреса в восстановленных объектах <i><b>animals1</b></i> и <i><b>animals2</b></i> совпадают, вплоть до повторения ссылок на объект House, общий для обоих списков. С другой стороны, при восстановлении списка <i><b>animals3</b></i>
 система не имеет представления о том, что находящиеся в них объекты уже
 были восстановлены и имеются в программе, поэтому она создает 
совершенно иное семейство взаимосвязанных объектов.
Если вы будете проводить сериализацию с использованием единого выходного
 потока, сохраненная сеть объектов гарантированно восстановится в 
первоначальном виде, без излишних повторений объектов. Конечно, записать
 объекты можно тогда, когда они еще не приняли окончательного состояния,
 но это уже на вашей совести — сохраненные объекты останутся в том 
состоянии, в котором вы их записали (с теми связями, что у них были на 
момент сериализации).
Если уж необходимо зафиксировать состояние системы, безопаснее всего 
сделать это в рамках «атомарной» операции. Если вы сохраняете что-то, 
затем выполняете какие-то действия, снова сохраняете данные и т. д., у 
вас не получится безопасного хранилища состояния системы. Вместо этого 
следует поместить все объекты, являющиеся слагаемыми состояния системы в
 целом, в контейнер и сохранить этот контейнер единой операцией. Затем 
можно восстановить его вызовом одного метода.
</p><p>Следующий пример — имитатор воображаемой системы 
автоматизированного проектирования (CAD), в котором используется такой 
подход. Вдобавок в нем продемонстрировано сохранение статических (<i><b>static</b></i>) нолей — если вы взглянете на документацию <i>JDK</i>, то увидите, что класс <i><b>Class</b></i> реализует интерфейс <i><b>Serializable</b></i>, поэтому для сохранения статических данных достаточно сохранить объект <i><b>Class</b></i>. Это достаточно разумное решение.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/StoreCADState.java</span>
<span class="co1">// Сохранение состояния вымышленной системы CAD.</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">abstract</span> <span class="kw2">class</span> <span class="kw6">Shape</span> <span class="kw2">implements</span> <span class="kw20">Serializable</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> RED = <span class="nu0">1</span>, BLUE = <span class="nu0">2</span>, GREEN = <span class="nu0">3</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> xPos, yPos, dimension<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw3">void</span> setColor<span class="br0">(</span><span class="kw3">int</span> newColor<span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">abstract</span> <span class="kw3">int</span> getColor<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw6">Shape</span><span class="br0">(</span><span class="kw3">int</span> xVal, <span class="kw3">int</span> yVal, <span class="kw3">int</span> dim<span class="br0">)</span> <span class="br0">{</span>
    xPos = xVal<span class="sy0">;</span>
    yPos = yVal<span class="sy0">;</span>
    dimension = dim<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> getClass<span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">"color["</span> + getColor<span class="br0">(</span><span class="br0">)</span> + <span class="st0">"] xPos["</span> + xPos +
      <span class="st0">"] yPos["</span> + yPos + <span class="st0">"] dim["</span> + dimension + <span class="st0">"]<span class="es0">\n</span>"</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw6">Shape</span> randomFactory<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw3">int</span> xVal = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> yVal = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> dim = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">switch</span><span class="br0">(</span>counter++ <span class="sy0">%</span> <span class="nu0">3</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw1">default</span>:
      <span class="kw1">case</span> <span class="nu0">0</span>: <span class="kw2">return</span> <span class="kw2">new</span> Circle<span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">case</span> <span class="nu0">1</span>: <span class="kw2">return</span> <span class="kw2">new</span> Square<span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
      <span class="kw1">case</span> <span class="nu0">2</span>: <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw99">Line</span><span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Circle <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> color = RED<span class="sy0">;</span>
  <span class="kw2">public</span> Circle<span class="br0">(</span><span class="kw3">int</span> xVal, <span class="kw3">int</span> yVal, <span class="kw3">int</span> dim<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> setColor<span class="br0">(</span><span class="kw3">int</span> newColor<span class="br0">)</span> <span class="br0">{</span> color = newColor<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getColor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> color<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Square <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> color<span class="sy0">;</span>
  <span class="kw2">public</span> Square<span class="br0">(</span><span class="kw3">int</span> xVal, <span class="kw3">int</span> yVal, <span class="kw3">int</span> dim<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
    color = RED<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> setColor<span class="br0">(</span><span class="kw3">int</span> newColor<span class="br0">)</span> <span class="br0">{</span> color = newColor<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getColor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> color<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> <span class="kw99">Line</span> <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> color = RED<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span>
  serializeStaticState<span class="br0">(</span><span class="kw20">ObjectOutputStream</span> os<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span> os.<span class="me1">writeInt</span><span class="br0">(</span>color<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span>
  deserializeStaticState<span class="br0">(</span><span class="kw20">ObjectInputStream</span> os<span class="br0">)</span>
  <span class="kw2">throws</span> <span class="kw20">IOException</span> <span class="br0">{</span> color = os.<span class="me1">readInt</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw99">Line</span><span class="br0">(</span><span class="kw3">int</span> xVal, <span class="kw3">int</span> yVal, <span class="kw3">int</span> dim<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>xVal, yVal, dim<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> setColor<span class="br0">(</span><span class="kw3">int</span> newColor<span class="br0">)</span> <span class="br0">{</span> color = newColor<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> getColor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> color<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> StoreCADState <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">Class</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw6">Shape</span><span class="sy0">&gt;&gt;</span> shapeTypes =
      <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">Class</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw6">Shape</span><span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Add references to the class objects:</span>
    shapeTypes.<span class="me1">add</span><span class="br0">(</span>Circle.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    shapeTypes.<span class="me1">add</span><span class="br0">(</span>Square.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    shapeTypes.<span class="me1">add</span><span class="br0">(</span><span class="kw99">Line</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw6">Shape</span><span class="sy0">&gt;</span> shapes = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw6">Shape</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Make some shapes:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      shapes.<span class="me1">add</span><span class="br0">(</span><span class="kw6">Shape</span>.<span class="me1">randomFactory</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Set all the static colors to GREEN:</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="br0">(</span><span class="br0">(</span><span class="kw6">Shape</span><span class="br0">)</span>shapes.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span><span class="br0">)</span>.<span class="me1">setColor</span><span class="br0">(</span><span class="kw6">Shape</span>.<span class="me1">GREEN</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Save the state vector:</span>
    <span class="kw20">ObjectOutputStream</span> out = <span class="kw2">new</span> <span class="kw20">ObjectOutputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileOutputStream</span><span class="br0">(</span><span class="st0">"CADState.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span>shapeTypes<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw99">Line</span>.<span class="me1">serializeStaticState</span><span class="br0">(</span>out<span class="br0">)</span><span class="sy0">;</span>
    out.<span class="me1">writeObject</span><span class="br0">(</span>shapes<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Display the shapes:</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>shapes<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[class Circlecolor[3] xPos[58] yPos[55] dim[93]
, class Squarecolor[3] xPos[61] yPos[61] dim[29]
, class Linecolor[3] xPos[68] yPos[0] dim[22]
, class Circlecolor[3] xPos[7] yPos[88] dim[28]
, class Squarecolor[3] xPos[51] yPos[89] dim[9]
, class Linecolor[3] xPos[78] yPos[98] dim[61]
, class Circlecolor[3] xPos[20] yPos[58] dim[16]
, class Squarecolor[3] xPos[40] yPos[11] dim[22]
, class Linecolor[3] xPos[4] yPos[83] dim[6]
, class Circlecolor[3] xPos[75] yPos[10] dim[42]
]
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Shape</b></i> реализует интерфейс <i><b>Serializable</b></i>, поэтому все унаследованные от него классы по определению поддерживают сериализацию и восстановление. В каждой фигуре <i><b>Shape</b></i> содержатся некоторые данные, и в каждом унаследованном от <i><b>Shape</b></i> классе имеется статическое (<i><b>static</b></i>)
 поле, которое определяет цвет фигуры. (Если бы мы поместили статическое
 поле в базовый класс, то получили бы одно поле для всех фигур, 
поскольку статические поля в производных классах не копируются.) Для 
задания цвета некоторого типа фигур можно переопределить методы базового
 класса (статические методы не используют динамическое связывание). 
Метод <i><b>randomFactory()</b></i> создает при каждом вызове новую фигуру, используя для этого случайные значения <i><b>Shape</b></i>.
Классы <i><b>Circle</b></i> и <i><b>Square</b></i> — простые подклассы Shape, различающиеся только способом инициализации поля <i><b>color</b></i>: окружность (<i><b>Circle</b></i>) задает значение этого поля в месте определения, а прямоугольник (<i><b>Square</b></i>) инициализирует его в кон­структоре. Класс <i><b>Line</b></i> мы обсудим чуть позже.
В методе <i><b>main()</b></i> один список <i><b>ArrayList</b></i> используется для хранения объектов <i><b>Class</b></i>, а другой — для хранения фигур.
Восстановление объектов выполняется вполне тривиально:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/RecoverCADState.java</span>
<span class="co1">// Восстановление состояния вымышленной системы CAD.</span>
<span class="co1">// {RunFirst: StoreCADState}</span>
<span class="kw2">import</span> <span class="co2">java.io.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> RecoverCADState <span class="br0">{</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw20">ObjectInputStream</span> in = <span class="kw2">new</span> <span class="kw20">ObjectInputStream</span><span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw20">FileInputStream</span><span class="br0">(</span><span class="st0">"CADState.out"</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Read in the same order they were written:</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">Class</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw6">Shape</span><span class="sy0">&gt;&gt;</span> shapeTypes =
      <span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">Class</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw6">Shape</span><span class="sy0">&gt;&gt;</span><span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw99">Line</span>.<span class="me1">deserializeStaticState</span><span class="br0">(</span>in<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw6">Shape</span><span class="sy0">&gt;</span> shapes = <span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw6">Shape</span><span class="sy0">&gt;</span><span class="br0">)</span>in.<span class="me1">readObject</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>shapes<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[class Circlecolor[1] xPos[58] yPos[55] dim[93]
, class Squarecolor[0] xPos[61] yPos[61] dim[29]
, class Linecolor[3] xPos[68] yPos[0] dim[22]
, class Circlecolor[1] xPos[7] yPos[88] dim[28]
, class Squarecolor[0] xPos[51] yPos[89] dim[9]
, class Linecolor[3] xPos[78] yPos[98] dim[61]
, class Circlecolor[1] xPos[20] yPos[58] dim[16]
, class Squarecolor[0] xPos[40] yPos[11] dim[22]
, class Linecolor[3] xPos[4] yPos[83] dim[6]
, class Circlecolor[1] xPos[75] yPos[10] dim[42]
]
</pre>
<p>&lt;/spoiler&gt;
Мы видим, что значения переменных <i><b>xPos</b></i>, <i><b>уPos</b></i> и <i><b>dim</b></i>
 сохранились и были успешно восстановлены, однако при восстановлении 
статической информации произошло что-то странное. При записи все 
статические поля <i><b>color</b></i> имели значение <i>3</i>, но восстановление дало другие результаты. В окружностях значением стала единица (то есть константа <i><b>RED</b></i>), а в прямоугольниках поля <i><b>color</b></i>
 вообще равны нулю (помните, в этих объектах инициализация проходит в 
конструкторе). Похоже, статические поля вообще не сериализовались! Да, 
это именно так — хотя класс <i><b>Class</b></i> и реализует интерфейс <i><b>Serializable</b></i>,
 происходит это не так, как нам хотелось бы. Отсюда, если вам 
понадобится сохранить статические значения, делайте это самостоятельно.
</p><p>Именно для этой цели предназначены методы <i><b>serializeStaticState()</b></i> и <i><b>deserializeStaticState()</b></i>
 класса Line. Вы можете видеть, как они вызываются в процессе сохранения
 и восстановления системы. (Заметьте, порядок действий при сохранении 
информации должен соблюдаться и при ее десериализации.) Поэтому для 
правильного выполнения этих программ необходимо сделать следующее:
</p>
<hr>
<ul>
<li>Добавьте методы <i><b>sеrializeStaticState()</b></i> и <i><b>deserializeStaticState()</b></i> во все фигуры <i><b>Shape</b></i>.
</li>
<li>Уберите из программы список <i><b>shapeTypes</b></i> и весь связанный с ним код.
</li>
<li>При сериализации и восстановлении вызывайте новые методы для сохранения статической информации.
</li>
</ul>
<hr>
<p>Также стоит позаботиться о безопасности, ведь сериализация сохраняет и закрытые (<i><b>private</b></i>) поля. Если в вашем объекте имеется конфиденциальная информация, ее необходимо пометить как <i><b>transient</b></i>.
 Но в таком случае придется подумать о безопасном способе хранения такой
 информации, ведь при восстановлении объекта необходимо восстанавливать 
все его данные.
</p><p>Предпочтения
</p>
<pre>Circlecolor[l] xPos[20] yPos[58] dim[16] Squarecolor[0] xPos[40] yPos[ll] dim[22] 
Linecolor[3] xPos[4]  yPos[83] dim[6] Circlecolor[l] xPos[75] yPos[10] dim[42]
</pre>
<p>В пакете <i>JDK</i>-1.4 появился программный интерфейс <i>АРІ</i> для работы с предпочтениями (<i>preferences</i>).
 Предпочтения гораздо более тесно связаны с долговременным хранением, 
чем механизм сериализации объектов, поскольку они позволяют 
автоматически сохранять и восстанавливать вашу информацию. Однако они 
применимы лишь к небольшим, ограниченным наборам данных — хранить в них 
можно только примитивы и строки, и длина строки не должна превышать 8 
Кбайт (не так уж мало, но вряд ли подойдет для решения серьезных задач).
 Как и предполагает название нового API, предпочтения предназначены для 
хранения и получения информации о предпочтениях пользователя и 
конфигурации программы.
Предпочтения представляют собой наборы пар «ключ-значение» (как в 
картах), образующих иерархию узлов. Хотя иерархия узлов и годится для 
построения сложных структур, чаще всего создают один узел, имя которого 
совпадает с именем класса, и хранят информацию в нем. Простой пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: io/PreferencesDemo.java</span>
<span class="kw2">import</span> <span class="co2">java.util.prefs.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PreferencesDemo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="kw2">throws</span> <span class="kw21">Exception</span> <span class="br0">{</span>
    <span class="kw52">Preferences</span> prefs = <span class="kw52">Preferences</span>
      .<span class="me1">userNodeForPackage</span><span class="br0">(</span>PreferencesDemo.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    prefs.<span class="me1">put</span><span class="br0">(</span><span class="st0">"Location"</span>, <span class="st0">"Oz"</span><span class="br0">)</span><span class="sy0">;</span>
    prefs.<span class="me1">put</span><span class="br0">(</span><span class="st0">"Footwear"</span>, <span class="st0">"Ruby Slippers"</span><span class="br0">)</span><span class="sy0">;</span>
    prefs.<span class="me1">putInt</span><span class="br0">(</span><span class="st0">"Companions"</span>, <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    prefs.<span class="me1">putBoolean</span><span class="br0">(</span><span class="st0">"Are there witches?"</span>, <span class="kw4">true</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw3">int</span> usageCount = prefs.<span class="me1">getInt</span><span class="br0">(</span><span class="st0">"UsageCount"</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
    usageCount++<span class="sy0">;</span>
    prefs.<span class="me1">putInt</span><span class="br0">(</span><span class="st0">"UsageCount"</span>, usageCount<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> key&nbsp;: prefs.<span class="me1">keys</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      print<span class="br0">(</span>key + <span class="st0">": "</span>+ prefs.<span class="me1">get</span><span class="br0">(</span>key, <span class="kw4">null</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// You must always provide a default value:</span>
    print<span class="br0">(</span><span class="st0">"How many companions does Dorothy have? "</span> +
      prefs.<span class="me1">getInt</span><span class="br0">(</span><span class="st0">"Companions"</span>, <span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>Location: Oz
Footwear: Ruby Slippers
Companions: 4
Are there witches?: true
UsageCount: 53
How many companions does Dorothy have? 4
</pre>
<p>&lt;/spoiler&gt;
Здесь используется метод <i><b>userNodeForPackage()</b></i>, но с тем же успехом можно было бы заменить его методом <i><b>systemNodeForPackage()</b></i>, это дело вкуса. Предполагается, что префикс user используется для хранения индивидуальных пред­почтений пользователя, a <i><b>system</b></i> — для хранения информации общего плана о настройках установки. Так как метод <i><b>main()</b></i> статический, для идентификации узла применен класс <i><b>PreferencesDemo.class</b></i>, хотя в нестатических методах обычно вызывается метод <i><b>getClass()</b></i>. Использовать текущий класс для идентификации узла не обязательно, но чаще всего именно так и поступают.
</p><p>Созданный узел используется для хранения или считывания 
информации. В данном примере в узел помещаются различные данные, после 
вызывается метод <i><b>keys()</b></i>. Последний возвращает массив строк <i><b>String[]</b></i>, что может быть непривычно, если вы привыкли использовать метод <i><b>keys()</b></i> в коллекциях. Обратите внимание на второй аргумент метода <i><b>get()</b></i>.
 Это значение по умолчанию, которое будет возвращено, если для данного 
ключа не будет найдено значение. При переборе множества ключей мы знаем,
 что каждому из них сопоставлено значение, поэтому передача <i><b>null</b></i> по умолчанию безопасна, но обычно используется именованный ключ:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> prefs.<span class="me1">getInt</span><span class="br0">(</span><span class="st0">"Companions "</span>. <span class="nu0">0</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>В таких ситуациях стоит обзавестись имеющим смысл значением по 
умолчанию. В качестве характерного средства выражения часто выступает 
следующего рода конструкция:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw3">int</span> usageCount = prefs.<span class="me1">getlntC</span><span class="st0">"UsageCount"</span>, <span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
 usageCount++<span class="sy0">;</span>
 prefs.<span class="me1">putlnt</span><span class="br0">(</span><span class="st0">"UsageCount"</span>. <span class="me1">usageCount</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>В этом случае при первом запуске программы значение переменной <i><b>usageCount</b></i> будет нулем, а при последующих запусках оно должно измениться.
</p><p>Запустив программу <i><b>PreferencesDemo.java</b></i>, вы увидите, что значение <i><b>usageCount</b></i>
 действительно увеличивается при каждом запуске программы, но где же 
хранятся данные? Никакие локальные файлы после запуска программы не 
создаются. Система предпочтений привлекает для хранения данных системные
 ресурсы, а конкретная реализация зависит от операционной системы. 
Например, в Windows используется реестр (поскольку он и так представляет
 собой иерархию узлов с набором пар «ключ-значение»). С точки зрения 
программиста, реализация — это несущественно: информация сохраняется 
«сама собой», и вам не приходится беспокоиться о том, как это работает 
на различных системах.
</p><p>Программный интерфейс предпочтений обладает гораздо большим 
возможностями, чем было показано в этом разделе. За более подробным 
описанием обратитесь к документации <i>JDK</i>, этот вопрос там описан достаточно подробно.
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5">Резюме</span></h2>
<p>Библиотека ввода/вывода <i>Java</i> удовлетворяет всем основным 
потребностям: она позволяет выполнять операции чтения и записи с 
консолью, файлами, буфером в памяти и даже сетевыми подключениями к 
Интернету. Наследование позволяет создавать новые типы объектов для 
ввода и вывода данных. Вы даже можете обеспечить расширяемость для 
объектов потока, использовав тот факт, что переопределенный метод <i><b>toString()</b></i> автоматически вызывается при передаче объекта методу, ожидающему <i><b>String</b></i> (ограниченное «автоматическое преобразование типов» <i>Java</i>).
</p><p>Впрочем, ответы на некоторые вопросы не удается найти ни в документации, ни в архитектуре библиотеки ввода/вывода <i>Java</i>.
 Например, было бы замечательно, если бы при попытке перезаписи файла 
возбуждалось исключение — многие программные системы позволяют указать, 
что файл может быть открыт для вывода только тогда, когда файла с тем же
 именем еще не существует. В языке <i>Java</i> проверка существования файла возможна лишь с помощью объекта <i><b>File</b></i>, поскольку если вы откроете файл как <i><b>FileOutputStream</b></i> или <i><b>FileWriter</b></i>, старый файл всегда будет стерт.
</p><p>При знакомстве с библиотекой ввода/вывода возникают смешанные 
чувства; с одной стороны, она берёт на себя значительный объем работы и к
 тому же обеспечивает переносимость. Но пока вы не вполне поняли суть 
работы шаблона декоратора, архитектура библиотеки кажется не совсем 
понятной, и от вас потребуются определенные усилия для ее изучения и 
освоения. Кроме того, библиотека не совсем полна: например, только 
отсутствие необходимых средств заставило меня писать инструменты, 
подобные <i><b>TextFile</b></i> (новый класс <i>Java</i> <i>SE5</i> <i><b>PrintWriter</b></i> — шаг в правильном направлении, но это лишь частичное решение). К числу значительных усовершенствований <i>Java</i> <i>SE5</i> следует отнести и то, что в нем появились возможности форматирования вывода, присутствующие практически в любом другом языке.
</p><p>Впрочем, как только вы действительно проникаетесь идеей шаблона 
декоратора и начинаете использовать библиотеку в ситуациях, где 
требуется вся ее гибкость, вы извлекаете из библиотеки все большую 
выгоду, и даже требующийся для надстроек дополнительный код не мешает 
этому.

</p>
                <p><br>
                </p>
                <hr>
                <p><a href="http://wikijava.it-cache.net/index.php" title="Thinking in Java 4th edition">назад в Оглавление</a>
                </p><p><br>
                </p>
<!-- 
NewPP limit report
CPU time usage: 5.561 seconds
Real time usage: 5.586 seconds
Preprocessor visited node count: 671/1000000
Preprocessor generated node count: 1290/1000000
Post‐expand include size: 243/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wjava2-wj_:pcache:idhash:30-0!*!*!!ru!2!* and timestamp 20140813052832
 -->
</div>								<div class="printfooter">
				Источник — «<a href="http://wikijava.org.ua/index.php?title=Glava_16_Thinking_in_Java_4th_edition&amp;oldid=40">http://wikijava.org.ua/index.php?title=Глава_16_Thinking_in_Java_4th_edition&amp;oldid=40</a>»				</div>
                                <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8" title="Категория:Книги">Книги</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:Java" title="Категория:Java">Java</a></li></ul></div></div>												<div class="visualClear"></div>
            </div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Персональные инструменты</h3>
	<ul>
<li id="pt-login"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0+16+Thinking+in+Java+4th+edition" title="Здесь можно зарегистрироваться в системе, но это необязательно. [o]" accesskey="o">Представиться системе</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Пространства имён</h3>
	<ul>
					<!--<li  id="ca-nstab-main" class="selected"><span><a href="index.php@title=Glava_16_Thinking_in_Java_4th_edition.html"  title="Просмотр основной страницы [c]" accesskey="c">Статья</a></span></li>-->
					<!--<li  id="ca-talk" class="new"><span><a href="http://wikijava.org.ua/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;action=edit&amp;redlink=1"  title="Обсуждение основной страницы [t]" accesskey="t">Обсуждение</a></span></li>-->
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Варианты</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Просмотры</h3>
	<ul>
					<!--<li id="ca-view" class="selected"><span><a href="index.php@title=Glava_16_Thinking_in_Java_4th_edition.html" >Читать</a></span></li>-->
					<!--<li id="ca-viewsource"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;action=edit"  title="Эта страница защищена от изменений, но вы можете посмотреть и скопировать её исходный текст [e]" accesskey="e">Просмотр</a></span></li>-->
					<!--<li id="ca-history" class="collapsible"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;action=history"  title="Журнал изменений страницы [h]" accesskey="h">История</a></span></li>-->
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Действия</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_16_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Поиск</label></h3>
	<form action="http://wikijava.org.ua/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Поиск" title="Искать в WikiJava: Wiki of Java: викифицированные книги и статьи по Java [f]" accesskey="f" id="searchInput">						<button type="submit" name="button" title="Найти страницы, содержащие указанный текст" id="searchButton"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/search-ltr.asc" alt="Найти" height="13" width="12"></button>								<input name="title" value="Служебная:Поиск" type="hidden">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<!--<div id="p-logo" role="banner"><a style="background-image: url(/skins/common/images/wikijava.png);" href="index.php@title=Заглавная_страница.html"  title="Перейти на заглавную страницу"></a></div>-->
				<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
	<h3 id="p-navigation-label">Навигация</h3>
	<div class="body">
        <ul>
            <li id="n-mainpage-description"><a href="http://wikijava.org.ua/index.php?title=%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [z]" accesskey="z">Заглавная страница</a></li>
            <li id="n-recentchanges"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [r]" accesskey="r">Свежие правки</a></li>
            <li id="n-.D0.9A.D0.BD.D0.B8.D0.B3.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8_Java">Книги Java</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D1.8C.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D0%B8_Java">Статьи Java</a></li>
            <li id="n-Java-.D0.BF.D0.BE.D1.80.D1.82.D0.B0.D0.BB"><a href="http://wikijava.org.ua/index.php?title=Java-portal">Java портал</a></li>
            <li id="n-help"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Место, где можно получить справку">Справка</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.81.D1.82.D0.B8.D0.BA.D0.B0"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0">Статистика</a></li>
        </ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label">Инструменты</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition" title="Список всех страниц, ссылающихся на данную [j]" accesskey="j">Ссылки сюда</a></li>
			<li id="t-recentchangeslinked"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition" title="Последние изменения в страницах, на которые ссылается эта страница [k]" accesskey="k">Связанные правки</a></li>
			<li id="t-specialpages"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [q]" accesskey="q">Спецстраницы</a></li>
			<li id="t-print"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [p]" accesskey="p">Версия для печати</a></li>
			<li id="t-permalink"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;oldid=40" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
			<li id="t-info"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_16_Thinking_in_Java_4th_edition&amp;action=info">Сведения о странице</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B" aria-labelledby="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">
	<h3 id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">Другие проекты</h3>
	<div class="body">
		<ul>
			<li id="n-rastafara.com.ua"><a href="http://rastafara.com.ua/" rel="nofollow">rastafara.com.ua</a></li>
			<li id="n-rastafara-blog"><a href="http://sergey-rastafara.blogspot.com/" rel="nofollow">rastafara blog</a></li>
			<li id="n-rastaban"><a href="http://rastaban.com.ua/" rel="nofollow">rastaban</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 22:02, 16 февраля 2014.</li>
											<li id="footer-info-viewcount">К этой странице обращались 3587 раза.</li>
											<li id="footer-info-copyright">Содержимое доступно по лицензии <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 или более поздняя</a> (если не указано иное).</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Описание">Описание WikiJava: Wiki of Java: викифицированные книги и статьи по Java</a></li>
											<li id="footer-places-disclaimer"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Отказ от ответственности">Отказ от ответственности</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/copyleft/fdl.html"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/gnu-fdl.png" alt="GNU Free Documentation License 1.3 или более поздняя" height="31" width="88"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2016_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","ext.vector.simpleSearch","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.240 secs. -->
	

</body></html>