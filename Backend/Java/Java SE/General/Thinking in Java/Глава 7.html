<!DOCTYPE html>
<html dir="ltr" class="client-nojs" lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>Глава 7 Thinking in Java 4th edition — WikiJava: Wiki of Java: викифицированные книги и статьи по Java</title>
<meta name="generator" content="MediaWiki 1.22.2">
<link rel="shortcut icon" href="http://wikijava.it-cache.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wikijava.it-cache.net/opensearch_desc.php" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://wikijava.it-cache.net/api.php@action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java&nbsp;— Atom-лента" href="http://wikijava.it-cache.net/index.php@title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F%253A%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="stylesheet" href="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/style3.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wjava2-wj_:resourceloader:filter:minify-css:7:32e7e505403c81fe0a24e297ef166436 */</style>

<script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/style1.css"></script><script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/load.html"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Глава_7_Thinking_in_Java_4th_edition","wgTitle":"Глава 7 Thinking in Java 4th edition","wgCurRevisionId":31,"wgRevisionId":31,"wgArticleId":21,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Книги","Java","Страницы с неработающими файловыми ссылками"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Глава_7_Thinking_in_Java_4th_edition","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"simplesearch":true,"experiments":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"ru","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"ru"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wjava2-wj_:resourceloader:filter:minify-js:7:07bb1f4d2452379e70abca47c4cde6d9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java5.source-java5 .de1, .java5.source-java5 .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java5.source-java5  {font-family:monospace;}
.java5.source-java5 .imp {font-weight: bold; color: red;}
.java5.source-java5 li, .java5.source-java5 .li1 {font-weight: normal; vertical-align:top;}
.java5.source-java5 .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java5.source-java5 .li2 {font-weight: bold; vertical-align:top;}
.java5.source-java5 .kw1 {color: #000000;  font-weight: bold;}
.java5.source-java5 .kw2 {color: #000000; font-weight: bold;}
.java5.source-java5 .kw3 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw4 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw5 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw6 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw7 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw8 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw9 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw10 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw11 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw12 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw13 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw14 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw15 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw16 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw17 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw18 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw19 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw20 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw21 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw22 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw23 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw24 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw25 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw26 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw27 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw28 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw29 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw30 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw31 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw32 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw33 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw34 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw35 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw36 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw37 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw38 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw39 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw40 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw41 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw42 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw43 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw44 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw45 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw46 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw47 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw48 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw49 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw50 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw51 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw52 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw53 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw54 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw55 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw56 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw57 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw58 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw59 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw60 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw61 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw62 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw63 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw64 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw65 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw66 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw67 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw68 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw69 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw70 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw71 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw72 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw73 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw74 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw75 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw76 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw77 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw78 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw79 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw80 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw81 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw82 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw83 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw84 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw85 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw86 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw87 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw88 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw89 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw90 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw91 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw92 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw93 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw94 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw95 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw96 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw97 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw98 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw99 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw100 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw101 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw102 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw103 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw104 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw105 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw106 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw107 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw108 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw109 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw110 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw111 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw112 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw113 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw114 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw115 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw116 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw117 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw118 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw119 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw120 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw121 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw122 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw123 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw124 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw125 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw126 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw127 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw128 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw129 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw130 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw131 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw132 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw133 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw134 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw135 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw136 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw137 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw138 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw139 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw140 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw141 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw142 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw143 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw144 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw145 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw146 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw147 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw148 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw149 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw150 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw151 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw152 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw153 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw154 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw155 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw156 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw157 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw158 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw159 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw160 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw161 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw162 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw163 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw164 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw165 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw166 {color: #003399; font-weight: bold;}
.java5.source-java5 .co1 {color: #666666; font-style: italic;}
.java5.source-java5 .co2 {color: #006699;}
.java5.source-java5 .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java5.source-java5 .coMULTI {color: #666666; font-style: italic;}
.java5.source-java5 .es0 {color: #000099; font-weight: bold;}
.java5.source-java5 .br0 {color: #009900;}
.java5.source-java5 .sy0 {color: #339933;}
.java5.source-java5 .st0 {color: #0000ff;}
.java5.source-java5 .nu0 {color: #cc66cc;}
.java5.source-java5 .me1 {color: #006633;}
.java5.source-java5 .me2 {color: #006633;}
.java5.source-java5 .ln-xtra, .java5.source-java5 li.ln-xtra, .java5.source-java5 div.ln-xtra {background-color: #ffc;}
.java5.source-java5 span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Глава_7_Thinking_in_Java_4th_edition skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="ru"><span dir="auto">Глава 7 Thinking in Java 4th edition</span></h1>
			<div id="bodyContent">
								<div id="siteSub">Материал из WikiJava: Wiki of Java: викифицированные книги и статьи по Java</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#mw-navigation">навигация</a>, 					<a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#p-search">поиск</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="ru"><table style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;" cellpadding="0" cellspacing="0">
<tbody><tr>
<td> <div id="toc" class="toc"><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9F.D0.9E.D0.92.D0.A2.D0.9E.D0.A0.D0.9D.D0.9E.D0.95_.D0.98.D0.A1.D0.9F.D0.9E.D0.9B.D0.AC.D0.97.D0.9E.D0.92.D0.90.D0.9D.D0.98.D0.95_.D0.9A.D0.9B.D0.90.D0.A1.D0.A1.D0.9E.D0.92"><span class="tocnumber">1</span> <span class="toctext"><b>ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ КЛАССОВ</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8"><span class="tocnumber">1.1</span> <span class="toctext">Синтаксис композиции</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.2</span> <span class="toctext">Синтаксис наследования</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B1.D0.B0.D0.B7.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0"><span class="tocnumber">1.3</span> <span class="toctext">Инициализация базового класса</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D1.8B_.D1.81_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.B0.D0.BC.D0.B8"><span class="tocnumber">1.4</span> <span class="toctext">Конструкторы с аргументами</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.94.D0.B5.D0.BB.D0.B5.D0.B3.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.5</span> <span class="toctext">Делегирование</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D1.87.D0.B5.D1.82.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.6</span> <span class="toctext">Сочетание композиции и наследования</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B1.D0.B5.D1.81.D0.BF.D0.B5.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B7.D0.B0.D0.B2.D0.B5.D1.80.D1.88.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.7</span> <span class="toctext">Обеспечение правильного завершения</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D0.BA.D1.80.D1.8B.D1.82.D0.B8.D0.B5_.D0.B8.D0.BC.D0.B5.D0.BD"><span class="tocnumber">1.8</span> <span class="toctext">Сокрытие имен</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D1.8F_.D0.B2_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D0.B8_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC"><span class="tocnumber">1.9</span> <span class="toctext">Композиция в сравнении с наследованием</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#protected"><span class="tocnumber">1.10</span> <span class="toctext">protected</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.92.D0.BE.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B5_.D0.BF.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2"><span class="tocnumber">1.11</span> <span class="toctext">Восходящее преобразование типов</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D1.87.D0.B5.D0.BC.D1.83_.C2.AB.D0.B2.D0.BE.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B5_.D0.BF.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.C2.BB.3F"><span class="tocnumber">1.11.1</span> <span class="toctext">Почему «восходящее преобразование»?</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BD.D0.BE.D0.B2.D0.B0_.D0.BE_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC"><span class="tocnumber">1.11.2</span> <span class="toctext">Снова о композиции с наследованием</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_final"><span class="tocnumber">1.12</span> <span class="toctext">Ключевое слово final</span></a>
<ul>
<li class="toclevel-3 tocsection-16"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5"><span class="tocnumber">1.12.1</span> <span class="toctext">Неизменные данные</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9F.D1.83.D1.81.D1.82.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D0.B0.D0.BD.D1.82.D1.8B"><span class="tocnumber">1.12.2</span> <span class="toctext">Пустые константы</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D1.8B"><span class="tocnumber">1.12.3</span> <span class="toctext">Неизменные аргументы</span></a></li>
<li class="toclevel-3 tocsection-19"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B"><span class="tocnumber">1.12.4</span> <span class="toctext">Неизменные методы</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#C.D0.BF.D0.B5.D1.86.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.82.D0.BE.D1.80.D1.8B_final_.D0.B8_private"><span class="tocnumber">1.12.5</span> <span class="toctext"><i>C</i>пецификаторы final и private</span></a></li>
<li class="toclevel-3 tocsection-21"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B"><span class="tocnumber">1.12.6</span> <span class="toctext">Неизменные классы</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B5.D0.B4.D0.BE.D1.81.D1.82.D0.B5.D1.80.D0.B5.D0.B6.D0.B5.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.12.7</span> <span class="toctext">Предостережение</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-23"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.BE.D0.B2"><span class="tocnumber">1.13</span> <span class="toctext">Инициализация и загрузка классов</span></a>
<ul>
<li class="toclevel-3 tocsection-24"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC"><span class="tocnumber">1.13.1</span> <span class="toctext">Инициализация с наследованием</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><span class="tocnumber">1.14</span> <span class="toctext">Резюме</span></a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>
<h1><span class="mw-headline" id=".D0.9F.D0.9E.D0.92.D0.A2.D0.9E.D0.A0.D0.9D.D0.9E.D0.95_.D0.98.D0.A1.D0.9F.D0.9E.D0.9B.D0.AC.D0.97.D0.9E.D0.92.D0.90.D0.9D.D0.98.D0.95_.D0.9A.D0.9B.D0.90.D0.A1.D0.A1.D0.9E.D0.92"><b>ПОВТОРНОЕ ИСПОЛЬЗОВАНИЕ КЛАССОВ</b></span></h1>
<p>Возможность повторного использования кода принадлежит к числу важнейших преимуществ <i>Java</i>. Впрочем, по-настоящему масштабные изменения отнюдь не сводятся к обычному копированию и правке кода.
</p><p>Повторное использование на базе копирования кода характерно для процедурных языков, подобных <i>C</i>, но оно работало не очень хорошо. Решение этой проблемы в <i>Java</i>,
 как и многое другое, строится на концепции класса. Вместо того чтобы 
создавать новый класс «с чистого листа», вы берете за основу уже 
существующий класс, который кто-то уже создал и проверил на 
работоспособность.
</p><p>Хитрость состоит в том, чтобы использовать классы без ущерба для 
существующего кода. В этой главе рассматриваются два пути реализации 
этой идеи. Первый довольно прямолинеен: объекты уже имеющихся классов 
просто создаются внутри вашего нового класса. Механизм построения нового
 класса из объектов существующих классов называется композицией (<i>composition</i>). Вы просто используете функциональность готового кода, а не его структуру.
</p><p>Второй способ гораздо интереснее. Новый класс создается как 
специализация уже существующего класса. Взяв существующий класс за 
основу, вы добавляете к нему свой код без изменения существующего 
класса. Этот механизм называется наследованием (<i>inheritance</i>), и 
большую часть работы в нем совершает компилятор. Наследование является 
одним из «краеугольных камней» объектно-ориентированного 
программирования; некоторые из его дополнительных применений описаны в 
главе 8.
</p><p>Синтаксис и поведение типов при использовании композиции и 
наследования нередко совпадают (что вполне логично, так как оба 
механизма предназначены для построения новых типов на базе уже 
существующих). В этой главе рассматриваются оба механизма повторного 
использования кода.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8">Синтаксис композиции</span></h2>
<p>До этого момента мы уже довольно часто использовали композицию — 
ссылка на внедряемый объект просто включается в новый класс. Допустим, 
вам понадобился объект, содержащий несколько объектов <i><b>String</b></i>,
 пару полей примитивного типа и объект еще одного класса. Для 
не-примитивных объектов в новый класс включаются ссылки, а примитивы 
определяются сразу:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/SprinklerSystem.java</span>
<span class="co1">// Композиция для повторного использования кода.</span>
&nbsp;
<span class="kw2">class</span> WaterSource <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> s<span class="sy0">;</span>
  WaterSource<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"WaterSource()"</span><span class="br0">)</span><span class="sy0">;</span>
    s = <span class="st0">"Constructed"</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> s<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SprinklerSystem <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> valve1, valve2, valve3, valve4<span class="sy0">;</span>
  <span class="kw2">private</span> WaterSource source = <span class="kw2">new</span> WaterSource<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">float</span> f<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span>
      <span class="st0">"valve1 = "</span> + valve1 + <span class="st0">" "</span> +
      <span class="st0">"valve2 = "</span> + valve2 + <span class="st0">" "</span> +
      <span class="st0">"valve3 = "</span> + valve3 + <span class="st0">" "</span> +
      <span class="st0">"valve4 = "</span> + valve4 + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"i = "</span> + i + <span class="st0">" "</span> + <span class="st0">"f = "</span> + f + <span class="st0">" "</span> +
      <span class="st0">"source = "</span> + source<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    SprinklerSystem sprinklers = <span class="kw2">new</span> SprinklerSystem<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>sprinklers<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
WaterSource()
</p>
<pre>valve1 = null valve2 = null valve3 = null valve4 = null
i = 0 f = 0.0 source = Constructed
</pre>
<p>&lt;/spoiler&gt;
В обоих классах определяется особый метод <i><b>toString()</b></i>. Позже вы узнаете, что каждый не-примитивный объект имеет метод <i><b>toString()</b></i>,
 который вызывается в специальных случаях, когда компилятор располагает 
не объектом, а хочет получить его строковое представление в формате <i><b>String</b></i>. Поэтому в выражении из метода <i><b>SрrinklerSystem.toString ()</b></i>:
</p>
<pre>"source = " + source;
</pre>
<p>компилятор видит, что к строке <i><b>"source = "</b></i> «прибавляется» объект класса <i><b>WaterSource</b></i>. Компилятор не может это сделать, поскольку к строке можно «добавить» только такую же строку, поэтому он преобразует объект <i><b>source</b></i> в <i><b>String</b></i>, вызывая метод <i><b>toString()</b></i>. После этого компилятор уже в состоянии соединить две строки и передать результат в метод <i><b>System.out.println()</b></i> (или статическим методам <i><b>print()</b></i> и <i><b>printnb()</b></i>, используемым в книге). Чтобы подобное поведение поддерживалось вашим классом, достаточно включить в него метод <i><b>toString()</b></i>.
</p><p>Примитивные типы, определенные в качестве полей класса, 
автоматически инициализируются нулевыми значениями, как упоминалось в 
главе 2. Однако ссылки на объекты заполняются значениями <i><b>null</b></i>, и при попытке вызова метода по такой ссылке произойдет исключение. К счастью, ссылку <i><b>null</b></i> можно вывести без выдачи исключения.
</p><p>Компилятор не создает объекты для ссылок «по умолчанию», и это 
логично, потому что во многих случаях это привело бы к лишним затратам 
ресурсов. Если вам понадобится проинициализировать ссылку, сделайте это 
самостоятельно:
</p>
<hr>
<ul>
<li><span style="color:#800000">в точке определения объекта. Это значит, что объект всегда будет инициализироваться перед вызовом конструктора;</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">в конструкторе данного класса;</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">непосредственно перед использованием 
объекта. Этот способ часто называют отложенной инициализацией. Он может 
сэкономить вам ресурсы в ситуациях, где создавать объект каждый раз 
необязательно и накладно;</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">с использованием инициализации экземпляров.</span>
</li>
</ul>
<hr>
<p>В следующем примере продемонстрированы все четыре способа:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Bath.java</span>
<span class="co1">// Инициализация в конструкторе с композицией.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Soap <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> s<span class="sy0">;</span>
  Soap<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Soap()"</span><span class="br0">)</span><span class="sy0">;</span>
    s = <span class="st0">"Constructed"</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> s<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Bath <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> <span class="co1">// Инициализация в точке определения&nbsp;:</span>
    s1 = <span class="st0">"Happy"</span>,
    s2 = <span class="st0">"Happy"</span>,
    s3, s4<span class="sy0">;</span>
  <span class="kw2">private</span> Soap castille<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">float</span> toy<span class="sy0">;</span>
  <span class="kw2">public</span> Bath<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Inside Bath()"</span><span class="br0">)</span><span class="sy0">;</span>
    s3 = <span class="st0">"Joy"</span><span class="sy0">;</span>
    toy = 3.14f<span class="sy0">;</span>
    castille = <span class="kw2">new</span> Soap<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="co1">// Инициализация экземпляра:</span>
  <span class="br0">{</span> i = <span class="nu0">47</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>s4 == <span class="kw4">null</span><span class="br0">)</span> <span class="co1">// Отложенная инициализация:</span>
      s4 = <span class="st0">"Joy"</span><span class="sy0">;</span>
    <span class="kw2">return</span>
      <span class="st0">"s1 = "</span> + s1 + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"s2 = "</span> + s2 + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"s3 = "</span> + s3 + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"s4 = "</span> + s4 + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"i = "</span> + i + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"toy = "</span> + toy + <span class="st0">"<span class="es0">\n</span>"</span> +
      <span class="st0">"castille = "</span> + castille<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Bath b = <span class="kw2">new</span> Bath<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>b<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Inside Bath()
Soap()
s1 = Happy
s2 = Happy
s3 = Joy
s4 = Joy
i = 47
toy = 3.14
castille = Constructed
</pre>
<p>&lt;/spoiler&gt;
Заметьте, что в конструкторе класса <i><b>Bath</b></i> команда 
выполняется до проведения какой-либо инициализации. Если инициализация в
 точке определения не выполняется, нет никаких гарантий того, что она 
будет выполнена перед отправкой сообщения по ссылке объекта — кроме 
неизбежных исключений времени выполнения.
При вызове метода <i><b>toString()</b></i> в нем присваивается значение ссылке <i><b>s4</b></i>, чтобы все поля были должным образом инициализированы к моменту их использования.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.B8.D0.BD.D1.82.D0.B0.D0.BA.D1.81.D0.B8.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F">Синтаксис наследования</span></h2>
<p>Наследование является неотъемлемой частью <i>Java</i> (и любого 
другого языка ООП). Фактически оно всегда используется при создании 
класса, потому что, даже если класс не объявляется производным от 
другого класса, он автоматически становится производным от корневого 
класса <i>Java</i> <i><b>Object</b></i>.
</p><p>Синтаксис композиции очевиден, но для наследования существует 
совершенно другая форма записи. При использовании наследования вы 
фактически говорите: «Этот новый класс похож на тот старый класс». В 
программе этот факт выражается перед фигурной скобкой, открывающей тело 
класса: сначала записывается ключевое слово <i><b>extends</b></i>, а затем имя базового (<i>base</i>) класса. Тем самым вы автоматически получаете доступ ко всем полям и методам базового класса. Пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Detergent.java</span>
<span class="co1">// Синтаксис наследования и его свойства.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Cleanser <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> s = <span class="st0">"Cleanser"</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> append<span class="br0">(</span><span class="kw21">String</span> a<span class="br0">)</span> <span class="br0">{</span> s += a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> dilute<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> append<span class="br0">(</span><span class="st0">" dilute()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> apply<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> append<span class="br0">(</span><span class="st0">" apply()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> scrub<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> append<span class="br0">(</span><span class="st0">" scrub()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> s<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Cleanser x = <span class="kw2">new</span> Cleanser<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">dilute</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> x.<span class="me1">apply</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> x.<span class="me1">scrub</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Detergent <span class="kw2">extends</span> Cleanser <span class="br0">{</span>
  <span class="co1">// Изменяем метод:</span>
  <span class="kw2">public</span> <span class="kw3">void</span> scrub<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    append<span class="br0">(</span><span class="st0">" Detergent.scrub()"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">super</span>.<span class="me1">scrub</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Вызываем метод базового класса</span>
  <span class="br0">}</span>
  <span class="co1">// Добавляем новые методы к интерфейсу&nbsp;:</span>
  <span class="kw2">public</span> <span class="kw3">void</span> foam<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> append<span class="br0">(</span><span class="st0">" foam()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Проверяем новый класс:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Detergent x = <span class="kw2">new</span> Detergent<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">dilute</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">apply</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">scrub</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    x.<span class="me1">foam</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Testing base class:"</span><span class="br0">)</span><span class="sy0">;</span>
    Cleanser.<span class="me1">main</span><span class="br0">(</span>args<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Cleanser dilute() apply() Detergent.scrub() scrub() foam()
Testing base class:
Cleanser dilute() apply() scrub()
</pre>
<p>&lt;/spoiler&gt;
Пример демонстрирует сразу несколько особенностей наследования. Во-первых, в методе класса <i><b>Cleanser.append()</b></i> новые строки присоединяются к строке <i><b>s</b></i> оператором <i><b>+=</b></i>, одним из операторов, специально «перегруженных» создателями <i>Java</i> для строк (<i><b>String</b></i>).
</p><p>Во-вторых, как <i><b>Cleanser</b></i>, так и <i><b>Detergent</b></i> содержат метод <i><b>main()</b></i>. Вы можете определить метод <i><b>main()</b></i> в каждом из своих классов; это позволяет встраивать тестовый код прямо в класс. Метод <i><b>main()</b></i> даже не обязательно удалять после завершения тестирования, его вполне можно оставить на будущее.
</p><p>Даже если у вас в программе имеется множество классов, из командной строки исполняется только один (так как метод <i><b>main()</b></i> всегда объявляется как <i><b>public</b></i>, то неважно, объявлен ли класс, в котором он описан, как <i><b>public</b></i>). В нашем примере команда <i><b>java Detergent</b></i> вызывает метод <i><b>Detergent.main()</b></i>. Однако вы также можете использовать команду <i><b>java Cleanser</b></i> для вызова метода <i><b>Cleanser.main()</b></i>, хотя класс <i><b>Cleanser</b></i> не объявлен открытым. Даже если класс обладает доступом в пределах класса, открытый метод <i><b>main()</b></i> остается доступным.
</p><p>Здесь метод <i><b>Detergent.main()</b></i> вызывает <i><b>Cleanser.main()</b></i> явно, передавая ему собственный массив аргументов командной строки (впрочем, для этого годится любой массив строк).
</p><p>Важно, что все методы класса <i><b>Cleanser</b></i> объявлены 
открытыми. Помните, что при отсутствии спецификатора доступа, член 
класса автоматически получает доступ «в пределах пакета», что позволяет 
обращаться к нему только из текущего пакета. Таким образом, в пределах 
данного пакета при отсутствии спецификатора доступа вызов этих методов 
разрешен кому угодно — например, это легко может сделать класс <i><b>Detergent</b></i>.
</p><p>Но если бы какой-то класс из другого пакета был объявлен производным от класса <i><b>Cleanser</b></i>, то он получил бы доступ только к его <i><b>public</b></i>-членам. С учетом возможности наследования все поля обычно помечаются как <i><b>private</b></i>, а все методы — как <i><b>public</b></i>. (Производный класс также получает доступ к защищенным (<i><b>protected</b></i>)
 членам базового класса, но об этом позже.) Конечно, иногда вы будете 
отступать от этих правил, но в любом случае полезно их запомнить.
</p><p>Класс <i><b>Cleanser</b></i> содержит ряд методов: <i><b>append(), dilute(), apply(), scrub()</b></i> и <i><b>toString()</b></i>. Так как класс <i><b>Detergent</b></i> произведен от класса <i><b>Cleanser</b></i> (с помощью ключевого слова <i><b>extends</b></i>), он автоматически получает все эти методы в своем интерфейсе, хотя они и не определяются явно в классе <i><b>Detergent</b></i>. Таким образом, наследование обеспечивает повторное использование класса.
</p><p>Как показано на примере метода <i><b>scrub()</b></i>, разработчик
 может взять уже существующий метод базового класса и изменить его. 
Возможно, в этом случае потребуется вызвать метод базового класса из 
новой версии этого метода. Однако в методе <i><b>scrub()</b></i> вы не можете просто вызвать <i><b>scrub()</b></i> — это приведет к рекурсии, а нам нужно не это. Для решения проблемы в <i>Java</i> существует ключевое слово <i><b>super</b></i>, которое обозначает «суперкласс», то есть класс, производным от которого является текущий класс. Таким образом, выражение <i><b>super.scrub()</b></i> обращается к методу <i><b>scrub()</b></i> из базового класса.
</p><p>При наследовании вы не ограничены использованием методов базового
 класса. В производный класс можно добавлять новые методы тем же 
способом, что и раньше, то есть просто определяя их. Метод <i><b>foam()</b></i> — наглядный пример такого подхода.
</p><p>В методе <i><b>Detergent.main()</b></i> для объекта класса <i><b>Detergent</b></i> вызываются все методы, доступные как из класса <i><b>Cleanser</b></i>, так и из класса <i><b>Detergent</b></i> (имеется в виду метод <i><b>foam()</b></i>).
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B1.D0.B0.D0.B7.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.B0">Инициализация базового класса</span></h2>
<p>Так как в наследовании участвуют два класса, базовый и производный, 
не сразу понятно, какой же объект получится в результате. Внешне все 
выглядит так, словно новый класс имеет тот же интерфейс, что и базовый 
класс, плюс еще несколько дополнительных методов и полей. Однако 
наследование не просто копирует интерфейс базового класса. Когда вы 
создаете объект производного класса, внутри него содержится подобъект 
базового класса. Этот подобъект выглядит точно так же, как выглядел бы 
созданный обычным порядком объект базового класса. Поэтому извне 
представляется, будто бы в объекте производного класса «упакован» объект
 базового класса.
</p><p>Конечно, очень важно, чтобы подобъект базового класса был 
правильно инициализирован, и гарантировать это можно только одним 
способом: выполнить инициализацию в конструкторе, вызывая при этом 
конструктор базового класса, у которого есть необходимые знания и 
привилегии для проведения инициализации базового класса. <i>Java</i> 
автоматически вставляет вызовы конструктора базового класса в 
конструктор производного класса. В следующем примере задействовано три 
уровня наследования:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Cartoon.java</span>
<span class="co1">// Вызовы конструкторов при проведении наследования</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Art <span class="br0">{</span>
  Art<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Art constructor"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Drawing <span class="kw2">extends</span> Art <span class="br0">{</span>
  Drawing<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Drawing constructor"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Cartoon <span class="kw2">extends</span> Drawing <span class="br0">{</span>
  <span class="kw2">public</span> Cartoon<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Cartoon constructor"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Cartoon x = <span class="kw2">new</span> Cartoon<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Art constructor
Drawing constructor
Cartoon constructor
</pre>
<p>&lt;/spoiler&gt;
Как видите, конструирование начинается с «самого внутреннего» базового 
класса, поэтому базовый класс инициализируется еще до того, как он 
станет доступным для конструктора производного класса. Даже если 
конструктор класса <i><b>Cartoon</b></i> не определен, компилятор сгенерирует конструктор по умолчанию, в котором также вызывается конструктор базового класса.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.81.D1.82.D1.80.D1.83.D0.BA.D1.82.D0.BE.D1.80.D1.8B_.D1.81_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.B0.D0.BC.D0.B8">Конструкторы с аргументами</span></h2>
<p>В предыдущем примере использовались конструкторы по умолчанию, то 
есть конструкторы без аргументов. У компилятора не возникает проблем с 
вызовом таких конструкторов, так как вопросов о передаче аргументов не 
возникает. Если класс не имеет конструктора по умолчанию или вам 
понадобится вызвать конструктор базового класса с аргументами, этот 
вызов придется оформить явно, с указанием ключевого слова super и 
передачей аргументов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Chess.java</span>
<span class="co1">// Наследование, конструкторы и аргументы.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Game <span class="br0">{</span>
  Game<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Game constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> BoardGame <span class="kw2">extends</span> Game <span class="br0">{</span>
  BoardGame<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"BoardGame constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Chess <span class="kw2">extends</span> BoardGame <span class="br0">{</span>
  Chess<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span><span class="nu0">11</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Chess constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Chess x = <span class="kw2">new</span> Chess<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Game constructor
BoardGame constructor
Chess constructor
</pre>
<p>&lt;/spoiler&gt;
Если не вызвать конструктор базового класса в <i><b>BoardGame()</b></i>, то компилятор «пожалуется» на то, что не может обнаружить конструктор в форме <i><b>Game()</b></i>.
 Вдобавок вызов конструктора базового класса должен быть первой командой
 в конструкторе производного класса. (Если вы вдруг забудете об этом, 
компилятор вам тут же напомнит.)
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.94.D0.B5.D0.BB.D0.B5.D0.B3.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5">Делегирование</span></h2>
<p>Третий вид отношений, не поддерживаемый в <i>Java</i> напрямую, 
называется делегированием. Он занимает промежуточное положение между 
наследованием и композицией: экземпляр существующего класса включается в
 создаваемый класс (как при композиции), но в то же время все методы 
встроенного объекта становятся доступными в новом классе (как при 
наследовании). Например, класс <i><b>SpaceShipControls</b></i> имитирует модуль управления космическим кораблем:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/SpaceShipControls.java</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SpaceShipControls <span class="br0">{</span>
  <span class="kw3">void</span> up<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> down<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> left<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> right<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> forward<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> back<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> turboBoost<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Для построения космического корабля можно воспользоваться наследованием:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/SpaceShip.java</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SpaceShip <span class="kw2">extends</span> SpaceShipControls <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
  <span class="kw2">public</span> SpaceShip<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">name</span> = name<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> name<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    SpaceShip protector = <span class="kw2">new</span> SpaceShip<span class="br0">(</span><span class="st0">"NSEA Protector"</span><span class="br0">)</span><span class="sy0">;</span>
    protector.<span class="me1">forward</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Однако космический корабль не может рассматриваться как частный 
случай своего управляющего модуля — несмотря на то, что ему, к примеру, 
можно приказать двигаться вперед (<i><b>forward()</b></i>). Точнее сказать, что <i><b>SpaceShip</b></i> содержит <i><b>SpaceShipControls</b></i>, и в то же время все методы последнего предоставляются классом <i><b>SpaceShip</b></i>. Проблема решается при помощи делегирования:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/SpaceShipDelegation.java</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SpaceShipDelegation <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
  <span class="kw2">private</span> SpaceShipControls controls =
    <span class="kw2">new</span> SpaceShipControls<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> SpaceShipDelegation<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">name</span> = name<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Делегированные методы:</span>
  <span class="kw2">public</span> <span class="kw3">void</span> back<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">back</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> down<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">down</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> forward<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">forward</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> left<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">left</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> right<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">right</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> turboBoost<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">turboBoost</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> up<span class="br0">(</span><span class="kw3">int</span> velocity<span class="br0">)</span> <span class="br0">{</span>
    controls.<span class="me1">up</span><span class="br0">(</span>velocity<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    SpaceShipDelegation protector =
      <span class="kw2">new</span> SpaceShipDelegation<span class="br0">(</span><span class="st0">"NSEA Protector"</span><span class="br0">)</span><span class="sy0">;</span>
    protector.<span class="me1">forward</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Как видите, вызовы методов переадресуются встроенному объекту <i><b>controls</b></i>,
 а интерфейс остается таким же, как и при наследовании. С другой 
стороны, делегирование позволяет лучше управлять происходящим, потому 
что вы можете ограничиться небольшим подмножеством методов встроенного 
объекта.
Хотя делегирование не поддерживается языком <i>Java</i>, его поддержка присутствует во многих средах разработки. Например, приведенный пример был автоматически сгенерирован в <i>JetBrains Idea IDE</i>.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BE.D1.87.D0.B5.D1.82.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F">Сочетание композиции и наследования</span></h2>
<p>Композиция очень часто используется вместе с наследованием. Следующий
 пример демонстрирует процесс создания более сложного класса с 
объединением композиции и наследования, с выполнением необходимой 
инициализации в конструкторе:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/PlaceSetting.java</span>
<span class="co1">// Совмещение композиции и наследования.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Plate <span class="br0">{</span>
  Plate<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Plate constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> DinnerPlate <span class="kw2">extends</span> Plate <span class="br0">{</span>
  DinnerPlate<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"DinnerPlate constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">class</span> Utensil <span class="br0">{</span>
  Utensil<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Utensil constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Spoon <span class="kw2">extends</span> Utensil <span class="br0">{</span>
  Spoon<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Spoon constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Fork <span class="kw2">extends</span> Utensil <span class="br0">{</span>
  Fork<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Fork constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">class</span> Knife <span class="kw2">extends</span> Utensil <span class="br0">{</span>
  Knife<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Knife constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// A cultural way of doing something:</span>
<span class="kw2">class</span> Custom <span class="br0">{</span>
  Custom<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Custom constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> PlaceSetting <span class="kw2">extends</span> Custom <span class="br0">{</span>
  <span class="kw2">private</span> Spoon sp<span class="sy0">;</span>
  <span class="kw2">private</span> Fork frk<span class="sy0">;</span>
  <span class="kw2">private</span> Knife kn<span class="sy0">;</span>
  <span class="kw2">private</span> DinnerPlate pl<span class="sy0">;</span>
  <span class="kw2">public</span> PlaceSetting<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i + <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    sp = <span class="kw2">new</span> Spoon<span class="br0">(</span>i + <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>
    frk = <span class="kw2">new</span> Fork<span class="br0">(</span>i + <span class="nu0">3</span><span class="br0">)</span><span class="sy0">;</span>
    kn = <span class="kw2">new</span> Knife<span class="br0">(</span>i + <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    pl = <span class="kw2">new</span> DinnerPlate<span class="br0">(</span>i + <span class="nu0">5</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"PlaceSetting constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    PlaceSetting x = <span class="kw2">new</span> PlaceSetting<span class="br0">(</span><span class="nu0">9</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Custom constructor
Utensil constructor
Spoon constructor
Utensil constructor
Fork constructor
Utensil constructor
Knife constructor
Plate constructor
DinnerPlate constructor
PlaceSetting constructor
</pre>
<p>&lt;/spoiler&gt;
Несмотря на то, что компилятор заставляет вас инициализировать базовые 
классы и требует, чтобы вы делали это прямо в начале конструктора, он не
 следит за инициализацией встроенный объектов, поэтому вы должны сами 
помнить об этом.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9E.D0.B1.D0.B5.D1.81.D0.BF.D0.B5.D1.87.D0.B5.D0.BD.D0.B8.D0.B5_.D0.BF.D1.80.D0.B0.D0.B2.D0.B8.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B7.D0.B0.D0.B2.D0.B5.D1.80.D1.88.D0.B5.D0.BD.D0.B8.D1.8F">Обеспечение правильного завершения</span></h2>
<p>В <i>Java</i> отсутствует понятие деструктора из <i>C++</i> — метода, автоматически вызываемого при уничтожении объекта. В <i>Java</i>
 программисты просто «забывают» об объектах, не уничтожая их 
самостоятельно, так как функции очистки памяти возложены на сборщика 
мусора.
</p><p>Во многих случаях эта модель работает, но иногда класс выполняет 
некоторые операции, требующие завершающих действий. Как упоминалось в 
главе 5, вы не знаете, когда будет вызван сборщик мусора и произойдет ли
 это вообще. Поэтому, если в классе должны выполняться действия по 
очистке, вам придется написать для этого особый метод и сделать так, 
чтобы программисты-клиенты знали о необходимости вызова этого метода. 
Более того, как описано в главе 10, вам придется предусмотреть возможные
 исключения и выполнить завершающие действия в секции <i><b>finally</b></i>.
Представим пример системы автоматизированного проектирования, которая рисует на экране изображения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/CADSystem.java</span>
<span class="co1">// Обеспечение необходимого завершения.</span>
<span class="kw2">package</span> <span class="co2">reusing</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw6">Shape</span><span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Shape constructor"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> dispose<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"Shape dispose"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Circle <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  Circle<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Drawing Circle"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> dispose<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Erasing Circle"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">super</span>.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Triangle <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  Triangle<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Drawing Triangle"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> dispose<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Erasing Triangle"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">super</span>.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> <span class="kw99">Line</span> <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> start, end<span class="sy0">;</span>
  <span class="kw99">Line</span><span class="br0">(</span><span class="kw3">int</span> start, <span class="kw3">int</span> end<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>start<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">start</span> = start<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">end</span> = end<span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Drawing Line: "</span> + start + <span class="st0">", "</span> + end<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> dispose<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Erasing Line: "</span> + start + <span class="st0">", "</span> + end<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">super</span>.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CADSystem <span class="kw2">extends</span> <span class="kw6">Shape</span> <span class="br0">{</span>
  <span class="kw2">private</span> Circle c<span class="sy0">;</span>
  <span class="kw2">private</span> Triangle t<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw99">Line</span><span class="br0">[</span><span class="br0">]</span> lines = <span class="kw2">new</span> <span class="kw99">Line</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy0">;</span>
  <span class="kw2">public</span> CADSystem<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>i + <span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> j = <span class="nu0">0</span><span class="sy0">;</span> j <span class="sy0">&lt;</span> lines.<span class="me1">length</span><span class="sy0">;</span> j++<span class="br0">)</span>
      lines<span class="br0">[</span>j<span class="br0">]</span> = <span class="kw2">new</span> <span class="kw99">Line</span><span class="br0">(</span>j, j<span class="sy0">*</span>j<span class="br0">)</span><span class="sy0">;</span>
    c = <span class="kw2">new</span> Circle<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    t = <span class="kw2">new</span> Triangle<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Combined constructor"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> dispose<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"CADSystem.dispose()"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Завершение осуществляется в порядке, </span>
    <span class="co1">// обратном порядку инициализации</span>
    t.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    c.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = lines.<span class="me1">length</span> - <span class="nu0">1</span><span class="sy0">;</span> i <span class="sy0">&gt;</span>= <span class="nu0">0</span><span class="sy0">;</span> i--<span class="br0">)</span>
      lines<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">super</span>.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    CADSystem x = <span class="kw2">new</span> CADSystem<span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="co1">// Код и обработка исключений...</span>
    <span class="br0">}</span> <span class="kw2">finally</span> <span class="br0">{</span>
      x.<span class="me1">dispose</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Shape constructor
Shape constructor
Drawing Line: 0, 0
Shape constructor
Drawing Line: 1, 1
Shape constructor
Drawing Line: 2, 4
Shape constructor
Drawing Circle
Shape constructor
Drawing Triangle
Combined constructor
CADSystem.dispose()
Erasing Triangle
Shape dispose
Erasing Circle
Shape dispose
Erasing Line: 2, 4
Shape dispose
Erasing Line: 1, 1
Shape dispose
Erasing Line: 0, 0
Shape dispose
Shape dispose
</pre>
<p>&lt;/spoiler&gt;
Все в этой системе является некоторой разновидностью класса <i><b>Shape</b></i> (который, в свою очередь, неявно наследует от корневого класса <i><b>Object</b></i>). Каждый класс переопределяет метод <i><b>dispose()</b></i> класса <i><b>Shape</b></i>, вызывая при этом версию метода из базового класса с помощью ключевого слова <i><b>super</b></i>. 
</p><p>Все конкретные классы, унаследованные от <i><b>Shape</b></i> — <i><b>Circle, Triangle</b></i> и <i><b>Line</b></i>,
 имеют конструкторы, которые просто выводят сообщение, хотя во время 
жизни объекта любой метод может сделать что-то, требующее очистки. В 
каждом классе есть свой собственный метод <i><b>dispose()</b></i>, который восстанавливает ресурсы, не связанные с памятью, к исходному состоянию до создания объекта.
</p><p>В методе <i><b>main()</b></i> вы можете заметить два новых ключевых слова, которые будут подробно рассмотрены в главе 10: <i><b>try</b></i> и <i><b>finally</b></i>. Ключевое слово <i><b>try</b></i> показывает, что следующий за ним блок (ограниченный фигурными скобками) является защищенной секцией. Код в секции <i><b>finally</b></i> выполняется всегда, независимо от того, как прошло выполнение блока <i><b>try</b></i>. (При обработке исключений можно выйти из блока <i><b>try</b></i> некоторыми необычными способами.) В данном примере секция <i><b>finally</b></i> означает: «Что бы ни произошло, в конце всегда вызывать метод <i><b>x.dispose()</b></i>».
</p><p>Также обратите особое внимание на порядок вызова завершающих 
методов для базового класса и объектов-членов в том случае, если они 
зависят друг от друга. В основном нужно следовать тому же принципу, что 
использует компилятор <i>C++</i> при вызове деструкторов: сначала 
провести завершающие действия для вашего класса в последовательности, 
обратной порядку их создания. (Обычно для этого требуется, чтобы 
элементы базовых классов продолжали существовать.) Затем вызываются 
завершающие методы из базовых классов, как и показано в программе.
</p><p>Во многих случаях завершающие действия не являются проблемой; 
достаточно дать сборщику мусора выполнить свою работу. Но уж если 
понадобилось провести их явно, сделайте это со всей возможной 
тщательностью и вниманием, так как в процессе сборки мусора трудно в 
чем-либо быть уверенным. Сборщик мусора вообще может не вызываться, а 
если он начнет работать, то объекты будут уничтожаться в произвольном 
порядке. Лучше не полагаться на сборщик мусора в ситуациях, где дело не 
касается освобождения памяти. Если вы хотите провести завершающие 
действия, создайте для этой цели свой собственный метод и не полагайтесь
 на метод <i><b>finalize()</b></i>.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BE.D0.BA.D1.80.D1.8B.D1.82.D0.B8.D0.B5_.D0.B8.D0.BC.D0.B5.D0.BD">Сокрытие имен</span></h2>
<p>Если какой-либо из методов базового класса <i>Java</i> был перегружен
 несколько раз, переопределение имени этого метода в производном классе 
не скроет ни одну из базовых версий (в отличие от <i>C++</i>). Поэтому перегрузка работает вне зависимости от того, где был определен метод — на текущем уровне или в базовом классе:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Hide.java</span>
<span class="co1">// Перегрузка имени метода из базового класса</span>
<span class="co1">// в производном классе не скроет базовую версию метода.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Homer <span class="br0">{</span>
  <span class="kw3">char</span> doh<span class="br0">(</span><span class="kw3">char</span> c<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"doh(char)"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> <span class="st0">'d'</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw3">float</span> doh<span class="br0">(</span><span class="kw3">float</span> f<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"doh(float)"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> 1.0f<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Milhouse <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Bart <span class="kw2">extends</span> Homer <span class="br0">{</span>
  <span class="kw3">void</span> doh<span class="br0">(</span>Milhouse m<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"doh(Milhouse)"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Hide <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Bart b = <span class="kw2">new</span> Bart<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    b.<span class="me1">doh</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    b.<span class="me1">doh</span><span class="br0">(</span><span class="st0">'x'</span><span class="br0">)</span><span class="sy0">;</span>
    b.<span class="me1">doh</span><span class="br0">(</span>1.0f<span class="br0">)</span><span class="sy0">;</span>
    b.<span class="me1">doh</span><span class="br0">(</span><span class="kw2">new</span> Milhouse<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>doh(float)
doh(char)
doh(float)
doh(Milhouse)
</pre>
<p>&lt;/spoiler&gt;
Мы видим, что все перегруженные методы класса <i><b>Homer</b></i> доступны классу <i><b>Bart</b></i>, хотя класс <i><b>Bart</b></i> и добавляет новый перегруженный метод (в <i>C++</i>
 такое действие спрятало бы все методы базового класса). Как вы увидите в
 следующей главе, на практике при переопределении методов гораздо чаще 
используется точно такое же описание и список аргументов, как и в 
базовом классе. Иначе легко можно запутаться (и поэтому <i>C++</i> запрещает это, чтобы предотвратить совершение возможной ошибки).
</p><p>В <i>Java</i> SE5 появилась запись <i><b>@Override</b></i>; она 
не является ключевым словом, но может использоваться так, как если бы 
была им. Если вы собираетесь переопределить метод, используйте <i><b>@Override</b></i>, и компилятор выдаст сообщение об ошибке, если вместо переопределения будет случайно выполнена перегрузка:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Lisa.java</span>
<span class="co1">// {CompileTimeError} (Won't compile)</span>
&nbsp;
<span class="kw2">class</span> Lisa <span class="kw2">extends</span> Homer <span class="br0">{</span>
  @<span class="kw21">Override</span> 
    <span class="kw3">void</span> doh<span class="br0">(</span>Milhouse m<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"doh(Milhouse)"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D1.8F_.D0.B2_.D1.81.D1.80.D0.B0.D0.B2.D0.BD.D0.B5.D0.BD.D0.B8.D0.B8_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC">Композиция в сравнении с наследованием</span></h2>
<p>И композиция, и наследование позволяют вам помещать подобъекты внутрь
 вашего нового класса (при композиции это происходит явно, а в 
наследовании — опосредованно). Вы можете поинтересоваться, в чем между 
ними разница и когда следует выбирать одно, а когда — другое.
</p><p>Композиция в основном применяется, когда в новом классе 
необходимо использовать функциональность уже существующего класса, но не
 его интерфейс. То есть вы встраиваете объект, чтобы использовать его 
возможности в новом классе, а пользователь класса видит определенный 
вами интерфейс, но не замечает встроенных объектов. Для этого внедряемые
 объекты объявляются со спецификатором <i><b>private</b></i>.
</p><p>Иногда требуется предоставить пользователю прямой доступ к 
композиции вашего класса, то есть сделать встроенный объект открытым (<i><b>public</b></i>).
 Встроенные объекты и сами используют сокрытие реализации, поэтому 
открытый доступ безопасен. Когда пользователь знает, что класс 
собирается из составных частей, ему значительно легче понять его 
интерфейс. Хорошим примером служит объект <i><b>Саr</b></i> (машина):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Car.java</span>
<span class="co1">// Композиция с использованием открытых объектов</span>
&nbsp;
<span class="kw2">class</span> Engine <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> start<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> rev<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> stop<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Wheel <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> inflate<span class="br0">(</span><span class="kw3">int</span> psi<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> <span class="kw6">Window</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> rollup<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> rolldown<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Door <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw6">Window</span> window = <span class="kw2">new</span> <span class="kw6">Window</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> open<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> close<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Car <span class="br0">{</span>
  <span class="kw2">public</span> Engine engine = <span class="kw2">new</span> Engine<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> Wheel<span class="br0">[</span><span class="br0">]</span> wheel = <span class="kw2">new</span> Wheel<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy0">;</span>
  <span class="kw2">public</span> Door
    left = <span class="kw2">new</span> Door<span class="br0">(</span><span class="br0">)</span>,
    right = <span class="kw2">new</span> Door<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// 2-door</span>
  <span class="kw2">public</span> Car<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">4</span><span class="sy0">;</span> i++<span class="br0">)</span>
      wheel<span class="br0">[</span>i<span class="br0">]</span> = <span class="kw2">new</span> Wheel<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Car car = <span class="kw2">new</span> Car<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    car.<span class="me1">left</span>.<span class="me1">window</span>.<span class="me1">rollup</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    car.<span class="me1">wheel</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me1">inflate</span><span class="br0">(</span><span class="nu0">72</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Так как композиция объекта является частью проведенного анализа 
задачи (а не просто частью реализации класса), объявление членов класса 
открытыми (<i><b>public</b></i>) помогает программисту-клиенту понять, 
как использовать класс, и облегчает создателю класса написание кода. 
Однако нужно все-таки помнить, что описанный случай является 
специфическим и в основном поля класса следует объявлять как <i><b>private</b></i>.
</p><p>При использовании наследования вы берете уже существующий класс и
 создаете его специализированную версию. В основном это значит, что 
класс общего назначения адаптируется для конкретной задачи. Если 
чуть-чуть подумать, то вы поймете, что не имело бы смысла использовать 
композицию машины и средства передвижения — машина не содержит средства 
передвижения, она сама есть это средство. Взаимосвязь «является» 
выражается наследованием, а взаимосвязь «имеет» описывается композицией.
</p><p><br>
</p>
<h2><span class="mw-headline" id="protected">protected</span></h2>
<p>После знакомства с наследованием ключевое слово <i><b>protected</b></i> наконец-то обрело смысл. В идеале закрытых членов <i><b>private</b></i>
 должно было быть достаточно. В реальности существуют ситуации, когда 
вам необходимо спрятать что-либо от ок­ружающего мира, тем не менее 
оставив доступ для производных классов.
</p><p>Ключевое слово <i><b>protected</b></i> — дань прагматизму. Оно означает: «Член класса является закрытым (<i><b>private</b></i>) для пользователя класса, но для всех, кто наследует от класса, и для соседей по пакету он доступен». (В <i>Java</i> <i><b>protected</b></i> автоматически предоставляет доступ в пределах пакета.)
</p><p>Лучше всего, конечно, объявлять поля класса как <i><b>private</b></i>
 — всегда стоит оставить за собою право изменять лежащую в основе 
реализацию. Управляемый доступ наследникам класса предоставляется через 
методы <i><b>protected</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Orc.java</span>
<span class="co1">// Ключевое слово protected</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Villain <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">String</span> name<span class="sy0">;</span>
  <span class="kw2">protected</span> <span class="kw3">void</span> set<span class="br0">(</span><span class="kw21">String</span> nm<span class="br0">)</span> <span class="br0">{</span> name = nm<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> Villain<span class="br0">(</span><span class="kw21">String</span> name<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">name</span> = name<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"I'm a Villain and my name is "</span> + name<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Orc <span class="kw2">extends</span> Villain <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> orcNumber<span class="sy0">;</span>
  <span class="kw2">public</span> Orc<span class="br0">(</span><span class="kw21">String</span> name, <span class="kw3">int</span> orcNumber<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">orcNumber</span> = orcNumber<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> change<span class="br0">(</span><span class="kw21">String</span> name, <span class="kw3">int</span> orcNumber<span class="br0">)</span> <span class="br0">{</span>
    set<span class="br0">(</span>name<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Доступно, так как объявлено protected </span>
    <span class="kw2">this</span>.<span class="me1">orcNumber</span> = orcNumber<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"Orc "</span> + orcNumber + <span class="st0">": "</span> + <span class="kw2">super</span>.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Orc orc = <span class="kw2">new</span> Orc<span class="br0">(</span><span class="st0">"Limburger"</span>, <span class="nu0">12</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>orc<span class="br0">)</span><span class="sy0">;</span>
    orc.<span class="me1">change</span><span class="br0">(</span><span class="st0">"Bob"</span>, <span class="nu0">19</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>orc<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Orc 12: I'm a Villain and my name is Limburger
Orc 19: I'm a Villain and my name is Bob
</pre>
<p>&lt;/spoiler&gt;
Как видите, метод <i><b>change()</b></i> имеет доступ к методу <i><b>set()</b></i>, поскольку тот объявлен как <i><b>protected</b></i>. Также обратите внимание, что метод <i><b>toString()</b></i> класса <i><b>Orс</b></i> определяется с использованием версии этого метода из базового класса.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.92.D0.BE.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B5_.D0.BF.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2">Восходящее преобразование типов</span></h2>
<p>Самая важная особенность наследования заключается вовсе не в том, что
 оно предоставляет методы для нового класса, — наследование выражает 
отношения между новым и базовым классом. Ее можно выразить .следующим 
образом: «Новый класс имеет тип существующего класса».
</p><p>Данная формулировка — не просто причудливый способ описания 
наследования, она напрямую поддерживается языком. В качестве примера 
рассмотрим базовый класс с именем <i><b>Instrument</b></i> для представления музыкальных инструментов и его производный класс <i><b>Wind</b></i>.
 Так как наследование означает, что все методы базового класса также 
доступны в производном классе, любое сообщение, которое вы в состоянии 
отправить базовому классу, можно отправить и производному классу. 
</p><p>Если в классе <i><b>Instrument</b></i> имеется метод <i><b>play()</b></i>, то он будет присутствовать и в классе <i><b>Wind</b></i>. Таким образом, мы можем со всей определенностью утверждать, что объекты <i><b>Wind</b></i> также имеют тип <i><b>Instrument</b></i>. Следующий пример показывает, как компилятор поддерживает такое понятие:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Wind.java</span>
<span class="co1">// Наследование и восходящее преобразование.</span>
&nbsp;
<span class="kw2">class</span> <span class="kw97">Instrument</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> play<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> tune<span class="br0">(</span><span class="kw97">Instrument</span> i<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// ...</span>
    i.<span class="me1">play</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// Объекты Wind также являются объектами Instrument, </span>
<span class="co1">// поскольку они имеют тот же интерфейс:</span>
<span class="kw2">public</span> <span class="kw2">class</span> Wind <span class="kw2">extends</span> <span class="kw97">Instrument</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Wind flute = <span class="kw2">new</span> Wind<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw97">Instrument</span>.<span class="me1">tune</span><span class="br0">(</span>flute<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Восходящее преобразование</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Наибольший интерес в этом примере представляет метод <i><b>tune()</b></i>, получающий ссылку на объект <i><b>Instrument</b></i>. Однако в методе <i><b>Wind.main()</b></i> методу <i><b>tune()</b></i> передается ссылка на объект <i><b>Wind</b></i>. С учетом всего, что говорилось о строгой проверке типов в <i>Java</i>, кажется странным, что метод с готовностью берет один тип вместо другого. Но стоит вспомнить, что объект <i><b>Wind</b></i> также является объектом <i><b>Instrument</b></i>, и не существует метода, который можно вызвать в методе <i><b>tune()</b></i> для объектов <i><b>Instrument</b></i>, но нельзя для объектов <i><b>Wind</b></i>. В методе <i><b>tune()</b></i> код работает для <i><b>Instrument</b></i> и любых объектов, производных от <i><b>Instrument</b></i>, а преобразование ссылки на объект <i><b>Wind</b></i> в ссылку на объект <i><b>Instrument</b></i> называется восходящим преобразованием типов (<i>upcasting</i>).
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9F.D0.BE.D1.87.D0.B5.D0.BC.D1.83_.C2.AB.D0.B2.D0.BE.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B5.D0.B5_.D0.BF.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.C2.BB.3F">Почему «восходящее преобразование»?</span></h3>
<p>Термин возник по историческим причинам: традиционно на диаграммах 
наследования корень иерархии изображался у верхнего края страницы, а 
диаграмма разрасталась к нижнему краю страницы. (Конечно, вы можете 
рисовать свои диаграммы так, как сочтете нужным.) Для файла <i><b>Wind.java</b></i> диаграмма наследования выглядит так:
</p><p><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%97%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B0&amp;wpDestFile=P0187.png" class="new" title="Файл:P0187.png">Файл:P0187.png</a> 
</p><p>Преобразование от производного типа к базовому требует движения 
вверх по диаграмме, поэтому часто называется восходящим преобразованием.
 Восходящее преобразование всегда безопасно, так как это переход от 
конкретного типа к более общему типу. Иначе говоря, производный класс 
является надстройкой базового класса. Он может содержать больше методов,
 чем базовый класс, но обязан включать в себя все методы базового 
класса.
</p><p>Единственное, что может произойти с интерфейсом класса при 
восходящем преобразовании, — потеря методов, но никак не их 
приобретение. Именно поэтому компилятор всегда разрешает выполнять 
восходящее преобразование, не требуя явных преобразований или других 
специальных обозначений.
</p><p>Преобразование также может выполняться и в обратном направлении — так называемое нисходящее преобразование (<i>downcasting</i>). Но при этом возникает проблема, которая рассматривается в главе 1.1.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.BD.D0.BE.D0.B2.D0.B0_.D0.BE_.D0.BA.D0.BE.D0.BC.D0.BF.D0.BE.D0.B7.D0.B8.D1.86.D0.B8.D0.B8_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC">Снова о композиции с наследованием</span></h3>
<p>В объектно-ориентированном программировании разработчик обычно 
упаковывает данные вместе с методами в классе, а затем работает с 
объектами этого класса. Существующие классы также используются для 
создания новых классов посредством композиции. Наследование на практике 
применяется реже. Поэтому, хотя во время изучения ООП наследованию 
уделяется очень много внимания, это не значит, что его следует без 
разбора применять всюду, где это возможно. Наоборот, пользоваться им 
следует осмотрительно — только там, где полезность наследования не 
вызывает сомнений. Один из хороших критериев выбора между композицией и 
наследованием — спросить себя, собираеесь ли вы впоследствии проводить 
восходящее преобразование от производного класса к базовому классу. Если
 восходящее преобразование актуально, выбирайте наследование, а если нет
 — подумайте, нельзя ли поступить иначе.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D1.8E.D1.87.D0.B5.D0.B2.D0.BE.D0.B5_.D1.81.D0.BB.D0.BE.D0.B2.D0.BE_final">Ключевое слово final</span></h2>
<p>В <i>Java</i> смысл ключевого слова <i><b>final</b></i> зависит от 
контекста, но в основном оно означает: «Это нельзя изменить». Запрет на 
изменения может объясняться двумя причинами: архитектурой программы или 
эффективностью. Эти две причины основательно различаются, поэтому в 
программе возможно неверное употребление ключевого слова <i><b>final</b></i>.
В следующих разделах обсуждаются три возможных применения <i><b>final</b></i>: для данных, методов и классов.
</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5">Неизменные данные</span></h3>
<p>Во многих языках программирования существует тот или иной способ 
сказать компилятору, что частица данных является «константой». Константы
 полезны в двух ситуациях:
</p>
<hr>
<ul>
<li><span style="color:#800000">константа времени компиляции, которая никогда не меняется;</span>
</li>
</ul>
<ul>
<li><span style="color:#800000">значение, инициализируемое во время работы программы, которое нельзя изменять.</span>
</li>
</ul>
<hr>
<p>Компилятор подставляет значение константы времени компиляции во все 
выражения, где оно используется; таким образом предотвращаются некоторые
 издержки выполнения. В <i>Java</i> подобные константы должны относиться к примитивным типам, а для их определения используется ключевое слово <i><b>final</b></i>. Значение такой константы присваивается во время определения.
</p><p>Поле, одновременно объявленное с ключевыми словами <i><b>static</b></i> и <i><b>final</b></i>, существует в памяти в единственном экземпляре и не может быть изменено.
</p><p>При использовании слова <i><b>final</b></i> со ссылками на объекты его смысл не столь очевиден. Для примитивов <i><b>final</b></i>
 делает постоянным значение, но для ссылки на объект постоянной 
становится ссылка. После того как такая ссылка будет связана с объектом,
 она уже не сможет указывать на другой объект. Впрочем, сам объект при 
этом может изменяться; в <i>Java</i> нет механизмов, позволяющих сделать
 произвольный объект неизменным. (Впрочем, вы сами можете написать ваш 
класс так, чтобы его объекты фактически были константными.) Данное 
ограничение относится и к массивам, которые тоже являются объектами.
</p><p>Следующий пример демонстрирует использование <i><b>final</b></i> для полей классов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/FinalData.java</span>
<span class="co1">// Действие ключевого слова final для полей.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Value <span class="br0">{</span>
  <span class="kw3">int</span> i<span class="sy0">;</span> <span class="co1">// доступ в пределах пакета</span>
  <span class="kw2">public</span> Value<span class="br0">(</span><span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">i</span> = i<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FinalData <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> id<span class="sy0">;</span>
  <span class="kw2">public</span> FinalData<span class="br0">(</span><span class="kw21">String</span> id<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">id</span> = id<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Могут быть константами времени компиляции:</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> valueOne = <span class="nu0">9</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> VALUE_TWO = <span class="nu0">99</span><span class="sy0">;</span>
  <span class="co1">// Типичная открытая константа:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> VALUE_THREE = <span class="nu0">39</span><span class="sy0">;</span>
  <span class="co1">// He может быть константой времени компиляции:</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> i4 = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> INT_5 = rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">20</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> Value v1 = <span class="kw2">new</span> Value<span class="br0">(</span><span class="nu0">11</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> Value v2 = <span class="kw2">new</span> Value<span class="br0">(</span><span class="nu0">22</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">final</span> Value VAL_3 = <span class="kw2">new</span> Value<span class="br0">(</span><span class="nu0">33</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="co1">// Массивы:</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span><span class="br0">[</span><span class="br0">]</span> a = <span class="br0">{</span> <span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span> <span class="br0">}</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> id + <span class="st0">": "</span> + <span class="st0">"i4 = "</span> + i4 + <span class="st0">", INT_5 = "</span> + INT_5<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    FinalData fd1 = <span class="kw2">new</span> FinalData<span class="br0">(</span><span class="st0">"fd1"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">//! fd1.valueOne++; // Ошибка значение нельзя изменить</span>
    fd1.<span class="me1">v2</span>.<span class="me1">i</span>++<span class="sy0">;</span> <span class="co1">// Объект не является неизменным!</span>
    fd1.<span class="me1">v1</span> = <span class="kw2">new</span> Value<span class="br0">(</span><span class="nu0">9</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// OK - не является неизменным</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> fd1.<span class="me1">a</span>.<span class="me1">length</span><span class="sy0">;</span> i++<span class="br0">)</span>
      fd1.<span class="me1">a</span><span class="br0">[</span>i<span class="br0">]</span>++<span class="sy0">;</span>  <span class="co1">// Объект не является неизменным!</span>
    <span class="co1">//! fd1.v2 = new Value(0); // Ошибка: ссылку</span>
    <span class="co1">//! fd1.VAL_3 = new Value(1); // нельзя изменить</span>
    <span class="co1">//! fd1.a = new int[3];</span>
    print<span class="br0">(</span>fd1<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"Creating new FinalData"</span><span class="br0">)</span><span class="sy0">;</span>
    FinalData fd2 = <span class="kw2">new</span> FinalData<span class="br0">(</span><span class="st0">"fd2"</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>fd1<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span>fd2<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>fd1: i4 = 15, INT_5 = 18
Creating new FinalData
fd1: i4 = 15, INT_5 = 18
fd2: i4 = 13, INT_5 = 18
</pre>
<p>&lt;/spoiler&gt;
Так как <i><b>valueOne</b></i> и <i><b>VALUE_TWO</b></i> являются 
примитивными типами со значениями, заданными на стадии компиляции, они 
оба могут использоваться в качестве констант времени компиляции, и 
принципиальных различий между ними нет. Константа <i><b>VALUE_THREE</b></i> демонстрирует общепринятый способ определения подобных полей: спецификатор <i><b>public</b></i> открывает к ней доступ за пределами пакета; ключевое слово <i><b>static</b></i> указывает, что она существует в единственном числе, а ключевое слово <i><b>final</b></i> указывает, что ее значение остается неизменным. Заметьте, что примитивы <i><b>final static</b></i>
 с неизменными начальными значениями (то есть константы времени 
компиляции) записываются целиком заглавными буквами, а слова разделяются
 подчеркиванием (эта схема записи констант позаимствована из языка <i>C</i>).
</p><p>Само по себе присутствие <i><b>final</b></i> еще не означает, что
 значение переменной известно уже на стадии компиляции. Данный факт 
продемонстрирован на примере инициализации <i><b>І4</b></i> и <i><b>INT_5</b></i>
 с использованием случайных чисел. Эта часть про­граммы также показывает
 разницу между статическими и нестатическими константами. Она 
проявляется только при инициализации во время исполнения, так как все 
величины времени компиляции обрабатываются компилятором одинаково (и 
обычно просто устраняются с целью оптимизации). Различие проявляется в 
результатах запуска программы. Заметьте, что значения поля <i><b>І4</b></i> для объектов <i><b>fdl</b></i> и <i><b>fd2</b></i> уникальны, но значение поля <i><b>INT_5</b></i> не изменяется при создании второго объекта <i><b>FinalData</b></i>. Дело в том, что поле <i><b>INT_5</b></i> объявлено как <i><b>static</b></i>, поэтому оно инициализируется только один раз во время загрузки класса.
</p><p>Переменные от <i><b>v1</b></i> до <i><b>VAL_3</b></i> поясняют смысл объявления ссылок с ключевым словом <i><b>final</b></i>. Как видно из метода <i><b>main()</b></i>, объявление ссылки <i><b>v2</b></i> как <i><b>final</b></i> еще не означает, что ее объект неизменен. Однако присоединить ссылку <i><b>v2</b></i> к новому объекту не получится, как раз из-за того, что она была объявлена как <i><b>final</b></i>. Именно такой смысл имеет ключевое слово <i><b>final</b></i>
 по отношению к ссылкам. Вы также можете убедиться, что это верно и для 
массивов, которые являются просто другой разновидностью ссылки. Пожалуй,
 для ссылок ключевое слово <i><b>final</b></i> обладает меньшей практической ценностью, чем для примитивов.
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.83.D1.81.D1.82.D1.8B.D0.B5_.D0.BA.D0.BE.D0.BD.D1.81.D1.82.D0.B0.D0.BD.D1.82.D1.8B">Пустые константы</span></h3>
<p>В <i>Java</i> разрешается создавать пустые константы — поля, объявленные как <i><b>final</b></i>,
 которым, однако, не было присвоено начальное значение. Во всех случаях 
пустую константу обязательно нужно инициализировать перед 
использованием, и компилятор следит за этим. Впрочем, пустые константы 
расширяют свободу действий при использовании ключевого слова <i><b>final</b></i>, так как, например, поле <i><b>final</b></i> в классе может быть разным для каждого объекта, и при этом оно сохраняет свою неизменность. Пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/BlankFinal.java</span>
<span class="co1">// "Пустые" неизменные поля.</span>
<span class="kw2">class</span> Poppet <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i<span class="sy0">;</span>
  Poppet<span class="br0">(</span><span class="kw3">int</span> ii<span class="br0">)</span> <span class="br0">{</span> i = ii<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BlankFinal <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> <span class="co1">// Инициализированная константа</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> j<span class="sy0">;</span> <span class="co1">// Пустая константа</span>
  <span class="kw2">private</span> <span class="kw2">final</span> Poppet p<span class="sy0">;</span> <span class="co1">// Пустая константа-ссылка</span>
  <span class="co1">// Пустые константы НЕОБХОДИМО инициализировать в конструкторе:</span>
  <span class="kw2">public</span> BlankFinal<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    j = <span class="nu0">1</span><span class="sy0">;</span> <span class="co1">// Инициализация пустой константы</span>
    p = <span class="kw2">new</span> Poppet<span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Инициализация пустой неизменной ссылки</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> BlankFinal<span class="br0">(</span><span class="kw3">int</span> x<span class="br0">)</span> <span class="br0">{</span>
    j = x<span class="sy0">;</span> <span class="co1">// Инициализация пустой константы</span>
    p = <span class="kw2">new</span> Poppet<span class="br0">(</span>x<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Инициализация пустой неизменной ссылки</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">new</span> BlankFinal<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> BlankFinal<span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Значения неизменных (<i><b>final</b></i>) переменных обязательно 
должны присваиваться или в выражении, записываемом в точке определения 
переменной, или в каждом из конструкторов класса. Тем самым 
гарантируется инициализация полей, объявленных как <i><b>final</b></i>, перед их использованием.
</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D1.8B">Неизменные аргументы</span></h3>
<p><i>Java</i> позволяет вам объявлять неизменными аргументы метода, объявляя их с ключевым словом <i><b>final</b></i> в списке аргументов. Это значит, что метод не может изменить значение, на которое указывает передаваемая ссылка:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/FinalArguments.java</span>
<span class="co1">// Использование final с аргументами метода</span>
&nbsp;
<span class="kw2">class</span> Gizmo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> spin<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FinalArguments <span class="br0">{</span>
  <span class="kw3">void</span> with<span class="br0">(</span><span class="kw2">final</span> Gizmo g<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">//! g = new Gizmo(); // запрещено -- g объявлено final</span>
  <span class="br0">}</span>
  <span class="kw3">void</span> without<span class="br0">(</span>Gizmo g<span class="br0">)</span> <span class="br0">{</span>
    g = <span class="kw2">new</span> Gizmo<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Разрешено -- g не является final</span>
    g.<span class="me1">spin</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// void f(final int i) { i++; } // Нельзя изменять</span>
  <span class="co1">// неизменные примитивы доступны только для чтения:</span>
  <span class="kw3">int</span> g<span class="br0">(</span><span class="kw2">final</span> <span class="kw3">int</span> i<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> i + <span class="nu0">1</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    FinalArguments bf = <span class="kw2">new</span> FinalArguments<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    bf.<span class="me1">without</span><span class="br0">(</span><span class="kw4">null</span><span class="br0">)</span><span class="sy0">;</span>
    bf.<span class="me1">with</span><span class="br0">(</span><span class="kw4">null</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Методы <i><b>f()</b></i> и <i><b>g()</b></i> показывают, что происходит при передаче методу примитивов с пометкой <i><b>final</b></i>: их значение можно прочитать, но изменить его не удастся.
</p><p><br>
</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B">Неизменные методы</span></h3>
<p>Неизменные методы используются по двум причинам. Первая причина — 
«блокировка» метода, чтобы производные классы не могли изменить его 
содержание. Это делается по соображениям проектирования, когда вам точно
 надо знать, что поведение метода не изменится при наследовании.
</p><p>Второй причиной в прошлом считалась эффективность. В более ранних реализациях <i>Java</i> объявление метода с ключевым словом <i><b>final</b></i> позволяло компилятору превращать все вызовы такого метода во встроенные (<i>inline</i>). Когда компилятор видит метод, объявленный как <i><b>final</b></i>,
 он может (на свое усмотрение) пропустить стандартный механизм вставки 
кода для проведения вызова метода (занести аргументы в стек, перейти к 
телу метода, исполнить находящийся там код, вернуть управление, удалить 
аргументы из стека и распорядиться возвращенным значением) и вместо 
этого подставить на место вызова копию реального кода, находящегося в 
теле метода. Таким образом устраняются издержки обычного вызова метода. 
Конечно, для больших методов подстановка приведет к «разбуханию» 
программы, и, скорее всего, никаких преимуществ от использования прямого
 встраивания не будет.
</p><p>В последних версиях <i>Java</i> виртуальная машина выявляет подобные ситуации и устраняет лишние передачи управления при оптимизации, поэтому использовать <i><b>final</b></i> для методов уже не обязательно — и более того, нежелательно.
</p>
<h3><span class="mw-headline" id="C.D0.BF.D0.B5.D1.86.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.82.D0.BE.D1.80.D1.8B_final_.D0.B8_private"><i>C</i>пецификаторы final и private</span></h3>
<p>Любой закрытый (<i><b>private</b></i>) метод в классе косвенно является неизменным (<i><b>final</b></i>) методом. Так как вы не в силах получить доступ к закрытому методу, то не сможете и переопределить его. Ключевое слово <i><b>final</b></i> можно добавить к закрытому методу, но его присутствие ни на что не повлияет.
</p><p>Это может вызвать недоразумения, так как при попытке переопределения закрытого (<i><b>private</b></i>) метода, также неявно являющегося <i><b>final</b></i>, все вроде бы работает и компилятор не выдает сообщений об ошибках:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/FinalOverridingIllusion.java</span>
<span class="co1">// Все выглядит так, будто закрытый (и неизменный) метод</span>
<span class="co1">// можно переопределить, но это заблуждение.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> WithFinals <span class="br0">{</span>
  <span class="co1">// To же, что и просто private:</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"WithFinals.f()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Также автоматически является final:</span>
  <span class="kw2">private</span> <span class="kw3">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> print<span class="br0">(</span><span class="st0">"WithFinals.g()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> OverridingPrivate <span class="kw2">extends</span> WithFinals <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"OverridingPrivate.f()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"OverridingPrivate.g()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> OverridingPrivate2 <span class="kw2">extends</span> OverridingPrivate <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">final</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"OverridingPrivate2.f()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"OverridingPrivate2.g()"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FinalOverridingIllusion <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    OverridingPrivate2 op2 = <span class="kw2">new</span> OverridingPrivate2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    op2.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    op2.<span class="me1">g</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Можно провести восходящее преобразование:</span>
    OverridingPrivate op = op2<span class="sy0">;</span>
    <span class="co1">// Но методы при этом вызвать невозможно:</span>
    <span class="co1">//! op.f();</span>
    <span class="co1">//! op.g();</span>
    <span class="co1">// И то же самое здесь:</span>
    WithFinals wf = op2<span class="sy0">;</span>
    <span class="co1">//! wf.f();</span>
    <span class="co1">//! wf.g();</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>OverridingPrivate2.f()
OverridingPrivate2.g()
</pre>
<p>&lt;/spoiler&gt;
«Переопределение» применимо только к компонентам интерфейса базового 
класса. Иначе говоря, вы должны иметь возможность выполнить восходящее 
преобразование объекта к его базовому типу и вызвать тот же самый метод 
(это утверждение подробнее обсуждается в следующей главе). Если метод 
объявлен как <i><b>private</b></i>, он не является частью интерфейса 
базового класса; это просто некоторый код, скрытый внутри класса, у 
которого оказалось то же имя. Если вы создаете в производном классе 
одноименный метод со спецификатором <i><b>public</b></i>, <i><b>protected</b></i> или с доступом в пределах пакета, то он никак не связан с закрытым методом базового класса. Так как <i><b>privat</b></i>-метод
 недоступен и фактически невидим для окружающего мира, он не влияет ни 
на что, кроме внутренней организации кода в классе, где он был описан.
</p>
<h3><span class="mw-headline" id=".D0.9D.D0.B5.D0.B8.D0.B7.D0.BC.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B">Неизменные классы</span></h3>
<p>Объявляя класс неизменным (записывая в его определении ключевое слово <i><b>final</b></i>),
 вы показываете, что не собираетесь использовать этот класс в качестве 
базового при наследовании и запрещаете это делать другим. Другими 
словами, по какой-то причине структура вашего класса должна оставаться 
постоянной — или же появление субклассов нежелательно по соображениям 
безопасности.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Jurassic.java</span>
<span class="co1">// Объявление неизменным всего класса.</span>
&nbsp;
<span class="kw2">class</span> SmallBrain <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">final</span> <span class="kw2">class</span> Dinosaur <span class="br0">{</span>
  <span class="kw3">int</span> i = <span class="nu0">7</span><span class="sy0">;</span>
  <span class="kw3">int</span> j = <span class="nu0">1</span><span class="sy0">;</span>
  SmallBrain x = <span class="kw2">new</span> SmallBrain<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">//! class Further extends Dinosaur {}</span>
<span class="co1">// Ошибка: Нельзя расширить неизменный класс Dinosaur</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Jurassic <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Dinosaur n = <span class="kw2">new</span> Dinosaur<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    n.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    n.<span class="me1">i</span> = <span class="nu0">40</span><span class="sy0">;</span>
    n.<span class="me1">j</span>++<span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Заметьте, что поля класса могут быть, а могут и не быть неизменными, 
по вашему выбору. Те же правила верны и для неизменных методов вне 
зависимости от того, объявлен ли класс целиком как <i><b>final</b></i>. Объявление класса со спецификатором <i><b>final</b></i>
 запрещает наследование от него — и ничего больше. Впрочем, из-за того, 
что это предотвращает наследование, все методы в неизменном классе также
 являются неизменными, поскольку нет способа переопределить их. Поэтому 
компилятор имеет тот же выбор для обеспечения эффективности выполнения, 
что и в случае с явным объявлением методов как <i><b>final</b></i>. И если вы добавите спецификатор <i><b>final</b></i> к методу в классе, объявленном всецело как <i><b>final</b></i>, то это ничего не будет значить.
</p>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.B4.D0.BE.D1.81.D1.82.D0.B5.D1.80.D0.B5.D0.B6.D0.B5.D0.BD.D0.B8.D0.B5">Предостережение</span></h3>
<p>На первый взгляд идея объявления неизменных методов (<i><b>final</b></i>)
 во время разработки класса выглядит довольно заманчиво — никто не 
сможет переопределить ваши методы. Иногда это действительно так.
Но будьте осторожнее в своих допущениях. Трудно предусмотреть все 
возможности повторного использования класса, особенно для классов общего
 назначения. Определяя метод как <i><b>final</b></i>, вы блокируете 
возможность использования класса в проектах других программистов только 
потому, что сами не могли предвидеть такую возможность.
</p><p>Хорошим примером служит стандартная библиотека <i>Java</i>. Класс <i><b>Vector</b></i> <i>Java</i>
 1.0/1.1 часто использовался на практике и был бы еще полезнее, если бы 
по соображениям эффективности (в данном случае эфемерной) все его методы
 не были объявлены как <i><b>final</b></i>. Возможно, вам хотелось бы создать на основе <i><b>Vector</b></i> производный класс и переопределить некоторые методы, но разработчики почему-то посчитали это излишним. 
</p><p>Ситуация выглядит еще более парадоксальной по двум причинам. Во-первых, класс <i><b>Stack</b></i> унаследован от <i><b>Vector</b></i>, и это значит, что <i><b>Stack</b></i> есть <i><b>Vector</b></i>, а это неверно с точки зрения логики. Тем не менее мы видим пример ситуации, в которой сами проектировщики <i>Java</i> используют наследование от <i><b>Vector</b></i>. 
</p><p>Во-вторых, многие полезные методы класса <i><b>Vector</b></i>, такие как <i><b>addElement()</b></i> и <i><b>elementAt()</b></i>, объявлены с ключевым словом <i><b>synchronized</b></i>.
 Как вы увидите в главе 12, синхронизация сопряжена со значительными 
издержками во время выполнения, которые, вероятно, сводят к нулю все 
преимущества от объявления метода как <i><b>final</b></i>. 
</p><p>Все это лишь подтверждает теорию о том", что программисты не 
умеют правильно находить области для применения оптимизации. Очень 
плохо, что такой неуклюжий дизайн проник в стандартную библиотеку <i>Java</i>. (К счастью, современная библиотека контейнеров <i>Java</i> заменяет <i><b>Vector</b></i> классом <i><b>ArrayList</b></i>,
 который сделан гораздо более аккуратно и по общепринятым нормам. К 
сожалению, существует очень много готового кода, написанного с 
использованием старой библиотеки контейнеров.)
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.B8_.D0.B7.D0.B0.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D0.BE.D0.B2">Инициализация и загрузка классов</span></h2>
<p>В традиционных языках программы загружаются целиком в процессе 
запуска. Далее следует инициализация, а затем программа начинает работу.
 Процесс инициализации в таких языках должен тщательно контролироваться,
 чтобы порядок инициализации статических объектов не создавал проблем. 
Например, в <i>C++</i> могут возникнуть проблемы, когда один из 
статических объектов полагает, что другим статическим объектом уже можно
 пользоваться, хотя последний еще не был инициализирован.
</p><p>В языке <i>Java</i> таких проблем не существует, поскольку в нем 
используется другой подход к загрузке. Вспомните, что скомпилированный 
код каждого класса хранится в отдельном файле. Этот файл не загружается,
 пока не возникнет такая необходимость. В сущности, код класса 
загружается только в точке его первого использования. Обычно это 
происходит при создании первого объекта класса, но загрузка также 
выполняется при обращениях к статическим полям или методам.
</p><p>Точкой первого использования также является точка выполнения 
инициализации статических членов. Все статические объекты и блоки кода 
инициализируются при загрузке класса в том порядке, в котором они 
записаны в определении класса. Конечно, статические объекты 
инициализируются только один раз.
</p>
<h3><span class="mw-headline" id=".D0.98.D0.BD.D0.B8.D1.86.D0.B8.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D1.81_.D0.BD.D0.B0.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5.D0.BC">Инициализация с наследованием</span></h3>
<p>Полезно разобрать процесс инициализации полностью, включая 
наследование, чтобы получить общую картину происходящего. Рассмотрим 
следующий пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: reusing/Beetle.java</span>
<span class="co1">// Полный процесс инициализации.</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Insect <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> i = <span class="nu0">9</span><span class="sy0">;</span>
  <span class="kw2">protected</span> <span class="kw3">int</span> j<span class="sy0">;</span>
  Insect<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"i = "</span> + i + <span class="st0">", j = "</span> + j<span class="br0">)</span><span class="sy0">;</span>
    j = <span class="nu0">39</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> x1 =
    printInit<span class="br0">(</span><span class="st0">"static Insect.x1 initialized"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">int</span> printInit<span class="br0">(</span><span class="kw21">String</span> s<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> <span class="nu0">47</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Beetle <span class="kw2">extends</span> Insect <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> k = printInit<span class="br0">(</span><span class="st0">"Beetle.k initialized"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> Beetle<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"k = "</span> + k<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"j = "</span> + j<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">int</span> x2 =
    printInit<span class="br0">(</span><span class="st0">"static Beetle.x2 initialized"</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    print<span class="br0">(</span><span class="st0">"Beetle constructor"</span><span class="br0">)</span><span class="sy0">;</span>
    Beetle b = <span class="kw2">new</span> Beetle<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>static Insect.x1 initialized
static Beetle.x2 initialized
Beetle constructor
i = 9, j = 0
Beetle.k initialized
k = 47
j = 39
</pre>
<p>&lt;/spoiler&gt;
Запуск класса <i><b>Beetle</b></i> в <i>Java</i> начинается с выполнения метода <i><b>Beetle.main()</b></i> (статического), поэтому загрузчик пытается найти скомпилированный код класса <i><b>Beetle</b></i> (он должен находиться в файле <i><b>Beetle.class</b></i>). При этом загрузчик обнаруживает, что у класса имеется базовый класс (о чем говорит ключевое слово <i><b>extends</b></i>),
 который затем и загружается. Это происходит независимо от того, 
собираетесь вы создавать объект базового класса или нет. (Чтобы 
убедиться в этом, попробуйте закомментировать создание объекта.)
</p><p>Если у базового класса имеется свой базовый класс, этот второй 
базовый класс будет загружен в свою очередь, и т. д. Затем проводится <i><b>static</b></i>-инициализация корневого базового класса (в данном случае это <i><b>Insect</b></i>), затем следующего за ним производного класса, и т. д. Это важно, так как производный класс и инициализация его <i><b>static</b></i>-объектов могут зависеть от инициализации членов базового класса.
</p><p>В этой точке все необходимые классы уже загружены, и можно 
переходить к созданию объекта класса. Сначала всем примитивам данного 
объекта присваиваются значения по умолчанию, а ссылкам на объекты 
задается значение <i><b>null</b></i> — это делается за один проход 
посредством обнуления памяти. Затем вызывается конструктор базового 
класса. В нашем случае вызов происходит автоматически, но вы можете явно
 указать в программе вызов конструктора базового класса (записав его в 
первой строке описания конструктора <i><b>Beetle()</b></i>) с помощью ключевого слова <i><b>super</b></i>.
 Конструирование базового класса выполняется по тем же правилам и в том 
же порядке, что и для производного класса. После завершения работы 
конструктора базового класса инициализируются переменные, в порядке их 
определения. Наконец, выполняется оставшееся тело конструктора.
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5">Резюме</span></h2>
<p>Как наследование, так и композиция позволяют создавать новые типы на 
основе уже существующих. Композиция обычно применяется для повторного 
использования реализации в новом типе, а наследование — для повторного 
использования интерфейса. Так как производный класс имеет интерфейс 
базового класса, к нему можно применить восходящее преобразование к 
базовому классу; это очень важно для работы полиморфизма (см. следующую 
главу).
Несмотря на особое внимание, уделяемое наследованию в ООП, при начальном
 проектировании обычно предпочтение отдается композиции, а к 
наследованию следует обращаться только там, где это абсолютно 
необходимо. 
</p><p>Композиция обеспечивает несколько большую гибкость. Вдобавок, 
применяя хитрости наследования к встроенным типам, можно изменять точный
 тип и, соответственно, поведение этих встроенных объектов во время 
исполнения. Таким образом, появляется возможность изменения поведения 
составного объекта во время исполнения программы.
При проектировании системы вы стремитесь создать иерархию, в которой 
каждый класс имеет определенную цель, чтобы он не был ни излишне большим
 (не содержал слишком много функциональности, затрудняющей его повторное
 использование), ни раздражающе мал (так, что его нельзя использовать 
сам по себе, не добавив перед этим дополнительные возможности). Если 
архитектура становится слишком сложной, часто стоит внести в нее новые 
объекты, разбив существующие объекты на меньшие составные части.
</p><p>Важно понимать, что проектирование программы является пошаговым, 
последовательным процессом, как и обучение человека. Оно основано на 
экспериментах; сколько бы вы ни анализировали и ни планировали, в начале
 работы над проектом у вас еще останутся неясности. Процесс пойдет более
 успешно — и вы быстрее добьетесь результатов, если начнете «выращивать»
 свой проект как живое, эволюционирующее существо, нежели «воздвигнете» 
его сразу, как небоскреб из стекла и металла. Наследование и композиция —
 два важнейших инструмента объектно-ориентированного программирования, 
которые помогут вам выполнять эксперименты такого рода.


</p>
                <p><br>
                </p>
                <hr>
                <p><a href="http://wikijava.it-cache.net/index.php" title="Thinking in Java 4th edition">назад в Оглавление</a>
                </p><p><br>
                </p>
<!-- 
NewPP limit report
CPU time usage: 2.254 seconds
Real time usage: 2.612 seconds
Preprocessor visited node count: 309/1000000
Preprocessor generated node count: 618/1000000
Post‐expand include size: 242/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wjava2-wj_:pcache:idhash:21-0!*!*!!ru!2!* and timestamp 20140813074834
 -->
</div>								<div class="printfooter">
				Источник — «<a href="http://wikijava.org.ua/index.php?title=Glava_7_Thinking_in_Java_4th_edition&amp;oldid=31">http://wikijava.org.ua/index.php?title=Глава_7_Thinking_in_Java_4th_edition&amp;oldid=31</a>»				</div>
												<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8" title="Категория:Книги">Книги</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:Java" title="Категория:Java">Java</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%A1%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B_%D1%81_%D0%BD%D0%B5%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%8E%D1%89%D0%B8%D0%BC%D0%B8_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%BC%D0%B8_%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B0%D0%BC%D0%B8" title="Категория:Страницы с неработающими файловыми ссылками">Страницы с неработающими файловыми ссылками</a></li></ul></div></div>												<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Навигация</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Персональные инструменты</h3>
	<ul>
<li id="pt-login"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0+7+Thinking+in+Java+4th+edition" title="Здесь можно зарегистрироваться в системе, но это необязательно. [o]" accesskey="o">Представиться системе</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Пространства имён</h3>
	<ul>
					<!--<li  id="ca-nstab-main" class="selected"><span><a href="index.php@title=Glava_7_Thinking_in_Java_4th_edition.html"  title="Просмотр основной страницы [c]" accesskey="c">Статья</a></span></li>-->
					<!--<li  id="ca-talk" class="new"><span><a href="http://wikijava.org.ua/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;action=edit&amp;redlink=1"  title="Обсуждение основной страницы [t]" accesskey="t">Обсуждение</a></span></li>-->
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Варианты</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Просмотры</h3>
	<ul>
					<!--<li id="ca-view" class="selected"><span><a href="index.php@title=Glava_7_Thinking_in_Java_4th_edition.html" >Читать</a></span></li>-->
					<!--<li id="ca-viewsource"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;action=edit"  title="Эта страница защищена от изменений, но вы можете посмотреть и скопировать её исходный текст [e]" accesskey="e">Просмотр</a></span></li>-->
					<!--<li id="ca-history" class="collapsible"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;action=history"  title="Журнал изменений страницы [h]" accesskey="h">История</a></span></li>-->
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Действия</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_7_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Поиск</label></h3>
	<form action="http://wikijava.org.ua/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Поиск" title="Искать в WikiJava: Wiki of Java: викифицированные книги и статьи по Java [f]" accesskey="f" id="searchInput">						<button type="submit" name="button" title="Найти страницы, содержащие указанный текст" id="searchButton"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/search-ltr.asc" alt="Найти" height="13" width="12"></button>								<input name="title" value="Служебная:Поиск" type="hidden">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<!--<div id="p-logo" role="banner"><a style="background-image: url(/skins/common/images/wikijava.png);" href="index.php@title=Заглавная_страница.html"  title="Перейти на заглавную страницу"></a></div>-->
				<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
	<h3 id="p-navigation-label">Навигация</h3>
	<div class="body">
        <ul>
            <li id="n-mainpage-description"><a href="http://wikijava.org.ua/index.php?title=%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [z]" accesskey="z">Заглавная страница</a></li>
            <li id="n-recentchanges"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [r]" accesskey="r">Свежие правки</a></li>
            <li id="n-.D0.9A.D0.BD.D0.B8.D0.B3.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8_Java">Книги Java</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D1.8C.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D0%B8_Java">Статьи Java</a></li>
            <li id="n-Java-.D0.BF.D0.BE.D1.80.D1.82.D0.B0.D0.BB"><a href="http://wikijava.org.ua/index.php?title=Java-portal">Java портал</a></li>
            <li id="n-help"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Место, где можно получить справку">Справка</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.81.D1.82.D0.B8.D0.BA.D0.B0"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0">Статистика</a></li>
        </ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label">Инструменты</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition" title="Список всех страниц, ссылающихся на данную [j]" accesskey="j">Ссылки сюда</a></li>
			<li id="t-recentchangeslinked"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition" title="Последние изменения в страницах, на которые ссылается эта страница [k]" accesskey="k">Связанные правки</a></li>
			<li id="t-specialpages"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [q]" accesskey="q">Спецстраницы</a></li>
			<li id="t-print"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [p]" accesskey="p">Версия для печати</a></li>
			<li id="t-permalink"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;oldid=31" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
			<li id="t-info"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_7_Thinking_in_Java_4th_edition&amp;action=info">Сведения о странице</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B" aria-labelledby="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">
	<h3 id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">Другие проекты</h3>
	<div class="body">
		<ul>
			<li id="n-rastafara.com.ua"><a href="http://rastafara.com.ua/" rel="nofollow">rastafara.com.ua</a></li>
			<li id="n-rastafara-blog"><a href="http://sergey-rastafara.blogspot.com/" rel="nofollow">rastafara blog</a></li>
			<li id="n-rastaban"><a href="http://rastaban.com.ua/" rel="nofollow">rastaban</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 21:31, 16 февраля 2014.</li>
											<li id="footer-info-viewcount">К этой странице обращались 2798 раза.</li>
											<li id="footer-info-copyright">Содержимое доступно по лицензии <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 или более поздняя</a> (если не указано иное).</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Описание">Описание WikiJava: Wiki of Java: викифицированные книги и статьи по Java</a></li>
											<li id="footer-places-disclaimer"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Отказ от ответственности">Отказ от ответственности</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/copyleft/fdl.html"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/gnu-fdl.png" alt="GNU Free Documentation License 1.3 или более поздняя" height="31" width="88"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%207_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","ext.vector.simpleSearch","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.231 secs. -->
	

</body></html>