<!DOCTYPE html>
<html dir="ltr" class="client-nojs" lang="ru"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8"><title>Глава 14 Thinking in Java 4th edition — WikiJava: Wiki of Java: викифицированные книги и статьи по Java</title>
<meta name="generator" content="MediaWiki 1.22.2">
<link rel="shortcut icon" href="http://wikijava.it-cache.net/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wikijava.it-cache.net/opensearch_desc.php" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java (ru)">
<link rel="EditURI" type="application/rsd+xml" href="http://wikijava.it-cache.net/api.php@action=rsd">
<link rel="copyright" href="http://www.gnu.org/copyleft/fdl.html">
<link rel="alternate" type="application/atom+xml" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java&nbsp;— Atom-лента" href="http://wikijava.it-cache.net/index.php@title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F%253A%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8&amp;feed=atom">
<link rel="stylesheet" href="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/style3.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<style>a:lang(ar),a:lang(ckb),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wjava2-wj_:resourceloader:filter:minify-css:7:32e7e505403c81fe0a24e297ef166436 */</style>

<script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/style1.css"></script><script src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/load.html"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Глава_14_Thinking_in_Java_4th_edition","wgTitle":"Глава 14 Thinking in Java 4th edition","wgCurRevisionId":38,"wgRevisionId":38,"wgArticleId":28,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Книги","Java"],"wgBreakFrames":false,"wgPageContentLanguage":"ru","wgPageContentModel":"wikitext","wgSeparatorTransformTable":[",\t."," \t,"],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","январь","февраль","март","апрель","май","июнь","июль","август","сентябрь","октябрь","ноябрь","декабрь"],"wgMonthNamesShort":["","янв","фев","мар","апр","май","июн","июл","авг","сен","окт","ноя","дек"],"wgRelevantPageName":"Глава_14_Thinking_in_Java_4th_edition","wgIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgVectorEnabledModules":{"collapsiblenav":true,"collapsibletabs":true,"editwarning":true,"expandablesearch":false,"footercleanup":false,"sectioneditlinks":false,"simplesearch":true,"experiments":true}});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"vector-simplesearch":1,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,
"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"useeditwarning":1,"prefershttps":1,"language":"ru","variant-gan":"gan","variant-iu":"iu","variant-kk":"kk","variant-ku":"ku","variant-shi":"shi","variant-sr":"sr","variant-tg":"tg","variant-uz":"uz","variant-zh":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"variant":"ru"});},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});},{},{});
/* cache key: wjava2-wj_:resourceloader:filter:minify-js:7:07bb1f4d2452379e70abca47c4cde6d9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax","skins.vector.js"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-java5 {line-height: normal;}
.source-java5 li, .source-java5 pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for java5
 * CSS class: source-java5, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.java5.source-java5 .de1, .java5.source-java5 .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.java5.source-java5  {font-family:monospace;}
.java5.source-java5 .imp {font-weight: bold; color: red;}
.java5.source-java5 li, .java5.source-java5 .li1 {font-weight: normal; vertical-align:top;}
.java5.source-java5 .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.java5.source-java5 .li2 {font-weight: bold; vertical-align:top;}
.java5.source-java5 .kw1 {color: #000000;  font-weight: bold;}
.java5.source-java5 .kw2 {color: #000000; font-weight: bold;}
.java5.source-java5 .kw3 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw4 {color: #006600; font-weight: bold;}
.java5.source-java5 .kw5 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw6 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw7 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw8 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw9 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw10 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw11 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw12 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw13 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw14 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw15 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw16 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw17 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw18 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw19 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw20 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw21 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw22 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw23 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw24 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw25 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw26 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw27 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw28 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw29 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw30 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw31 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw32 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw33 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw34 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw35 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw36 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw37 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw38 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw39 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw40 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw41 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw42 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw43 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw44 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw45 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw46 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw47 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw48 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw49 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw50 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw51 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw52 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw53 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw54 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw55 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw56 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw57 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw58 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw59 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw60 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw61 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw62 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw63 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw64 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw65 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw66 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw67 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw68 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw69 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw70 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw71 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw72 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw73 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw74 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw75 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw76 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw77 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw78 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw79 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw80 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw81 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw82 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw83 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw84 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw85 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw86 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw87 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw88 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw89 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw90 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw91 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw92 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw93 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw94 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw95 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw96 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw97 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw98 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw99 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw100 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw101 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw102 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw103 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw104 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw105 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw106 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw107 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw108 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw109 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw110 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw111 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw112 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw113 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw114 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw115 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw116 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw117 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw118 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw119 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw120 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw121 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw122 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw123 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw124 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw125 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw126 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw127 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw128 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw129 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw130 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw131 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw132 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw133 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw134 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw135 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw136 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw137 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw138 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw139 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw140 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw141 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw142 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw143 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw144 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw145 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw146 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw147 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw148 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw149 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw150 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw151 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw152 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw153 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw154 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw155 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw156 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw157 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw158 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw159 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw160 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw161 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw162 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw163 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw164 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw165 {color: #003399; font-weight: bold;}
.java5.source-java5 .kw166 {color: #003399; font-weight: bold;}
.java5.source-java5 .co1 {color: #666666; font-style: italic;}
.java5.source-java5 .co2 {color: #006699;}
.java5.source-java5 .co3 {color: #008000; font-style: italic; font-weight: bold;}
.java5.source-java5 .coMULTI {color: #666666; font-style: italic;}
.java5.source-java5 .es0 {color: #000099; font-weight: bold;}
.java5.source-java5 .br0 {color: #009900;}
.java5.source-java5 .sy0 {color: #339933;}
.java5.source-java5 .st0 {color: #0000ff;}
.java5.source-java5 .nu0 {color: #cc66cc;}
.java5.source-java5 .me1 {color: #006633;}
.java5.source-java5 .me2 {color: #006633;}
.java5.source-java5 .ln-xtra, .java5.source-java5 li.ln-xtra, .java5.source-java5 div.ln-xtra {background-color: #ffc;}
.java5.source-java5 span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;font-family: monospace, monospace;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Глава_14_Thinking_in_Java_4th_edition skin-vector action-view vector-animateLayout">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<h1 id="firstHeading" class="firstHeading" lang="ru"><span dir="auto">Глава 14 Thinking in Java 4th edition</span></h1>
			<div id="bodyContent">
								<div id="siteSub">Материал из WikiJava: Wiki of Java: викифицированные книги и статьи по Java</div>
								<div id="contentSub"></div>
												<div id="jump-to-nav" class="mw-jump">
					Перейти к:					<a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#mw-navigation">навигация</a>, 					<a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#p-search">поиск</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="ru"><table style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;" cellpadding="0" cellspacing="0">
<tbody><tr>
<td> <div id="toc" class="toc"><div id="toctitle"><h2>Содержание</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.90.D0.A0.D0.90.D0.9C.D0.95.D0.A2.D0.A0.D0.98.D0.97.D0.90.D0.A6.D0.98.D0.AF"><span class="tocnumber">1</span> <span class="toctext"><b>ПАРАМЕТРИЗАЦИЯ</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B0.D1.8F_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F"><span class="tocnumber">1.1</span> <span class="toctext"><b>Простая параметризация</b></span></a></li>
<li class="toclevel-2 tocsection-3"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D1.80.D1.82.D0.B5.D0.B6.D0.B8"><span class="tocnumber">1.2</span> <span class="toctext"><b>Кортежи</b></span></a></li>
<li class="toclevel-2 tocsection-4"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BB.D0.B0.D1.81.D1.81_.D1.81.D1.82.D0.B5.D0.BA.D0.B0"><span class="tocnumber">1.3</span> <span class="toctext"><b>Класс стека</b></span></a></li>
<li class="toclevel-2 tocsection-5"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#RandomList"><span class="tocnumber">1.4</span> <span class="toctext"><b>RandomList</b></span></a></li>
<li class="toclevel-2 tocsection-6"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><span class="tocnumber">1.5</span> <span class="toctext"><b>Параметризованные интерфейсы</b></span></a></li>
<li class="toclevel-2 tocsection-7"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B"><span class="tocnumber">1.6</span> <span class="toctext"><b>Параметризованные методы</b></span></a></li>
<li class="toclevel-2 tocsection-8"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.92.D1.8B.D1.87.D0.B8.D1.81.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.B0_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.B0"><span class="tocnumber">1.7</span> <span class="toctext"><b>Вычисление типа аргумента</b></span></a></li>
<li class="toclevel-2 tocsection-9"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.AF.D0.B2.D0.BD.D0.BE.D0.B5_.D1.83.D0.BA.D0.B0.D0.B7.D0.B0.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.B0"><span class="tocnumber">1.8</span> <span class="toctext"><b>Явное указание типа</b></span></a></li>
<li class="toclevel-2 tocsection-10"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2_.D1.81_Generator"><span class="tocnumber">1.9</span> <span class="toctext"><b>Использование параметризованных методов с Generator</b></span></a></li>
<li class="toclevel-2 tocsection-11"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B1.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.B3.D0.B5.D0.BD.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80"><span class="tocnumber">1.10</span> <span class="toctext"><b>Обобщенный генератор</b></span></a></li>
<li class="toclevel-2 tocsection-12"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.A3.D0.BF.D1.80.D0.BE.D1.89.D0.B5.D0.BD.D0.B8.D0.B5_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D1.81_.D0.BA.D0.BE.D1.80.D1.82.D0.B5.D0.B6.D0.B0.D0.BC.D0.B8"><span class="tocnumber">1.11</span> <span class="toctext"><b>Упрощение работы с кортежами</b></span></a></li>
<li class="toclevel-2 tocsection-13"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.92.D1.81.D0.BF.D0.BE.D0.BC.D0.BE.D0.B3.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D0.BA.D0.BB.D0.B0.D1.81.D1.81_Set"><span class="tocnumber">1.12</span> <span class="toctext"><b>Вспомогательный класс Set</b></span></a></li>
<li class="toclevel-2 tocsection-14"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.90.D0.BD.D0.BE.D0.BD.D0.B8.D0.BC.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B"><span class="tocnumber">1.13</span> <span class="toctext"><b>Анонимные внутренние классы</b></span></a></li>
<li class="toclevel-2 tocsection-15"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.BB.D0.BE.D0.B6.D0.BD.D1.8B.D1.85_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B5.D0.B9"><span class="tocnumber">1.14</span> <span class="toctext"><b>Построение сложных моделей</b></span></a></li>
<li class="toclevel-2 tocsection-16"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.A2.D0.B0.D0.B9.D0.BD.D0.B0_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.15</span> <span class="toctext"><b>Тайна стирания</b></span></a></li>
<li class="toclevel-2 tocsection-17"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.BE.D0.B4.D1.85.D0.BE.D0.B4_C.2B.2B"><span class="tocnumber">1.16</span> <span class="toctext"><b>Подход <i>C++</i></b></span></a></li>
<li class="toclevel-2 tocsection-18"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9C.D0.B8.D0.B3.D1.80.D0.B0.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D0.B0.D1.8F_.D1.81.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D1.8C"><span class="tocnumber">1.17</span> <span class="toctext"><b>Миграционная совместимость</b></span></a></li>
<li class="toclevel-2 tocsection-19"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC.D1.8B_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.18</span> <span class="toctext"><b>Проблемы стирания</b></span></a></li>
<li class="toclevel-2 tocsection-20"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC.D1.8B_.D0.BD.D0.B0_.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.86.D0.B0.D1.85"><span class="tocnumber">1.19</span> <span class="toctext"><b>Проблемы на границах</b></span></a></li>
<li class="toclevel-2 tocsection-21"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BC.D0.BF.D0.B5.D0.BD.D1.81.D0.B0.D1.86.D0.B8.D1.8F_.D0.B7.D0.B0_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D0.B5"><span class="tocnumber">1.20</span> <span class="toctext"><b>Компенсация за стирание</b></span></a></li>
<li class="toclevel-2 tocsection-22"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.A1.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5_.D1.8D.D0.BA.D0.B7.D0.B5.D0.BC.D0.BF.D0.BB.D1.8F.D1.80.D0.BE.D0.B2_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2"><span class="tocnumber">1.21</span> <span class="toctext"><b>Создание экземпляров типов</b></span></a></li>
<li class="toclevel-2 tocsection-23"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9C.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D1.8B_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2"><span class="tocnumber">1.22</span> <span class="toctext"><b>Массивы параметризованных типов</b></span></a></li>
<li class="toclevel-2 tocsection-24"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9E.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.23</span> <span class="toctext"><b>Ограничения</b></span></a></li>
<li class="toclevel-2 tocsection-25"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9C.D0.B5.D1.82.D0.B0.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B"><span class="tocnumber">1.24</span> <span class="toctext"><b>Метасимволы</b></span></a></li>
<li class="toclevel-2 tocsection-26"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B0.D1.81.D0.BA.D0.BE.D0.BB.D1.8C.D0.BA.D0.BE_.D1.83.D0.BC.D0.B5.D0.BD_.D0.BA.D0.BE.D0.BC.D0.BF.D0.B8.D0.BB.D1.8F.D1.82.D0.BE.D1.80.3F"><span class="tocnumber">1.25</span> <span class="toctext"><b>Насколько умен компилятор?</b></span></a></li>
<li class="toclevel-2 tocsection-27"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.B0.D0.B2.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><span class="tocnumber">1.26</span> <span class="toctext"><b>Контравариантность</b></span></a></li>
<li class="toclevel-2 tocsection-28"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9D.D0.B5.D0.BE.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.B0.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B"><span class="tocnumber">1.27</span> <span class="toctext"><b>Неограниченные метасимволы</b></span></a></li>
<li class="toclevel-2 tocsection-29"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.BE.D0.B2"><span class="tocnumber">1.28</span> <span class="toctext"><b>Реализация параметризованных интерфейсов</b></span></a></li>
<li class="toclevel-2 tocsection-30"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2_.D0.B8_.D0.BF.D1.80.D0.B5.D0.B4.D1.83.D0.BF.D1.80.D0.B5.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F"><span class="tocnumber">1.29</span> <span class="toctext"><b>Преобразования типов и предупреждения</b></span></a></li>
<li class="toclevel-2 tocsection-31"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0"><span class="tocnumber">1.30</span> <span class="toctext"><b>Перегрузка</b></span></a></li>
<li class="toclevel-2 tocsection-32"><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#.D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><span class="tocnumber">1.31</span> <span class="toctext"><b>Резюме</b></span></a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>
<h1><span class="mw-headline" id=".D0.9F.D0.90.D0.A0.D0.90.D0.9C.D0.95.D0.A2.D0.A0.D0.98.D0.97.D0.90.D0.A6.D0.98.D0.AF"><b>ПАРАМЕТРИЗАЦИЯ</b></span></h1>
<p>Обычные классы и методы работают с конкретными типами: либо, 
примитивами, либо с классами. Если ваш код должен работать с разными 
типами, такая жесткость может создавать проблемы.
</p><p>Одним из механизмов обеспечения универсальности кода в 
объектно-ориентированных языках является полиморфизм. Например, вы 
можете написать метод, который получает в аргументе объект базового 
класса, а затем использует этот метод с любым классом, производным от 
него. Метод становится чуть более универсальным, а область его 
применения расширяется. Это относится и к классам — использование 
базового класса вместо производного обеспечивает дополнительную 
гибкость. Конечно, наследование возможно только для классов, не 
являющихся <i><b>final</b></i>.
</p><p>Впрочем, иногда даже рамки одной иерархии оказываются слишком 
тесными. Если в аргументе метода передается интерфейс вместо класса, то 
ограничения ослабляются и в них включается все, что реализует данный 
интерфейс, — в том числе и классы, которые еще не были созданы. Это дает
 программисту-клиенту возможность реализовать интерфейс, чтобы 
соответствовать требованиям вашего класса или метода. Таким образом, 
интерфейсы позволяют выходить за рамки иерархий классов, если только у 
вас имеется возможность создать новый класс.
Но в некоторых случаях даже интерфейсы оказываются недостаточно гибкими.
 Интерфейс требует, чтобы ваш код работал в этом конкретном интерфейсе. 
Если бы было можно указать, что ваш код работает «с некоторым не 
заданным типом», а не с конкретным интерфейсом или классом, программа 
приобрела бы еще более общий характер.
</p><p>В этом и состоит концепция параметризации — одного из самых значительных новшеств <i>Java</i> <i>SE5</i>.
 Параметризованные типы позволяют создавать компоненты (прежде всего, 
контейнеры), которые могут легко использоваться с разными типами. Если 
прежде вы еще никогда не встречались с механизмом параметризации в 
действии, вероятно, параметризованные типы <i>Java</i> покажутся вам 
довольно удобным дополнением к языку. При создании экземпляра 
па­раметризованного типа преобразования типа выполняются автоматически, а
 правильность типов проверяется на стадии компиляции. С другой стороны, 
разработчики с опытом использования параметризованных типов в других 
языках (скажем, в <i>C++</i>) увидят, что в <i>Java</i> они не соответствуют всем ожиданиям.
</p><p>Если использовать готовый параметризованный тип относительно 
несложно, при попытке написать собственный тип вас ждут сюрпризы. В 
частности, в этой главе я постараюсь объяснить, почему параметризованные
 типы <i>Java</i> получились именно такими.
Не стоит думать, что параметризованные типы <i>Java</i> бесполезны — во 
многих случаях они делают код более четким и элегантным. Но, если вы 
работали на другом языке, в котором они были реализованы более «чисто», 
вас могут ждать разочарования. В этой главе мы изучим как достоинства, 
так и недостатки параметризованных типов <i>Java</i>, чтобы вы могли использовать эту новую возможность более эффективно.
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B0.D1.8F_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F"><b>Простая параметризация</b></span></h2>
<p>Одной из важнейших причин для появления параметризации стало создание
 классов контейнеров (см. главу 11). Контейнер предназначен для хранения
 объектов, используемых в программе. В принципе это описание подойдет и 
для массива, но контейнеры обычно обладают большей гибкостью и 
отличаются по своим характеристикам от простых массивов. Необходимость 
хранения групп объектов возникает едва ли не в каждой программе, поэтому
 контейнеры составляют одну из самых часто используемых библиотек 
классов.
</p><p>Рассмотрим класс для хранения одного объекта. Конечно, в этом классе можно указать точный тип объекта:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Holder1.java</span>
<span class="kw2">class</span> Automobile <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Holder1 <span class="br0">{</span>
  <span class="kw2">private</span> Automobile a<span class="sy0">;</span>
  <span class="kw2">public</span> Holder1<span class="br0">(</span>Automobile a<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">a</span> = a<span class="sy0">;</span> <span class="br0">}</span>
  Automobile get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> a<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Однако такой «контейнер» получается не слишком универсальным — он не 
может использоваться только для одного типа. Конечно, было бы неудобно 
создавать новый класс для каждого типа, который нам встретится в 
программе.
До выхода <i>Java</i> <i>SE5</i> можно было бы хранить в классе <i><b>Object</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Holder2.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Holder2 <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">Object</span> a<span class="sy0">;</span>
  <span class="kw2">public</span> Holder2<span class="br0">(</span><span class="kw166">Object</span> a<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">a</span> = a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span><span class="kw166">Object</span> a<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">a</span> = a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw166">Object</span> get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Holder2 h2 = <span class="kw2">new</span> Holder2<span class="br0">(</span><span class="kw2">new</span> Automobile<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    Automobile a = <span class="br0">(</span>Automobile<span class="br0">)</span>h2.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    h2.<span class="me1">set</span><span class="br0">(</span><span class="st0">"Not an Automobile"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>h2.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    h2.<span class="me1">set</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Автоматически упаковывается в Integer</span>
    <span class="kw21">Integer</span> x = <span class="br0">(</span><span class="kw21">Integer</span><span class="br0">)</span>h2.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Теперь класс <i><b>Holder2</b></i> может хранить все, что угодно, — в приведенном примере один объект <i><b>Holder2</b></i>
 используется для хранения трех разных типов данных.
В некоторых случаях бывает нужно, чтобы контейнер мог хранить объекты 
разных типов, но чаще контейнер предназначается для одного типа 
объектов. Одна из главных причин для применения параметризованных типов 
заключается именно в этом: вы можете указать, какой тип должен храниться
 в контейнере, и заданный тип будет поддерживаться комплиятором.
Итак, вместо <i><b>Object</b></i> в определении класса было бы удобнее 
использовать некий условный заменитель, чтобы отложить выбор до более 
позднего момента. Для этого после имени класса в угловых скобках 
указывается параметр типа, который при использовании заменяется 
фактическим типом. В нашем примере это будет выглядеть так (<i><b>Т </b></i>— параметр типа):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Holder3.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Holder3<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T a<span class="sy0">;</span>
  <span class="kw2">public</span> Holder3<span class="br0">(</span>T a<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">a</span> = a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span>T a<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">a</span> = a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> a<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Holder3<span class="sy0">&lt;</span>Automobile<span class="sy0">&gt;</span> h3 =
      <span class="kw2">new</span> Holder3<span class="sy0">&lt;</span>Automobile<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> Automobile<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    Automobile a = h3.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Преобразование не требуется</span>
    <span class="co1">// h3.set("Not an Automobile");// Ошибка</span>
    <span class="co1">// h3.set(1); // Ошибка</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>При создании <i><b>Holder3</b></i> необходимо указать тип объектов, хранящихся в контейнере, в угловых скобках, как в <i><b>main()</b></i>.
 В дальнейшем в контейнер можно будет помещать объекты только этого типа
 (или производного, так как принцип заменяемости работает и для 
параметризованных типов). А при извлечении вы автоматически получаете 
объект нужного типа.
В этом заключается основная идея параметризованных типов <i>Java</i>: вы указываете, какой тип должен использоваться, а механизм параметризации берет на себя все подробности.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D1.80.D1.82.D0.B5.D0.B6.D0.B8"><b>Кортежи</b></span></h2>
<p>При вызове метода часто требуется, чтобы метод возвращал несколько объектов. Команда <i><b>return</b></i>
 позволяет вернуть только один объект, поэтому проблема решается 
созданием объекта, содержащего несколько возвращаемых объектов. Конечно,
 можно создавать специальный класс каждый раз, когда возникает подобная 
ситуация, но параметризованные типы позволяют решить проблему один раз и
 избавиться от хлопот в будущем. Заодно решается проблема безопасности 
типов на стадии компиляции.
Концепция нескольких объектов, «упакованных» в один объект, называется 
кортежем (<i>tuple</i>). Получатель объекта может читать элементы, но не
 может добавлять их (эта концепция еще называется объектом передачи 
данных).
Обычно кортеж может иметь произвольную длину, а все объекты кортежа 
могут относиться к разным типам. Однако мы хотим задать тип каждого 
объекта и при этом гарантировать, что при чтении значения будет получен 
правильный тип. Для решения проблемы переменной длины мы создадим 
несколько разных кортежей. Вот один из них, рассчитанный на два объекта:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/TwoTuple.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TwoTuple<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">final</span> A first<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">final</span> B second<span class="sy0">;</span>
  <span class="kw2">public</span> TwoTuple<span class="br0">(</span>A a, B b<span class="br0">)</span> <span class="br0">{</span> first = a<span class="sy0">;</span> second = b<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + first + <span class="st0">", "</span> + second + <span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Конструктор запоминает сохраняемый объект, а вспомогательная функция <i><b>toString()</b></i> выводит значения из списка. Обратите внимание: кортеж подразумевает упорядоченное хранение элементов.
При первом чтении может показаться, что такая архитектура нарушает общие принципы безопасности программирования на <i>Java</i>. Разве <i><b>first</b></i> и <i><b>second</b></i> не должны быть объявлены приватными, а обращения к ним осуществляться только из методов <i><b>getFirst()</b></i> и <i><b>getSecond()</b></i>?
 Подумайте, какая безопасность реализуется в этом случае: клиент может 
читать объекты и делать с прочитанными значениями все, что пожелает, но 
не может изменить <i><b>first</b></i> и <i><b>second</b></i>. Фактически объявление <i><b>final</b></i> делает то же самое, но короче и проще.
Кортежи большей длины создаются посредством наследования. Добавить новый параметр типа несложно:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//:------------ net/mindview/util/ThreeTuple.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ThreeTuple<span class="sy0">&lt;</span>A,B,C<span class="sy0">&gt;</span> <span class="kw2">extends</span> TwoTuple<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">final</span> C third<span class="sy0">;</span>
  <span class="kw2">public</span> ThreeTuple<span class="br0">(</span>A a, B b, C c<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>a, b<span class="br0">)</span><span class="sy0">;</span>
    third = c<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + first + <span class="st0">", "</span> + second + <span class="st0">", "</span> + third +<span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">//:-------------- net/mindview/util/FourTuple.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FourTuple<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span> <span class="kw2">extends</span> ThreeTuple<span class="sy0">&lt;</span>A,B,C<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">final</span> D fourth<span class="sy0">;</span>
  <span class="kw2">public</span> FourTuple<span class="br0">(</span>A a, B b, C c, D d<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>a, b, c<span class="br0">)</span><span class="sy0">;</span>
    fourth = d<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + first + <span class="st0">", "</span> + second + <span class="st0">", "</span> +
      third + <span class="st0">", "</span> + fourth + <span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">//:--------------- net/mindview/util/FiveTuple.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FiveTuple<span class="sy0">&lt;</span>A,B,C,D,E<span class="sy0">&gt;</span>
<span class="kw2">extends</span> FourTuple<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">final</span> E fifth<span class="sy0">;</span>
  <span class="kw2">public</span> FiveTuple<span class="br0">(</span>A a, B b, C c, D d, E e<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">super</span><span class="br0">(</span>a, b, c, d<span class="br0">)</span><span class="sy0">;</span>
    fifth = e<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="st0">"("</span> + first + <span class="st0">", "</span> + second + <span class="st0">", "</span> +
      third + <span class="st0">", "</span> + fourth + <span class="st0">", "</span> + fifth + <span class="st0">")"</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Чтобы воспользоваться этими классами, достаточно определить кортеж 
нужной длины как возвращаемое значение функции, а затем создать и 
вернуть его командой <i><b>return</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/TupleTest.java</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Amphibian <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Vehicle <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TupleTest <span class="br0">{</span>
  <span class="kw2">static</span> TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Autoboxing converts the int to Integer:</span>
    <span class="kw2">return</span> <span class="kw2">new</span> TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> ThreeTuple<span class="sy0">&lt;</span>Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> ThreeTuple<span class="sy0">&lt;</span>Amphibian, <span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span>
      <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span>
  FourTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> h<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span>
      <span class="kw2">new</span> FourTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span>
        <span class="kw2">new</span> Vehicle<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span>
  FiveTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span> k<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span>
      FiveTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span><span class="br0">(</span>
        <span class="kw2">new</span> Vehicle<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span>, <span class="nu0">11.1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> ttsi = f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ttsi<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// ttsi.first = "there"; // Compile error: final</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>g<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>h<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>k<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;(80% match)
</p>
<pre>(hi, 47)
(Amphibian@1f6a7b9, hi, 47)
(Vehicle@35ce36, Amphibian@757aef, hi, 47)
(Vehicle@9cab16, Amphibian@1a46e30, hi, 47, 11.1)
</pre>
<p>&lt;/spoiler&gt;
Спецификация <i><b>final</b></i> для <i><b>public</b></i>-полей предотвращает их изменение после конструирования (поэтому попытка выполнения команды <i><b>ttsi.first="there"</b></i> приводит к ошибке).
Конструкции <i><b>new</b></i> получаются немного громоздкими. Позднее в этой главе будет показано, как упростить их при помощи параметризованных методов.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BB.D0.B0.D1.81.D1.81_.D1.81.D1.82.D0.B5.D0.BA.D0.B0"><b>Класс стека</b></span></h2>
<p>Давайте рассмотрим менее тривиальный пример: реализацию традиционного стека. В главе 11 была приведена реализация стека на базе <i><b>LinkedList</b></i>. В этом примере класс <i><b>LinkedList</b></i> уже содержал все методы, необходимые для создания стека. Класс стека строился объединением одного параметризованного класса (<i><b>Stack&lt;T&gt;</b></i>) с другим параметризованным классом (<i><b>LinkedList&lt;T&gt;</b></i>).
 Этот пример показывает, что параметризованный тип — такой же тип, как и
 все остальные (за некоторыми исключениями, о которых речь пойдет 
позже):-
Вместо того, чтобы использовать <i><b>LinkedList</b></i>, мы также могли реализовать собственный механизм хранения связанного списка:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/LinkedStack.java</span>
<span class="co1">// Стек, реализованный на базе внутренней структуры</span>
<span class="kw2">public</span> <span class="kw2">class</span> LinkedStack<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw2">class</span> <span class="kw159">Node</span><span class="sy0">&lt;</span>U<span class="sy0">&gt;</span> <span class="br0">{</span>
    U item<span class="sy0">;</span>
    <span class="kw159">Node</span><span class="sy0">&lt;</span>U<span class="sy0">&gt;</span> next<span class="sy0">;</span>
    <span class="kw159">Node</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> item = <span class="kw4">null</span><span class="sy0">;</span> next = <span class="kw4">null</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="kw159">Node</span><span class="br0">(</span>U item, <span class="kw159">Node</span><span class="sy0">&lt;</span>U<span class="sy0">&gt;</span> next<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">this</span>.<span class="me1">item</span> = item<span class="sy0">;</span>
      <span class="kw2">this</span>.<span class="me1">next</span> = next<span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw3">boolean</span> end<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item == <span class="kw4">null</span> <span class="sy0">&amp;&amp;</span> next == <span class="kw4">null</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw159">Node</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> top = <span class="kw2">new</span> <span class="kw159">Node</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Предохранитель</span>
  <span class="kw2">public</span> <span class="kw3">void</span> push<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span>
    top = <span class="kw2">new</span> <span class="kw159">Node</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span>item, top<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> T pop<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    T result = top.<span class="me1">item</span><span class="sy0">;</span>
    <span class="kw1">if</span><span class="br0">(</span><span class="sy0">!</span>top.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      top = top.<span class="me1">next</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    LinkedStack<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> lss = <span class="kw2">new</span> LinkedStack<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> s&nbsp;: <span class="st0">"Phasers on stun!"</span>.<span class="me1">split</span><span class="br0">(</span><span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span>
      lss.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s<span class="sy0">;</span>
    <span class="kw1">while</span><span class="br0">(</span><span class="br0">(</span>s = lss.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="sy0">!</span>= <span class="kw4">null</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>stun!
on
Phasers
</pre>
<p>&lt;/spoiler&gt;
Внутренний класс <i><b>Node</b></i> тоже является параметризованным и имеет собственный параметр типа.
Для определения наличия элементов в стеке в этом примере используется предохранитель (<i>end sentinel</i>). Он создается при конструировании <i><b>LinkedStack</b></i>, а затем при каждом вызове <i><b>push()</b></i> новый объект <i><b>Node&lt;T&gt; </b></i> создается и связывается с предыдущим <i><b>Node&lt;T&gt;</b></i>. При вызове <i><b>рор()</b></i> всегда возвращается <i><b>top.item</b></i>, после чего текущий объект <i><b>Node&lt;T&gt;</b></i>
 уничтожается и происходит переход к следующему — если только текущим 
элементом не является предохранитель; в этом случае переход не 
выполняется. При повторных вызовах <i><b>рор()</b></i> клиент будет получать <i><b>null</b></i>, что свидетельствует об отсутствии элементов в стеке.
</p>
<h2><span class="mw-headline" id="RandomList"><b>RandomList</b></span></h2>
<p>Рассмотрим еще один пример контейнера: допустим, вам понадобилась 
особая разновидность списка, которая случайным образом выбирает один из 
своих элементов при вызове <i><b>select()</b></i>. Так как класс должен работать для любых объектов, мы воспользуемся параметризацией:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/RandomList.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> RandomList<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> storage = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> add<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> storage.<span class="me1">add</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T select<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> storage.<span class="me1">get</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span>storage.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    RandomList<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> rs = <span class="kw2">new</span> RandomList<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> s: <span class="br0">(</span><span class="st0">"The quick brown fox jumped over "</span> +
        <span class="st0">"the lazy brown dog"</span><span class="br0">)</span>.<span class="me1">split</span><span class="br0">(</span><span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span>
      rs.<span class="me1">add</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">11</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>rs.<span class="me1">select</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>brown over fox quick quick dog brown The brown lazy brown
</pre>
<p>&lt;/spoiler&gt;
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><b>Параметризованные интерфейсы</b></span></h2>
<p>Параметризация работает и с интерфейсами. Например, класс, создающий 
объекты, называется генератором. В сущности, генератор представляет 
собой специализированную версию паттерна «метод-фабрика», но при 
обращении к нему никакие аргументы не передаются, тогда как 
метод-фабрика обычно получает аргументы. Генератор умеет создавать 
объекты без дополнительной информации.
</p><p>Обычно генератор определяет всего один метод — тот, который создает объекты. Назовем его <i><b>next()</b></i> и включим в стандартный инструментарий:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/Generator.java</span>
<span class="co1">// Параметризованный интерфейс</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">interface</span> Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span> 
 T next<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span></pre></div></div>
<p>Возвращаемое значение метода <i><b>next()</b></i> параметризовано по типу <i><b>Т</b></i>. Как видите, механизм параметризации работает с интерфейсами почти так же, как с классами.
</p><p>Чтобы продемонстрировать, как работает реализация <i><b>Generator</b></i>, мы воспользуемся иерархией классов, представляющих разные виды кофе:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/coffee/Coffee.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Coffee <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">long</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">long</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> getClass<span class="br0">(</span><span class="br0">)</span>.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span> + id<span class="sy0">;</span>
 <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">//: generics/coffee/Latte.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Latte <span class="kw2">extends</span> Coffee <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="co1">//: generics/coffee/Mocha.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Mocha <span class="kw2">extends</span> Coffee <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="co1">//: generics/coffee/Cappuccino.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Cappuccino <span class="kw2">extends</span> Coffee <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="co1">//: generics/coffee/Americano.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Americano <span class="kw2">extends</span> Coffee <span class="br0">{</span><span class="br0">}</span> 
&nbsp;
<span class="co1">//: generics/coffee/Breve.java</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> Breve <span class="kw2">extends</span> Coffee <span class="br0">{</span><span class="br0">}</span></pre></div></div>
<p>Теперь мы можем реализовать интерфейс <i><b>Generator&lt;Coffee&gt;</b></i>, который создает случайные типы объектов из иерархии <i><b>Coffee</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/coffee/CoffeeGenerator.java</span>
<span class="co1">// Генератор случайных объектов из иерархии Coffee</span>
<span class="kw2">package</span> <span class="co2">generics.coffee</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CoffeeGenerator
<span class="kw2">implements</span> Generator<span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span>, <span class="kw21">Iterable</span><span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">Class</span><span class="br0">[</span><span class="br0">]</span> types = <span class="br0">{</span> Latte.<span class="kw2">class</span>, Mocha.<span class="kw2">class</span>,
    Cappuccino.<span class="kw2">class</span>, Americano.<span class="kw2">class</span>, Breve.<span class="kw2">class</span>, <span class="br0">}</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> CoffeeGenerator<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="co1">//Для перебора</span>
  <span class="kw2">private</span> <span class="kw3">int</span> size = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> CoffeeGenerator<span class="br0">(</span><span class="kw3">int</span> sz<span class="br0">)</span> <span class="br0">{</span> size = sz<span class="sy0">;</span> <span class="br0">}</span>	
  <span class="kw2">public</span> Coffee next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw2">return</span> <span class="br0">(</span>Coffee<span class="br0">)</span>
        types<span class="br0">[</span>rand.<span class="me1">nextInt</span><span class="br0">(</span>types.<span class="me1">length</span><span class="br0">)</span><span class="br0">]</span>.<span class="me1">newInstance</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="co1">// Сообщение об ошибках во время выполнения:</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="kw2">class</span> CoffeeIterator <span class="kw2">implements</span> <span class="kw46">Iterator</span><span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span> <span class="br0">{</span>
    <span class="kw3">int</span> count = size<span class="sy0">;</span>
    <span class="kw2">public</span> <span class="kw3">boolean</span> hasNext<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> count <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="kw2">public</span> Coffee next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      count--<span class="sy0">;</span>
      <span class="kw2">return</span> CoffeeGenerator.<span class="kw2">this</span>.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
    <span class="kw2">public</span> <span class="kw3">void</span> remove<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="co1">// He реализован</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">UnsupportedOperationException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span><span class="sy0">;</span>	
  <span class="kw2">public</span> <span class="kw46">Iterator</span><span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span> iterator<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> CoffeeIterator<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    CoffeeGenerator gen = <span class="kw2">new</span> CoffeeGenerator<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>gen.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Coffee c&nbsp;: <span class="kw2">new</span> CoffeeGenerator<span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Americano 0
Latte 1
Americano 2
Mocha 3
Mocha 4
Breve 5
Americano 6
Latte 7
Cappuccino 8
Cappuccino 9
</pre>
<p>&lt;/spoiler&gt;
Параметризованный интерфейс <i><b>Generator</b></i> гарантирует, что <i><b>next()</b></i> вернет параметр типа. <i><b>CoffeeGenerator</b></i> также реализует интерфейс <i><b>Iterable</b></i> и поэтому может использоваться в синтаксисе <i><b>foreach</b></i>. Аргумент, по которому определяется момент прекращения перебора, передается при вызове второго конструктора.
</p><p>А вот как выглядит другая реализация <i><b>Generator&lt;T&gt;</b></i>, предназначенная для получения чисел Фибоначчи:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Fibonacci.java</span>
<span class="co1">// Построение чисел Фибоначчи</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Fibonacci <span class="kw2">implements</span> Generator<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> count = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw21">Integer</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> fib<span class="br0">(</span>count++<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">private</span> <span class="kw3">int</span> fib<span class="br0">(</span><span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>n <span class="sy0">&lt;</span> <span class="nu0">2</span><span class="br0">)</span> <span class="kw2">return</span> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="kw2">return</span> fib<span class="br0">(</span>n-<span class="nu0">2</span><span class="br0">)</span> + fib<span class="br0">(</span>n-<span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Fibonacci gen = <span class="kw2">new</span> Fibonacci<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">18</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>gen.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 
</pre>
<p>&lt;/spoiler&gt;
Хотя и внутри, и снаружи класса мы работаем с <i><b>int</b></i>, в параметре типа передается <i><b>Integer</b></i>. В этом проявляется одно из ограничений параметризации в языке <i>Java</i>: примитивные типы не могут использоваться в качестве параметров типа. Впрочем, в <i>Java</i> <i>SE5</i>
 была добавлена удобная автоматическая упаковка (распаковка) для 
перехода от примитивных типов к объектным «оберткам», и наоборот.
Можно сделать следующий шаг вперед и создать генератор чисел Фибоначчи с
 реализацией <i><b>Iterable</b></i>. Конечно, можно изменить реализацию класса и добавить интерфейс <i><b>Iterable</b></i>,
 но исходные коды не всегда находятся в вашем распоряжении, и вообще 
там, где это возможно, лучше обойтись без их модификации. Вместо этого 
мы воспользуемся «адаптером» для получения нужного интерфейса (этот 
паттерн уже упоминался ранее в книге).
Существует несколько вариантов реализации адаптеров. Например, для 
получения адаптируемого класса можно воспользоваться наследованием:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/IterableFibonacci.java</span>
<span class="co1">// Adapt the Fibonacci class to make it Iterable.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> IterableFibonacci
<span class="kw2">extends</span> Fibonacci <span class="kw2">implements</span> <span class="kw21">Iterable</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> n<span class="sy0">;</span>
  <span class="kw2">public</span> IterableFibonacci<span class="br0">(</span><span class="kw3">int</span> count<span class="br0">)</span> <span class="br0">{</span> n = count<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw46">Iterator</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> iterator<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">Iterator</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> <span class="kw3">boolean</span> hasNext<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> n <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">}</span>
      <span class="kw2">public</span> <span class="kw21">Integer</span> next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        n--<span class="sy0">;</span>
        <span class="kw2">return</span> IterableFibonacci.<span class="kw2">this</span>.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
      <span class="kw2">public</span> <span class="kw3">void</span> remove<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="co1">// Not implemented</span>
        <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">UnsupportedOperationException</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i&nbsp;: <span class="kw2">new</span> IterableFibonacci<span class="br0">(</span><span class="nu0">18</span><span class="br0">)</span><span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>i + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584
</pre>
<p>&lt;/spoiler&gt;
Для использования <i><b>IterableFibonacci</b></i> в синтаксисе <i><b>foreach</b></i> мы передаем конструктору границу, чтобы метод <i><b>hasNext()</b></i> знал, когда следует возвращать <i><b>false</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D1.8B"><b>Параметризованные методы</b></span></h2>
<p>До настоящего момента мы рассматривали параметризацию целых классов, 
однако параметризация может применяться и к отдельным методам классов. 
Сам класс при этом может быть параметризованным, а может и не быть — это
 не зависит от наличия параметризованных методов.
Параметризованный метод может изменяться независимо от класса. В общем 
случае параметризованные методы следует использовать «по мере 
возможности». Иначе говоря, если возможно параметризовать метод вместо 
целого класса, вероятно, стоит выбрать именно этот вариант. Кроме того, 
статические методы не имеют доступа к параметрам типа параметризованных 
классов; если такие методы должны использовать параметризацию, это 
должно происходить на уровне метода, а не на уровне класса.
Чтобы определить параметризованный метод, следует указать список 
параметров перед возвращаемым значением:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericMethods.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> GenericMethods <span class="br0">{</span>
  <span class="kw2">public</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw3">void</span> f<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>x.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericMethods gm = <span class="kw2">new</span> GenericMethods<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span><span class="st0">""</span><span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span><span class="nu0">1.0</span><span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span>1.0F<span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span><span class="st0">'c'</span><span class="br0">)</span><span class="sy0">;</span>
    gm.<span class="me1">f</span><span class="br0">(</span>gm<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>java.lang.String
java.lang.Integer
java.lang.Double
java.lang.Float
java.lang.Character
GenericMethods
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>GenericMethods</b></i> не параметризован, хотя и класс, и его методы могут быть параметризованными одновременно. Но в данном случае только метод <i><b>f()</b></i>
 имеет параметр типа, обозначаемый списком параметров перед возвращаемым
 значением метода.
Учтите, что при использовании параметризованного класса параметры типов 
должны указываться при создании экземпляра. Но при использовании 
параметризованного метода указывать параметры типа не обязательно, 
потому что компилятор способен «вычислить» их за вас. Таким образом, 
вызов <i><b>f()</b></i> выглядит как обычный вызов метода; создается впечатление, что метод <i><b>f()</b></i> существует в бесконечном количестве перегруженных версий. При вызове ему даже может передаваться аргумент типа <i><b>GenericMethods</b></i>.
Для вызовов <i><b>f()</b></i>, использующих примитивные типы, в действие
 вступает механизм автоматической упаковки — примитивные типы 
автоматически преобразуются в соответствующие объекты. Это позволяет 
исключить некоторые фрагменты кода, которые были необходимы прежде из-за
 явного выполнения преобразований.
</p>
<h2><span class="mw-headline" id=".D0.92.D1.8B.D1.87.D0.B8.D1.81.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.B0_.D0.B0.D1.80.D0.B3.D1.83.D0.BC.D0.B5.D0.BD.D1.82.D0.B0"><b>Вычисление типа аргумента</b></span></h2>
<p>Параметризацию иногда упрекают в том, что она увеличивает объем кода. Для наглядности возьмем пример <i><b>holding/MapOfList.java</b></i> из главы 11. Создание контейнера <i><b>Map</b></i> с <i><b>List</b></i> выглядит так:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw46">Map</span><span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Pet<span class="sy0">&gt;&gt;</span> petPeople = 
     <span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Pet<span class="sy0">&gt;&gt;</span><span class="br0">(</span><span class="br0">)</span>:</pre></div></div>
<p>(Ключевое слово <i><b>extends</b></i> и вопросительные знаки будут 
описаны позднее в этой главе.) Казалось бы, эта конструкция избыточна, а
 компилятор мог бы вычислить один из списков аргументов по-другому. В 
действительности сделать это он не может, но вычисление аргументов типов
 все же позволяет немного упростить код. Например, мы можем создать 
вспомогательную библиотеку с различными статическими методами, 
содержащими самые распространенные реализации различных контейнеров:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/New.java</span>
<span class="co1">// Utilities to simplify generic container creation</span>
<span class="co1">// by using type argument inference.</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> New <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>K,V<span class="sy0">&gt;</span> <span class="kw46">Map</span><span class="sy0">&lt;</span>K,V<span class="sy0">&gt;</span> map<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span>K,V<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> list<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">LinkedList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> lList<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">LinkedList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> set<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">HashSet</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Queue</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> queue<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">LinkedList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Примеры:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>, <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;&gt;</span> sls = New.<span class="me1">map</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> ls = New.<span class="me1">list</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">LinkedList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> lls = New.<span class="me1">lList</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> ss = New.<span class="me1">set</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Queue</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> qs = New.<span class="me1">queue</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Примеры использования представлены в <i><b>main()</b></i> — вычисление аргументов типов устраняет необходимость в повторении списков параметров. Этот прием можно использовать в <i><b>holding/MapOfList.java</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/SimplerPets.java</span>
<span class="kw2">import</span> <span class="co2">typeinfo.pets.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SimplerPets <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Map</span><span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Pet<span class="sy0">&gt;&gt;</span> petPeople = New.<span class="me1">map</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Rest of the code is the same...</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Пример интересный, однако трудно сказать, насколько он эффективен в 
действительности. Человеку, читающему код, придется просмотреть 
дополнительную библиотеку и разобраться в ее коде. Возможно, вместо 
этого стоит оставить исходное (пусть и избыточное) определение — как ни 
парадоксально, этот вариант проще. Хотя, если в стандартную библиотеку <i>Java</i> будет добавлено некое подобие <i><b>New.java</b></i>, им можно будет пользоваться.
Вычисление типов не работает ни в каких других ситуациях, кроме присваивания. Если передать результат вызова метода (скажем, <i><b>New.map()</b></i>)
 в аргументе другого метода, компилятор не пытается выполнить вычисление
 типа. Вместо этого вызов метода интерпретируется так, как если бы 
возвращаемое значение присваивалось переменной типа <i><b>Object</b></i>. Пример ошибки такого рода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/LimitsOfInference.java</span>
<span class="kw2">import</span> <span class="co2">typeinfo.pets.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> LimitsOfInference <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span>
  f<span class="br0">(</span><span class="kw46">Map</span><span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Pet<span class="sy0">&gt;&gt;</span> petPeople<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// f(New.map()); // Does not compile</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h2><span class="mw-headline" id=".D0.AF.D0.B2.D0.BD.D0.BE.D0.B5_.D1.83.D0.BA.D0.B0.D0.B7.D0.B0.D0.BD.D0.B8.D0.B5_.D1.82.D0.B8.D0.BF.D0.B0"><b>Явное указание типа</b></span></h2>
<p>При вызове параметризованного метода также можно явно задать тип, 
хотя на практике этот синтаксис используется редко. Тип указывается в 
угловых скобках за точкой, непосредственно перед именем метода. При 
вызове метода в пределах класса необходимо ставить <i><b>this</b></i> перед точкой, а при вызове статических методов перед точкой указывается имя класса. Проблема, продемонстрированная в <i><b>LimitsOflnference.java</b></i>, решается при помощи следующего синтаксиса:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ExplicitTypeSpecification.java</span>
<span class="kw2">import</span> <span class="co2">typeinfo.pets.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ExplicitTypeSpecification <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="kw46">Map</span><span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;</span>Pet<span class="sy0">&gt;&gt;</span> petPeople<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    f<span class="br0">(</span>New.<span class="sy0">&lt;</span>Person, <span class="kw166">List</span><span class="sy0">&lt;</span>Pet<span class="sy0">&gt;&gt;</span>map<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Конечно, при этом теряются преимущества от использования класса <i><b>New</b></i> для уменьшения объема кода, но дополнительный синтаксис необходим только за пределами команд присваивания.
Параметризованные методы и переменные списки аргументов
Параметризованные методы нормально сосуществуют с переменными списками аргументов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericVarargs.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GenericVarargs <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> makeList<span class="br0">(</span>T... <span class="me1">args</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>T item&nbsp;: args<span class="br0">)</span>
      result.<span class="me1">add</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> ls = makeList<span class="br0">(</span><span class="st0">"A"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ls<span class="br0">)</span><span class="sy0">;</span>
    ls = makeList<span class="br0">(</span><span class="st0">"A"</span>, <span class="st0">"B"</span>, <span class="st0">"C"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ls<span class="br0">)</span><span class="sy0">;</span>
    ls = makeList<span class="br0">(</span><span class="st0">"ABCDEFFHIJKLMNOPQRSTUVWXYZ"</span>.<span class="me1">split</span><span class="br0">(</span><span class="st0">""</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ls<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[A]
[A, B, C]
[, A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]
</pre>
<p>&lt;/spoiler&gt;
Метод <i><b>makeList()</b></i> предоставляет ту же функциональность, что и метод   <i><b>java.util.Arrays.asList()</b></i> из стандартной библиотеки.
</p>
<h2><span class="mw-headline" id=".D0.98.D1.81.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.BC.D0.B5.D1.82.D0.BE.D0.B4.D0.BE.D0.B2_.D1.81_Generator"><b>Использование параметризованных методов с Generator</b></span></h2>
<p>Генераторы хорошо подходят для заполнения <i><b>Collection</b></i>, и для выполнения этой операции было бы удобно создать параметризованный метод:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Generators.java</span>
<span class="co1">// A utility to use with Generators.</span>
<span class="kw2">import</span> <span class="co2">generics.coffee.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Generators <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Collection</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
  fill<span class="br0">(</span><span class="kw46">Collection</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> coll, Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> gen, <span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i++<span class="br0">)</span>
      coll.<span class="me1">add</span><span class="br0">(</span>gen.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> coll<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Collection</span><span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span> coffee = fill<span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Coffee<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> CoffeeGenerator<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Coffee c&nbsp;: coffee<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>c<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Collection</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> fnumbers = fill<span class="br0">(</span>
      <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> Fibonacci<span class="br0">(</span><span class="br0">)</span>, <span class="nu0">12</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i&nbsp;: fnumbers<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>i + <span class="st0">", "</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Americano 0
Latte 1
Americano 2
Mocha 3
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 
</pre>
<p>&lt;/spoiler&gt;
Обратите внимание на то, как параметризованный метод <i><b>fill()</b></i> применяется к контейнерам и генераторам как для типа <i><b>Coffee</b></i>, так и для <i><b>Integer</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9E.D0.B1.D0.BE.D0.B1.D1.89.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.B3.D0.B5.D0.BD.D0.B5.D1.80.D0.B0.D1.82.D0.BE.D1.80"><b>Обобщенный генератор</b></span></h2>
<p>Следующий класс создает генератор для любого класса, обладающего 
конструктором по умолчанию. Для уменьшения объема кода в него также 
включен параметризованный метод для получения <i><b>BasicGenerator</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/BasicGenerator.java</span>
<span class="co1">// Автоматическое создание Generator для класса </span>
<span class="co1">// с конструктором по умолчанию (без аргументов)</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BasicGenerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw2">implements</span> Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> type<span class="sy0">;</span>
  <span class="kw2">public</span> BasicGenerator<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> type<span class="br0">)</span><span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">type</span> = type<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="co1">// Assumes type is a public class:</span>
      <span class="kw2">return</span> type.<span class="me1">newInstance</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
  <span class="co1">// Получение генератора по умолчанию для заданного type:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> Generator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> create<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> type<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> BasicGenerator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span>type<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Класс предоставляет базовую реализацию, создающую объекты класса, который (1) является открытым (так как <i><b>BasicGenerator</b></i> определяется в отдельном пакете, соответствующий класс должен иметь уровень доступа <i><b>public</b></i>,
 не ограничиваясь пакетным доступом), и (2) обладает конструктором по 
умолчанию (то есть конструктором без аргументов). Чтобы создать один из 
таких объектов <i><b>BasicGenerator</b></i>, следует вызвать метод <i><b>create()</b></i> и передать ему обозначение генерируемого типа, параметризованный метод <i><b>create()</b></i> позволяет использовать запись <i><b>BasicGenerator.create(MyType.class)</b></i> вместо более громоздкой конструкции <i><b>new BasicGenerator&lt;MyType&gt;(MyType.class)</b></i>.
Для примера рассмотрим простой класс с конструктором по умолчанию:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/CountedObject.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> CountedObject <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">long</span> counter = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">long</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">long</span> id<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> id<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"CountedObject "</span> + id<span class="sy0">;</span><span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Класс <i><b>CountedObject</b></i> отслеживает количество созданных экземпляров и включает его в выходные данные <i><b>toString()</b></i>.
При помощи <i><b>BasicGenerator</b></i> можно легко создать <i><b>Generator</b></i> для <i><b>CountedObject</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/BasicGeneratorDemo.java</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BasicGeneratorDemo <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Generator<span class="sy0">&lt;</span>CountedObject<span class="sy0">&gt;</span> gen =
      BasicGenerator.<span class="me1">create</span><span class="br0">(</span>CountedObject.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">5</span><span class="sy0">;</span> i++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>gen.<span class="me1">next</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; 
</p>
<pre>CountedObject 0
CountedObject 1
CountedObject 2
CountedObject 3
CountedObject 4
</pre>
<p>&lt;/spoiler&gt;
Как видите, применение параметризованного метода снижает объем кода, необходимого для получения объекта <i><b>Generator</b></i>. Раз уж механизм параметризации <i>Java</i> все равно заставляет вас передавать объект <i><b>Class</b></i>, его можно заодно ис­пользовать для вычисления типа в методе <i><b>create()</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.A3.D0.BF.D1.80.D0.BE.D1.89.D0.B5.D0.BD.D0.B8.D0.B5_.D1.80.D0.B0.D0.B1.D0.BE.D1.82.D1.8B_.D1.81_.D0.BA.D0.BE.D1.80.D1.82.D0.B5.D0.B6.D0.B0.D0.BC.D0.B8"><b>Упрощение работы с кортежами</b></span></h2>
<p>Используя вычисление аргументов типов в сочетании со <i><b>static</b></i>-импортом,
 можно оформить приведенную ранее реализацию кортежей в более 
универсальную библиотеку. В следующем примере кортежи создаются 
перегруженным статическим методом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/Tuple.java</span>
<span class="co1">// Библиотека для работы с кортежами </span>
<span class="co1">// с использованием вычисления аргументов типов </span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Tuple <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> TwoTuple<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span> tuple<span class="br0">(</span>A a, B b<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> TwoTuple<span class="sy0">&lt;</span>A,B<span class="sy0">&gt;</span><span class="br0">(</span>a, b<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>A,B,C<span class="sy0">&gt;</span> ThreeTuple<span class="sy0">&lt;</span>A,B,C<span class="sy0">&gt;</span>
  tuple<span class="br0">(</span>A a, B b, C c<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> ThreeTuple<span class="sy0">&lt;</span>A,B,C<span class="sy0">&gt;</span><span class="br0">(</span>a, b, c<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span> FourTuple<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span>
  tuple<span class="br0">(</span>A a, B b, C c, D d<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> FourTuple<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span><span class="br0">(</span>a, b, c, d<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>A,B,C,D,E<span class="sy0">&gt;</span>
  FiveTuple<span class="sy0">&lt;</span>A,B,C,D,E<span class="sy0">&gt;</span> tuple<span class="br0">(</span>A a, B b, C c, D d, E e<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> FiveTuple<span class="sy0">&lt;</span>A,B,C,D,E<span class="sy0">&gt;</span><span class="br0">(</span>a, b, c, d, e<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>А вот как выглядит обновленная версия <i><b>TupleTest.java</b></i> для тестирования <i><b>Tuple.java</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/TupleTest2.java</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Amphibian <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Vehicle <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TupleTest2 <span class="br0">{</span>
  <span class="kw2">static</span> TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Autoboxing converts the int to Integer:</span>
    <span class="kw2">return</span> <span class="kw2">new</span> TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> TwoTuple f2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> tuple<span class="br0">(</span><span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
  <span class="kw2">static</span> ThreeTuple<span class="sy0">&lt;</span>Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> g<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> ThreeTuple<span class="sy0">&lt;</span>Amphibian, <span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span>
      <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span>
  FourTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> h<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span>
      <span class="kw2">new</span> FourTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span>
        <span class="kw2">new</span> Vehicle<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span>
  FiveTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span> k<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span>
      FiveTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span><span class="br0">(</span>
        <span class="kw2">new</span> Vehicle<span class="br0">(</span><span class="br0">)</span>, <span class="kw2">new</span> Amphibian<span class="br0">(</span><span class="br0">)</span>, <span class="st0">"hi"</span>, <span class="nu0">47</span>, <span class="nu0">11.1</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    TwoTuple<span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> ttsi = f<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ttsi<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// ttsi.first = "there"; // Compile error: final</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>g<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>h<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>k<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (80% match)
</p>
<pre>(hi, 47)
(Amphibian@1f6a7b9, hi, 47)
(Vehicle@35ce36, Amphibian@757aef, hi, 47)
(Vehicle@9cab16, Amphibian@1a46e30, hi, 47, 11.1)
</pre>
<p>&lt;/spoiler&gt;
Обратите внимание: <i><b>f()</b></i> возвращает параметризованный объект <i><b>TwoTuple</b></i>, a <i><b>f2()</b></i> — непараметризованный объект <i><b>TwoTuple</b></i>. Компилятор в данном случае не выдает предупреждения о <i><b>f2()</b></i>,
 потому что возвращаемое значение не используется в «параметризованном» 
стиле: в каком-то смысле проводится «восходящее преобразование» его до 
непараметризованного <i><b>TwoTuple</b></i>. Но, если попытаться сохранить результат <i><b>f2()</b></i> в параметризованном объекте <i><b>TwoTuple</b></i>, компилятор выдаст предупреждение.
</p>
<h2><span class="mw-headline" id=".D0.92.D1.81.D0.BF.D0.BE.D0.BC.D0.BE.D0.B3.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B9_.D0.BA.D0.BB.D0.B0.D1.81.D1.81_Set"><b>Вспомогательный класс Set</b></span></h2>
<p>Рассмотрим еще один пример использования параметризованных методов: 
математические операции между множествами. Эти операции удобно 
определить в виде параметризованных методов, используемых с различными 
типами:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/Sets.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Sets <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> union<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> a, <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> b<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">HashSet</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">addAll</span><span class="br0">(</span>b<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
  <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> intersection<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> a, <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> b<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">HashSet</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span>a<span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">retainAll</span><span class="br0">(</span>b<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="co1">// Вычитание подмножества из надмножества</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
  difference<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> superset, <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> subset<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">HashSet</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span>superset<span class="br0">)</span><span class="sy0">;</span>
    result.<span class="me1">removeAll</span><span class="br0">(</span>subset<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// Дополнение -- все. что не входит в пересечение</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> complement<span class="br0">(</span><span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> a, <span class="kw46">Set</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> b<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> difference<span class="br0">(</span>union<span class="br0">(</span>a, b<span class="br0">)</span>, intersection<span class="br0">(</span>a, b<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Первые три метода дублируют первый аргумент, копируя его ссылки в новый объект <i><b>HashSet</b></i>, поэтому аргументы <i><b>Set</b></i> не изменяются напрямую. Таким образом, возвращаемое значение представляет собой новый объект <i><b>Set</b></i>.
Четыре метода представляют математические операции с множествами: <i><b>union()</b></i> возвращает объект <i><b>Set</b></i>, полученный объединением множеств-аргументов, <i><b>intersection()</b></i> возвращает объект <i><b>Set</b></i> с общими элементами аргументов, <i><b>difference()</b></i> вычисляет разность множеств, a <i><b>complement()</b></i> — объект <i><b>Set</b></i>
 со всеми элементами, не входящими в пересечение. Чтобы создать простой 
пример использования этих методов, мы воспользуемся перечислением, 
содержащим разные названия акварельных красок:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/watercolors/Watercolors.java</span>
<span class="kw2">package</span> <span class="co2">generics.watercolors</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">enum</span> Watercolors <span class="br0">{</span>
  ZINC, LEMON_YELLOW, MEDIUM_YELLOW, DEEP_YELLOW, ORANGE,
  BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET,
  CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE,
  COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE,
  SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER,
  BURNT_UMBER, PAYNES_GRAY, IVORY_BLACK
<span class="br0">}</span></pre></div></div>
<p>Для удобства (чтобы избежать уточнения всех имен) в следующем примере это перечисление импортируется статически. Мы используем <i><b>EnumSet</b></i> — новый инструмент <i>Java</i> <i>SE5</i> для простого создания <i><b>Set</b></i> на базе перечисления. Статиче­скому методу <i><b>EnumSet.range()</b></i> передаются первый и последний элементы диапазона, по которому строится множество:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/WatercolorSets.java</span>
<span class="kw2">import</span> <span class="co2">generics.watercolors.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Sets.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">generics.watercolors.Watercolors.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> WatercolorSets <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>Watercolors<span class="sy0">&gt;</span> set1 =
      <span class="kw46">EnumSet</span>.<span class="me1">range</span><span class="br0">(</span>BRILLIANT_RED, VIRIDIAN_HUE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>Watercolors<span class="sy0">&gt;</span> set2 =
      <span class="kw46">EnumSet</span>.<span class="me1">range</span><span class="br0">(</span>CERULEAN_BLUE_HUE, BURNT_UMBER<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"set1: "</span> + set1<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"set2: "</span> + set2<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"union(set1, set2): "</span> + union<span class="br0">(</span>set1, set2<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span>Watercolors<span class="sy0">&gt;</span> subset = intersection<span class="br0">(</span>set1, set2<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"intersection(set1, set2): "</span> + subset<span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"difference(set1, subset): "</span> +
      difference<span class="br0">(</span>set1, subset<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>	
    print<span class="br0">(</span><span class="st0">"difference(set2, subset): "</span> +
      difference<span class="br0">(</span>set2, subset<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"complement(set1, set2): "</span> +
      complement<span class="br0">(</span>set1, set2<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>set1: [BRILLIANT_RED, CRIMSON, MAGENTA, ROSE_MADDER, VIOLET, CERULEAN_BLUE_HUE, PHTHALO_BLUE,
ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, VIRIDIAN_HUE]
set2: [CERULEAN_BLUE_HUE, PHTHALO_BLUE, ULTRAMARINE, COBALT_BLUE_HUE, PERMANENT_GREEN, 
VIRIDIAN_HUE, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, RAW_UMBER, BURNT_UMBER]
union(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, PERMANENT_GREEN, BURNT_UMBER,  
COBALT_BLUE_HUE, VIOLET, BRILLIANT_RED, RAW_UMBER, ULTRAMARINE, BURNT_SIENNA, CRIMSON, 
CERULEAN_BLUE_HUE, PHTHALO_BLUE, MAGENTA, VIRIDIAN_HUE]
intersection(set1, set2): [ULTRAMARINE, PERMANENT_GREEN, COBALT_BLUE_HUE, PHTHALO_BLUE, 
CERULEAN_BLUE_HUE, VIRIDIAN_HUE]
difference(set1, subset): [ROSE_MADDER, CRIMSON, VIOLET, MAGENTA, BRILLIANT_RED]
difference(set2, subset): [RAW_UMBER, SAP_GREEN, YELLOW_OCHRE, BURNT_SIENNA, BURNT_UMBER]
complement(set1, set2): [SAP_GREEN, ROSE_MADDER, YELLOW_OCHRE, BURNT_UMBER, VIOLET, 
BRILLIANT_RED, RAW_UMBER, BURNT_SIENNA, CRIMSON, MAGENTA]
</pre>
<p>&lt;/spoiler&gt;
В выходных данных показаны результаты выполнения каждой операции. В следующем примере представлены варианты вызова <i><b>Sets.difference()</b></i> для разных классов <i><b>Collection</b></i> и <i><b>Map</b></i> из <i><b>java.util</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: net/mindview/util/ContainerMethodDifferences.java</span>
<span class="kw2">package</span> <span class="co2">net.mindview.util</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.lang.reflect.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ContainerMethodDifferences <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> methodSet<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;?&gt;</span> type<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">TreeSet</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw26">Method</span> m&nbsp;: type.<span class="me1">getMethods</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      result.<span class="me1">add</span><span class="br0">(</span>m.<span class="me1">getName</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> interfaces<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;?&gt;</span> type<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span><span class="st0">"Interfaces in "</span> +
      type.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">": "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;?&gt;</span> c&nbsp;: type.<span class="me1">getInterfaces</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
      result.<span class="me1">add</span><span class="br0">(</span>c.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>result<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> object = methodSet<span class="br0">(</span><span class="kw166">Object</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="br0">{</span> object.<span class="me1">add</span><span class="br0">(</span><span class="st0">"clone"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span>
  difference<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;?&gt;</span> superset, <span class="kw21">Class</span><span class="sy0">&lt;?&gt;</span> subset<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>superset.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span> +
      <span class="st0">" extends "</span> + subset.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span> + <span class="st0">", adds: "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Set</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> comp = Sets.<span class="me1">difference</span><span class="br0">(</span>
      methodSet<span class="br0">(</span>superset<span class="br0">)</span>, methodSet<span class="br0">(</span>subset<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    comp.<span class="me1">removeAll</span><span class="br0">(</span>object<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Don't show 'Object' methods</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>comp<span class="br0">)</span><span class="sy0">;</span>
    interfaces<span class="br0">(</span>superset<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Collection: "</span> +
      methodSet<span class="br0">(</span><span class="kw46">Collection</span>.<span class="kw2">class</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    interfaces<span class="br0">(</span><span class="kw46">Collection</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">Set</span>.<span class="kw2">class</span>, <span class="kw46">Collection</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">HashSet</span>.<span class="kw2">class</span>, <span class="kw46">Set</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">LinkedHashSet</span>.<span class="kw2">class</span>, <span class="kw46">HashSet</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">TreeSet</span>.<span class="kw2">class</span>, <span class="kw46">Set</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw166">List</span>.<span class="kw2">class</span>, <span class="kw46">Collection</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">ArrayList</span>.<span class="kw2">class</span>, <span class="kw166">List</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">LinkedList</span>.<span class="kw2">class</span>, <span class="kw166">List</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">Queue</span>.<span class="kw2">class</span>, <span class="kw46">Collection</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">PriorityQueue</span>.<span class="kw2">class</span>, <span class="kw46">Queue</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"Map: "</span> + methodSet<span class="br0">(</span><span class="kw46">Map</span>.<span class="kw2">class</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">HashMap</span>.<span class="kw2">class</span>, <span class="kw46">Map</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">LinkedHashMap</span>.<span class="kw2">class</span>, <span class="kw46">HashMap</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">SortedMap</span>.<span class="kw2">class</span>, <span class="kw46">Map</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    difference<span class="br0">(</span><span class="kw46">TreeMap</span>.<span class="kw2">class</span>, <span class="kw46">Map</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h2><span class="mw-headline" id=".D0.90.D0.BD.D0.BE.D0.BD.D0.B8.D0.BC.D0.BD.D1.8B.D0.B5_.D0.B2.D0.BD.D1.83.D1.82.D1.80.D0.B5.D0.BD.D0.BD.D0.B8.D0.B5_.D0.BA.D0.BB.D0.B0.D1.81.D1.81.D1.8B"><b>Анонимные внутренние классы</b></span></h2>
<p>Параметризация также может применяться к внутренним классам и анонимным внутренним классам. Пример реализации интерфейса <i><b>Generator</b></i> с использованием анонимных внутренних классов:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/BankTeller.java</span>
<span class="co1">//  Очень простая имитация банковского обслуживания.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Customer <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">long</span> counter = <span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">long</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> Customer<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Customer "</span> + id<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// A method to produce Generator objects:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> Generator<span class="sy0">&lt;</span>Customer<span class="sy0">&gt;</span> generator<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> Generator<span class="sy0">&lt;</span>Customer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> Customer next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw2">new</span> Customer<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">class</span> Teller <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">static</span> <span class="kw3">long</span> counter = <span class="nu0">1</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">long</span> id = counter++<span class="sy0">;</span>
  <span class="kw2">private</span> Teller<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="st0">"Teller "</span> + id<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Метод для получения объектов Generator:</span>
  <span class="kw2">public</span> <span class="kw2">static</span> Generator<span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span> generator =
    <span class="kw2">new</span> Generator<span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">public</span> Teller next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw2">new</span> Teller<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BankTeller <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> serve<span class="br0">(</span>Teller t, Customer c<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>t + <span class="st0">" обслуживает "</span> + c<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Queue</span><span class="sy0">&lt;</span>Customer<span class="sy0">&gt;</span> line = <span class="kw2">new</span> <span class="kw46">LinkedList</span><span class="sy0">&lt;</span>Customer<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Generators.<span class="me1">fill</span><span class="br0">(</span>line, Customer.<span class="me1">generator</span><span class="br0">(</span><span class="br0">)</span>, <span class="nu0">15</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span> tellers = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Teller<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Generators.<span class="me1">fill</span><span class="br0">(</span>tellers, Teller.<span class="me1">generator</span>, <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Customer c&nbsp;: line<span class="br0">)</span>
      serve<span class="br0">(</span>tellers.<span class="me1">get</span><span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span>tellers.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>, c<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Teller 3 обслуживает Customer 1
Teller 2 обслуживает Customer 2
Teller 3 обслуживает Customer 3
Teller 1 обслуживает Customer 4
Teller 1 обслуживает Customer 5
Teller 3 обслуживает Customer 6
Teller 1 обслуживает Customer 7
Teller 2 обслуживает Customer 8
Teller 3 обслуживает Customer 9
Teller 3 обслуживает Customer 10
Teller 2 обслуживает Customer 11
Teller 4 обслуживает Customer 12
Teller 2 обслуживает Customer 13
Teller 1 обслуживает Customer 14
Teller 1 обслуживает Customer 15
</pre>
<p>&lt;/spoiler&gt;
И <i><b>Customer</b></i>, и <i><b>Teller</b></i> содержат приватные конструкторы, поэтому для создания их объектов пользователь вынужден использовать объекты <i><b>Generator</b></i>.
</p><p><i><b>Customer</b></i> содержит метод <i><b>generator()</b></i>, который при каждом вызове создает новый объект <i><b>Generator&lt;Customer&gt;</b></i>. На случай, если множественные объекты <i><b>Generator</b></i> вам не понадобятся, в <i><b>Teller</b></i> создается синглетный открытый объект <i><b>generator</b></i>. Оба подхода продемонстрированы в вызовах <i><b>fill()</b></i> внутри <i><b>main()</b></i>.
Поскольку метод <i><b>generator()</b></i> в <i><b>Customer</b></i> и объект <i><b>Generator</b></i> в <i><b>Teller</b></i>
 являются статическими, они не могут быть частью интерфейса, поэтому 
«обобщить» эту конкретную идиому не удастся. Несмотря на это 
обстоятельство, она достаточно хорошо работает в методе <i><b>fill()</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D1.81.D1.82.D1.80.D0.BE.D0.B5.D0.BD.D0.B8.D0.B5_.D1.81.D0.BB.D0.BE.D0.B6.D0.BD.D1.8B.D1.85_.D0.BC.D0.BE.D0.B4.D0.B5.D0.BB.D0.B5.D0.B9"><b>Построение сложных моделей</b></span></h2>
<p>К числу важных преимуществ параметризации относится простота и 
надежность создания сложных моделей. Например, можно легко создать 
список (<i><b>List</b></i>) с элементами-кортежами:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/TupleList.java</span>
<span class="co1">// Построение сложных параметризованных типов путем объединения</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> TupleList<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;</span>
<span class="kw2">extends</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>FourTuple<span class="sy0">&lt;</span>A,B,C,D<span class="sy0">&gt;&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    TupleList<span class="sy0">&lt;</span>Vehicle, Amphibian, <span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span> tl =
      <span class="kw2">new</span> TupleList<span class="sy0">&lt;</span>Vehicle, Amphibian, <span class="kw21">String</span>, <span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    tl.<span class="me1">add</span><span class="br0">(</span>TupleTest.<span class="me1">h</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    tl.<span class="me1">add</span><span class="br0">(</span>TupleTest.<span class="me1">h</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>FourTuple<span class="sy0">&lt;</span>Vehicle,Amphibian,<span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span> i: tl<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>i<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (75% match)
</p>
<pre>(Vehicle@11b86e7, Amphibian@35ce36, hi, 47)
(Vehicle@757aef, Amphibian@d9f9c3, hi, 47)
</pre>
<p>&lt;/spoiler&gt;
Запись получается довольно громоздкой (особенно при создании итератора),
 однако вы получаете довольно сложную структуру данных без излишков 
программного кода.
А вот другой пример, который показывает, как легко строить сложные 
модели на основе параметризованных типов. Хотя каждый класс представляет
 собой автономный «строительный блок», их совокупность имеет сложную 
структуру. В данном случае моделируется магазин с товарами, полками и 
стеллажами:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Store.java</span>
<span class="co1">// Построение сложной модели на базе параметризованных контейнеров</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">net.mindview.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Product <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> id<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw21">String</span> description<span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw3">double</span> price<span class="sy0">;</span>
  <span class="kw2">public</span> Product<span class="br0">(</span><span class="kw3">int</span> IDnumber, <span class="kw21">String</span> descr, <span class="kw3">double</span> price<span class="br0">)</span><span class="br0">{</span>
    id = IDnumber<span class="sy0">;</span>
    description = descr<span class="sy0">;</span>
    <span class="kw2">this</span>.<span class="me1">price</span> = price<span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>toString<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> id + <span class="st0">": "</span> + description + <span class="st0">", price: $"</span> + price<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> priceChange<span class="br0">(</span><span class="kw3">double</span> change<span class="br0">)</span> <span class="br0">{</span>
    price += change<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> Generator<span class="sy0">&lt;</span>Product<span class="sy0">&gt;</span> generator =
    <span class="kw2">new</span> Generator<span class="sy0">&lt;</span>Product<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">private</span> <span class="kw46">Random</span> rand = <span class="kw2">new</span> <span class="kw46">Random</span><span class="br0">(</span><span class="nu0">47</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw2">public</span> Product next<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
        <span class="kw2">return</span> <span class="kw2">new</span> Product<span class="br0">(</span>rand.<span class="me1">nextInt</span><span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span>, <span class="st0">"Test"</span>,
          <span class="kw21">Math</span>.<span class="me1">round</span><span class="br0">(</span>rand.<span class="me1">nextDouble</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">*</span> <span class="nu0">1000.0</span><span class="br0">)</span> + <span class="nu0">0.99</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="br0">}</span>
    <span class="br0">}</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Shelf <span class="kw2">extends</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Product<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> Shelf<span class="br0">(</span><span class="kw3">int</span> nProducts<span class="br0">)</span> <span class="br0">{</span>
    Generators.<span class="me1">fill</span><span class="br0">(</span><span class="kw2">this</span>, Product.<span class="me1">generator</span>, nProducts<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">class</span> Aisle <span class="kw2">extends</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Shelf<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> Aisle<span class="br0">(</span><span class="kw3">int</span> nShelves, <span class="kw3">int</span> nProducts<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> nShelves<span class="sy0">;</span> i++<span class="br0">)</span>
      add<span class="br0">(</span><span class="kw2">new</span> Shelf<span class="br0">(</span>nProducts<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> CheckoutStand <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Office <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Store <span class="kw2">extends</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Aisle<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>CheckoutStand<span class="sy0">&gt;</span> checkouts =
    <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>CheckoutStand<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">private</span> Office office = <span class="kw2">new</span> Office<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> Store<span class="br0">(</span><span class="kw3">int</span> nAisles, <span class="kw3">int</span> nShelves, <span class="kw3">int</span> nProducts<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> nAisles<span class="sy0">;</span> i++<span class="br0">)</span>
      add<span class="br0">(</span><span class="kw2">new</span> Aisle<span class="br0">(</span>nShelves, nProducts<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw21">String</span> toString<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">StringBuilder</span> result = <span class="kw2">new</span> <span class="kw21">StringBuilder</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span>Aisle a&nbsp;: <span class="kw2">this</span><span class="br0">)</span>
      <span class="kw1">for</span><span class="br0">(</span>Shelf s&nbsp;: a<span class="br0">)</span>
        <span class="kw1">for</span><span class="br0">(</span>Product p&nbsp;: s<span class="br0">)</span> <span class="br0">{</span>
          result.<span class="me1">append</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy0">;</span>
          result.<span class="me1">append</span><span class="br0">(</span><span class="st0">"<span class="es0">\n</span>"</span><span class="br0">)</span><span class="sy0">;</span>
        <span class="br0">}</span>
    <span class="kw2">return</span> result.<span class="me1">toString</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw2">new</span> Store<span class="br0">(</span><span class="nu0">14</span>, <span class="nu0">5</span>, <span class="nu0">10</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>258: Test, price: $400.99
861: Test, price: $160.99
868: Test, price: $417.99
207: Test, price: $268.99
551: Test, price: $114.99
278: Test, price: $804.99
520: Test, price: $554.99
140: Test, price: $530.99
</pre>
<p>&lt;/spoiler&gt;
Как видно из <i><b>Store.toString()</b></i>, в результате мы получаем 
многоуровневую архитектуру контейнеров, не лишаясь преимуществ 
безопасности типов и управляемости. Впечатляет и то, что построение 
такой модели не потребует заметных умственных усилий.
</p>
<h2><span class="mw-headline" id=".D0.A2.D0.B0.D0.B9.D0.BD.D0.B0_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D1.8F"><b>Тайна стирания</b></span></h2>
<p>Когда вы приступаете к более глубокому изучению контейнеров, 
некоторые обстоятельства на первых порах выглядят довольно странно. 
Например, запись <i><b>ArrayList.class</b></i> возможна, а запись <i><b>ArrayList&lt;Integer&gt;.class</b></i> — нет. Или возьмите следующий фрагмент:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ErasedTypeEquivalence.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ErasedTypeEquivalence <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">Class</span> c1 = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">Class</span> c2 = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>c1 == c2<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>true
</pre>
<p>&lt;/spoiler&gt;
Было бы логично считать, что <i><b>ArrayList&lt;String&gt;</b></i> и <i><b>ArrayList&lt;Integer&gt;</b></i> — разные типы, поэтому их поведение должно различаться, и при попытке поместить <i><b>Integer</b></i> в <i><b>ArrayList&lt;String&gt;</b></i> результат (неудача) должен отличаться от того, который будет получен при помещении <i><b>Integer</b></i> в <i><b>ArrayList&lt;Integer&gt;</b></i> (успех). Однако эта программа создает впечатление, что эти типы одинаковы. Следующий пример еще сильнее запутывает ситуацию:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/LostInformation.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Frob <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Fnorkle <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Quark<span class="sy0">&lt;</span>Q<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Particle<span class="sy0">&lt;</span>POSITION,MOMENTUM<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> LostInformation <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>Frob<span class="sy0">&gt;</span> list = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Frob<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw46">Map</span><span class="sy0">&lt;</span>Frob,Fnorkle<span class="sy0">&gt;</span> map = <span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span>Frob,Fnorkle<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Quark<span class="sy0">&lt;</span>Fnorkle<span class="sy0">&gt;</span> quark = <span class="kw2">new</span> Quark<span class="sy0">&lt;</span>Fnorkle<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Particle<span class="sy0">&lt;</span><span class="kw21">Long</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span> p = <span class="kw2">new</span> Particle<span class="sy0">&lt;</span><span class="kw21">Long</span>,<span class="kw21">Double</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>
      list.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getTypeParameters</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>
      map.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getTypeParameters</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>
      quark.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getTypeParameters</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>
      p.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getTypeParameters</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[E]
[K, V]
[Q]
[POSITION, MOMENTUM]
</pre>
<p>&lt;/spoiler&gt;
Согласно документации <i>JDK</i>, <i><b>Class.getTypeParameters()</b></i> «возвращает массив объектов <i><b>TypeVariable</b></i>,
 представляющих переменные типов, указанные в параметризованном 
объявлении...» Казалось бы, по ним можно определить параметры типов — 
но, как видно из результатов, вы всего лишь узнаете, какие 
идентификаторы использовались в качестве заполнителей, а эта информация 
не представляет особого интереса.
Мы приходим к холодной, бездушной истине:
Информация о параметрах типов недоступна внутри параметризованного кода.
Таким образом, вы можете узнать идентификатор параметра типа и 
ограничение параметризованного типа, но фактические параметры типов, 
использованные для создания конкретного экземпляра, остаются 
неизвестными. Этот факт, особенно раздражающий программистов с опытом 
работы на <i>C++</i>, является основной проблемой, которую приходится решать при использовании параметризации в <i>Java</i>.
</p><p>Параметризация в <i>Java</i> реализуется с применением стирания (<i>erasure</i>).
 Это означает, что при использовании параметризации вся конкретная 
информация о типе утрачивается. Внутри параметризованного кода вы знаете
 только то, что используется некий объект. Таким образом, <i><b>List&lt;String&gt;</b></i> и <i><b>List&lt;Integer&gt;</b></i> действительно являются одним типом во время выполнения; обе формы «стираются» до своего низкоуровневого типа <i><b>List</b></i>. Именно стирание и создаваемые им проблемы становятся главной преградой при изучении параметризации в <i>Java</i>; этой теме и будет посвящен настоящий раздел.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D0.B4.D1.85.D0.BE.D0.B4_C.2B.2B"><b>Подход <i>C++</i></b></span></h2>
<p>В следующем примере, написанном на <i>C++</i>, используются шаблоны. Синтаксис параметризованных типов выглядит знакомо, потому что многие идеи <i>C++</i> были взяты за основу при разработке <i>Java</i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="c source-c"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
using namespace std<span class="sy0">;</span>
&nbsp;
template<span class="sy0">&lt;</span>class T<span class="sy0">&gt;</span> class Manipulator <span class="br0">{</span>
  T obj<span class="sy0">;</span>
public<span class="sy0">:</span>
  Manipulator<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> obj <span class="sy0">=</span> x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw4">void</span> manipulate<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> obj.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
class HasF <span class="br0">{</span>
public<span class="sy0">:</span>
  <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> cout <span class="sy0">&lt;&lt;</span> <span class="st0">"HasF::f()"</span> <span class="sy0">&lt;&lt;</span> endl<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy0">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
  HasF hf<span class="sy0">;</span>
  Manipulator<span class="sy0">&lt;</span>HasF<span class="sy0">&gt;</span> manipulator<span class="br0">(</span>hf<span class="br0">)</span><span class="sy0">;</span>
  manipulator.<span class="me1">manipulate</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; 
</p>
<pre>HasF-:f()
</pre>
<p>&lt;/spoiler&gt;
Класс <i><b>Manipulator</b></i> хранит объект типа <i><b>Т</b></i>. Нас здесь интересует метод <i><b>manipulate()</b></i>, который вызывает метод f() для obj. Как он узнает, что у параметра типа Т существует метод <i><b>f()</b></i>? Компилятор <i>C++</i> выполняет проверку при создании экземпляра шаблона, поэтому в точке создания <i><b>Manipulator&lt;HasF&gt;</b></i> он узнает о том, что <i><b>HasF</b></i> содержит метод <i><b>f()</b></i>. В противном случае компилятор выдает ошибку, а безопасность типов сохраняется.
Написать такой код на <i>C++</i> несложно, потому что при создании экземпляра шаблона код шаблона знает тип своих параметров. С параметризацией <i>Java</i> дело обстоит иначе. Вот как выглядит версия <i><b>HasF</b></i>, переписанная на <i>Java</i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/HasF.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> HasF <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="st0">"HasF.f()"</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Если мы возьмем остальной код примера и перепишем его на <i>Java</i>, он не будет компилироваться:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Manipulation.java</span>
<span class="co1">//  {CompileTimeError} (He компилируется)</span>
&nbsp;
<span class="kw2">class</span> Manipulator<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T obj<span class="sy0">;</span>
  <span class="kw2">public</span> Manipulator<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> obj = x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Error: cannot find symbol: method f():</span>
  <span class="kw2">public</span> <span class="kw3">void</span> manipulate<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> obj.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Manipulation <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    HasF hf = <span class="kw2">new</span> HasF<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Manipulator<span class="sy0">&lt;</span>HasF<span class="sy0">&gt;</span> manipulator =
      <span class="kw2">new</span> Manipulator<span class="sy0">&lt;</span>HasF<span class="sy0">&gt;</span><span class="br0">(</span>hf<span class="br0">)</span><span class="sy0">;</span>
    manipulator.<span class="me1">manipulate</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Из-за стирания компилятор <i>Java</i> не может сопоставить требование о возможности вызова <i><b>f()</b></i> для <i><b> obj</b></i> из <i><b>manipulate()</b></i> с тем фактом, что <i><b>HasF</b></i> содержит метод <i><b>f()</b></i>. Чтобы вызвать <i><b>f()</b></i>,
 мы должны «помочь» параметризованному классу, и передать ему 
ограничение; компилятор принимает только те типы, которые соответствуют 
указанному ограничению. Для задания ограничения используется ключевое 
слово <i><b>extends</b></i>. При заданном ограничении следующий фрагмент компилируется нормально:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Manipulator2.java</span>
<span class="kw2">class</span> Manipulator2<span class="sy0">&lt;</span>T <span class="kw2">extends</span> HasF<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T obj<span class="sy0">;</span>
  <span class="kw2">public</span> Manipulator2<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> obj = x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> manipulate<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> obj.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Ограничение <i><b>&lt;T extends HasF&gt;</b></i> указывает на то, что параметр <i><b>Т</b></i> должен относиться к типу <i><b>HasF</b></i> или производному от него. Если это условие выполняется, то вызов <i><b>f()</b></i> для <i><b>obj</b></i>
 безопасен.
Можно сказать, что параметр типа стирается до первого ограничения (как 
будет показано позже, ограничений может быть несколько). Мы также 
рассмотрим понятие стирания параметра типа. Компилятор фактически 
заменяет параметр типа его «стертой» версией, так что в предыдущем 
случае <i><b>Т</b></i> стирается до <i><b>HasF</b></i>, а результат получается таким, как при замене <i><b>Т</b></i> на <i><b>HasF</b></i> в теле класса.
Справедливости ради нужно заметить, что в <i><b>Manipulation2.java</b></i>
 параметризация никакой реальной пользы не дает. С таким же успехом 
можно выполнить стирание самостоятельно, создав непараметризованный 
класс:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Manipulator3.java</span>
<span class="kw2">class</span> Manipulator3 <span class="br0">{</span>
  <span class="kw2">private</span> HasF obj<span class="sy0">;</span>
  <span class="kw2">public</span> Manipulator3<span class="br0">(</span>HasF x<span class="br0">)</span> <span class="br0">{</span> obj = x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> manipulate<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> obj.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Мы приходим к важному заключению: параметризация полезна только 
тогда, когда вы хотите использовать параметры типов, более «общие», 
нежели конкретный тип (и производные от него), то есть когда код должен 
работать для разных классов. В результате параметры типов и их 
применение в параметризованном коде сложнее простой замены классов. 
Впрочем, это не означает, что форма <i><b>&lt;Т extends HasF&gt;</b></i> чем-то ущербна. Например, если класс содержит метод, возвращающий <i><b>Т</b></i>, то параметризация будет полезной, потому что метод вернет точный тип:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ReturnGenericType.java</span>
<span class="kw2">class</span> ReturnGenericType<span class="sy0">&lt;</span>T <span class="kw2">extends</span> HasF<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T obj<span class="sy0">;</span>
  <span class="kw2">public</span> ReturnGenericType<span class="br0">(</span>T x<span class="br0">)</span> <span class="br0">{</span> obj = x<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> obj<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Просмотрите код и подумайте, достаточно ли он «сложен» для применения параметризации.
Ограничения будут более подробно рассмотрены далее в этой главе.
</p>
<h2><span class="mw-headline" id=".D0.9C.D0.B8.D0.B3.D1.80.D0.B0.D1.86.D0.B8.D0.BE.D0.BD.D0.BD.D0.B0.D1.8F_.D1.81.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D1.8C"><b>Миграционная совместимость</b></span></h2>
<p>Чтобы избежать всех потенциальных недоразумений со стиранием, 
необходимо четко понимать, что этот механизм не является особенностью 
языка. Скорее это компромисс, использованный при реализации 
параметризации в <i>Java</i>, потому что параметризация не являлась 
частью языка в его исходном виде. Этот компромисс создает определенные 
неудобства, поэтому вы должны поскорее привыкнуть к нему и понять, 
почему он существует.
Если бы параметризация была частью <i>Java</i> 1.0, то для ее реализации
 стирание не потребовалось бы — параметры типов сохранили бы свой статус
 равноправных компонентов языка, и с ними можно было бы выполнять 
типизованные языковые и рефлексивные операции. Позднее в этой главе 
будет показано, что стирание снижает «обобщенность» параметризованных 
типов. Параметризация в <i>Java</i> все равно приносит пользу, но не 
такую, какую могла бы приносить, и причиной тому является стирание.
В реализации, основанной на стирании, параметризованные типы 
рассматриваются как второстепенные компоненты языка, которые не могут 
использоваться в некоторых важных контекстах. Параметризованные типы 
присутствуют только при статической проверке типов, после чего каждый 
параметризованный тип в программе заменяется параметризованным верхним 
ограничением. Например, обозначения типов вида <i><b>List&lt;T&gt;</b></i> стирается до <i><b>List</b></i>, а обычные переменные типа — до <i><b>Object</b></i>,
 если ограничение не задано.
Главная причина для применения стирания заключается в том, что оно 
позволяет параметризованным клиентам использовать ^параметризованные 
библиотеки, и наоборот. Эта концепция часто называется миграционной 
совместимостью. Наверное, в идеальном мире параметризация была бы 
внедрена везде и повсюду одновременно. На практике программисту, даже 
если он пишет только параметризованный код, приходится иметь дело с 
параметризованными библиотеками, написанными до <i>Java</i> <i>SE5</i>. Возможно, авторы этих библиотек вообще не намерены параметризовать свой код или собираются сделать это в будущем.
Из-за этого механизму параметризации <i>Java</i> приходится поддерживать
 не только обратную совместимость (существующий код и файлы классов 
остаются абсолютно законными и сохраняют свой прежний смысл), но и 
миграционную совместимость — чтобы библиотеки могли переводиться в 
параметризованную форму в собственном темпе, причем их параметризация не
 влияла бы на работу зависящего от него кода и приложений. Выбрав эту 
цель, проектировщики <i>Java</i> и различные группы, работавшие над 
проблемой, решили, что единственным приемлемым решением является 
стирание, позволяющее непараметризованному коду нормально сосуществовать
 с параметризованным.
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC.D1.8B_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D1.8F"><b>Проблемы стирания</b></span></h2>
<p>Итак, главным аргументом для применения стирания является процесс 
перехода с непараметризованного кода на параметризованный и интеграция 
параметризации в язык без нарушения работы существующих библиотек. 
Стирание позволяет использовать существующий ^параметризованный код без 
изменений, пока клиент не будет готов переписать свой код с 
использованием параметризации.
Однако за стирание приходится расплачиваться. Параметризованные типы не 
могут использоваться в операциях, в которых явно задействованы типы 
времени выполнения — преобразования типов, <i><b>instanceof</b></i> и выражения <i><b>new</b></i>.
 Вся ин­формация о типах параметров теряется, и при написании 
параметризованного кода вам придется постоянно напоминать себе об этом. 
Допустим, вы пишете фрагмент кода
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">class</span> Foo<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span> 
     T var<span class="sy0">;</span>
 <span class="br0">}</span></pre></div></div>
<p>Может показаться, что при создании экземпляра <i><b>Foo</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> Foo<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span> f = <span class="kw2">new</span> Foo<span class="sy0">&lt;</span>Cat<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span></pre></div></div>
<p>код <i><b>class Foo</b></i> должен знать, что он работает с <i><b>Cat</b></i>. Синтаксис создает впечатление, что тип <i><b> Т</b></i>
 подставляется повсюду внутри класса. Но на самом деле это не так, и при
 написании кода для класса вы должны постоянно напоминать себе: «Нет, 
это всего лишь <i><b>Object</b></i>».
Кроме того, стирание и миграционная совместимость означают, что контроль
 за использованием параметризации не настолько жесткий, как хотелось бы:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ErasureAndInheritance.java</span>
<span class="kw2">class</span> GenericBase<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T element<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span>T arg<span class="br0">)</span> <span class="br0">{</span> arg = element<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> element<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Derived1<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw2">extends</span> GenericBase<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Derived2 <span class="kw2">extends</span> GenericBase <span class="br0">{</span><span class="br0">}</span> <span class="co1">// Без предупреждений</span>
&nbsp;
<span class="co1">// class Derived3 extends GenericBase&lt;?&gt; {}</span>
<span class="co1">// Странная ошибка.</span>
<span class="co1">// Обнаружен непредвиденный тип&nbsp;:&nbsp;?</span>
<span class="co1">// требуется- класс или интерфейс без ограничений	</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ErasureAndInheritance <span class="br0">{</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Derived2 d2 = <span class="kw2">new</span> Derived2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">Object</span> obj = d2.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    d2.<span class="me1">set</span><span class="br0">(</span>obj<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Warning here!</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><i><b>Derived2</b></i> наследует от <i><b>GenericBase</b></i> без параметризации, и компилятор не выдает при этом никаких предупреждений. Предупреждение выводится позже, при вызове <i><b>set()</b></i>.
Для подавления этого предупреждения в <i>Java</i> существует директива, приведенная в листинге (до выхода <i>Java</i> SE5 она не поддерживалась):
</p>
<pre>@SuppressWarnings("unchecked")
</pre>
<p>Обратите внимание: директива применяется к методу, генерирующему 
предупреждение, а не ко всему классу. При подавлении предупреждений 
желательно действовать в самых узких рамках, чтобы случайно не скрыть 
настоящую проблему.
Ошибка, выдаваемая в <i><b>Derived3</b></i>, означает, что компилятор 
рассчитывает увидеть «обычный» базовый класс. Добавьте к этому 
дополнительные усилия на управление ограничениями, если вы не желаете 
интерпретировать параметр типа как простой <i><b>Object</b></i>, — и что
 мы получаем в остатке? Гораздо больше хлопот при гораздо меньше, пользе
 по сравнению с параметризованными типами в языках вроде <i>C++</i>, <i>Ada</i> или <i>Eiffel</i>. Конечно, это вовсе не означает, что эти языки в целом эффективнее <i>Java</i>
 в большинстве задач программирования, а говорит лишь о том, что их 
механизмы параметризации типов отличаются большей гибкостью и мощью, чем
 в <i>Java</i>.
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B1.D0.BB.D0.B5.D0.BC.D1.8B_.D0.BD.D0.B0_.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.86.D0.B0.D1.85"><b>Проблемы на границах</b></span></h2>
<p>Пожалуй, самый странный аспект параметризации, обусловленный 
стиранием, заключается в возможности представления заведомо 
бессмысленных вещей. Пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ArrayMaker.java</span>
<span class="kw2">import</span> <span class="co2">java.lang.reflect.*</span><span class="sy0">;</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArrayMaker<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> kind<span class="sy0">;</span>
  <span class="kw2">public</span> ArrayMaker<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> kind<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">kind</span> = kind<span class="sy0">;</span> <span class="br0">}</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  T<span class="br0">[</span><span class="br0">]</span> create<span class="br0">(</span><span class="kw3">int</span> size<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw166">Array</span>.<span class="me1">newInstance</span><span class="br0">(</span>kind, size<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    ArrayMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> stringMaker =
      <span class="kw2">new</span> ArrayMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="kw21">String</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> stringArray = stringMaker.<span class="me1">create</span><span class="br0">(</span><span class="nu0">9</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="kw46">Arrays</span>.<span class="me1">toString</span><span class="br0">(</span>stringArray<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[null, null, null. null, null, null. null. null, null]
</pre>
<p>&lt;/spoiler&gt;
Несмотря на то что объект <i><b>kind</b></i> хранится в виде <i><b>Class&lt;T&gt;</b></i>, стирание означает, что фактически он хранится в виде <i><b>Class</b></i> без параметра. Следовательно, при выполнении с ним каких-либо операций (например, при создании массива) <i><b>Array.newInstance()</b></i> не обладает информацией о типе, подразумеваемой <i><b>kind</b></i>.
 Метод не сможет выдать нужный результат, не требующий преобразования 
типа, а это приводит к выдаче предупреждения, с которым вам не удастся 
справиться.
Обратите внимание: для создания массивов в параметризованном коде 
рекомендуется использовать <i><b> Array.newInstance()</b></i>.
Если вместо массива создается другой контейнер, ситуация меняется:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ListMaker.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ListMaker<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> create<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    ListMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> stringMaker= <span class="kw2">new</span> ListMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> stringList = stringMaker.<span class="me1">create</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Компилятор не выдает предупреждений, хотя мы знаем, что <i><b>&lt;Т&gt;</b></i> в <i><b>new ArrayList&lt;T&gt;()</b></i> внутри <i><b>create()</b></i> удаляется — во время выполнения <i><b>&lt;Т&gt;</b></i>
 внутри класса нет, поэтому здесь его присутствие выглядит 
бессмысленным. Однако если вы попробуете применить эту идею на практике и
 преобразуете выражение в <i><b>new ArrayList()</b></i>, компилятор 
выдаст предупреждение.
Но действительно ли этот элемент не имеет смысла? Что произойдет, если 
мы поместим в список несколько объектов, прежде чем возватим его?
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/FilledListMaker.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FilledListMaker<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> create<span class="br0">(</span>T t, <span class="kw3">int</span> n<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> result = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> n<span class="sy0">;</span> i++<span class="br0">)</span>
      result.<span class="me1">add</span><span class="br0">(</span>t<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> result<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    FilledListMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> stringMaker =
      <span class="kw2">new</span> FilledListMaker<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">List</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> list = stringMaker.<span class="me1">create</span><span class="br0">(</span><span class="st0">"Hello"</span>, <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>list<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>[Hello, Hello. Hello. Hello]
</pre>
<p>&lt;/spoiler&gt;
Хотя компилятор ничего не может знать о <i><b>Т</b></i> в <i><b>create()</b></i>, он все равно способен проверить — на стадии компиляции — что заносимые в <i><b>result</b></i> объекты имеют тип <i><b>Т</b></i> и согласуются с <i><b> ArrayList&lt;T&gt;</b></i>.
 Таким образом, несмотря на то что стирание удаляет информацию о 
фактическом типе внутри метода или класса, компилятор все равно может 
проверить корректность использования типа в методе или классе.
Так как стирание удаляет информацию о типе внутри тела метода, на стадии
 выполнения особую роль приобретают границы — точки, в которых объект 
входит и выходит из метода. Именно в этих точках компилятор выполняет 
проверку типов и вставляет код преобразования. Рассмотрим следующий 
параметризованный пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/SimpleHolder.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> SimpleHolder <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">Object</span> obj<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span><span class="kw166">Object</span> obj<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">obj</span> = obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw166">Object</span> get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    SimpleHolder holder = <span class="kw2">new</span> SimpleHolder<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    holder.<span class="me1">set</span><span class="br0">(</span><span class="st0">"Item"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s = <span class="br0">(</span><span class="kw21">String</span><span class="br0">)</span>holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Декомпилировав результат командой <i><b>javap -с SimpleHolder</b></i>, мы получим (после редактирования):
&lt;spoiler text="Byte-code:"&gt;
</p>
<pre>public void set(java lang Object);

0: aload_0
1: aload 1
2: putfield #2; II Поле obj.Object;
5: return public java lang.Object get().
0: aload 0
1: getfield #2; II Поле obj-Object,
4: areturn public static void main(java lang.StringE]);
0: new #3, // Класс SimpleHolder
3: dup
4: invokespecial #4; // Метод "&lt;init&gt;".()V
7: astore_l
8: aload 1
9: ldc #5; II String Item
11: invokevirtual #6; // Метод set (Object;)V
14: aload_l
15: invokevirtual #7, // Метод get:()Object:
18: checkcast #8, //'Класс java/lang/String
21: astore_2
22: return
</pre>
<p>&lt;/spoiler&gt;
Методы <i><b>set()</b></i> и <i><b>get()</b></i> просто записывают и читают значение, а преобразование проверяется в точке вызова <i><b>get()</b></i>.
Теперь включим параметризацию в приведенный фрагмент:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericHolder.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> GenericHolder<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T obj<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span>T obj<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">obj</span> = obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericHolder<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> holder =
      <span class="kw2">new</span> GenericHolder<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    holder.<span class="me1">set</span><span class="br0">(</span><span class="st0">"Item"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Необходимость преобразования выходного значения <i><b>get()</b></i> отпала, но мы также знаем, что тип значения, передаваемого <i><b>set(</b></i>), проверяется во время компиляции. Соответствующий байт-код:
&lt;spoiler text="Byte-code:"&gt; 
</p>
<pre>public void set(java.lang.Object);

0:aload_0
1:aload_l
2:putfield #2: // Поле obj:0bject:
5:return public java.lang.Object get():
0:aload_0
1:getfield #2; // Поле obj:0bject:
4:areturn public static void main(java.lang.String[]);
0.new #3: // Класс GenericHolder
3:dup
4:invokespecial #4; // Метод "&lt;init&gt;"-()V
7:astore_l
8:aload_l
9:ldc #5; // String Item
11:invokevirtual #6; II Метод set:(Object:)V
14:aload_l
15:invokevirtual #7; // Метод get:()Object:
18:checkcast #8: // Класс java/lang/String
21:astore_2
22:return
</pre>
<p>&lt;/spoiler&gt;
Как видите, байт-код идентичен. Дополнительная работа по проверке входного типа <i><b>set()</b></i> выполняется компилятором «бесплатно». Преобразование выходного значения <i><b>get()</b></i>
 по-прежнему сохранилось, но, по крайней мере, вам не приходится 
выполнять его самостоятельно — оно автоматически вставляется 
компилятором.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.BF.D0.B5.D0.BD.D1.81.D0.B0.D1.86.D0.B8.D1.8F_.D0.B7.D0.B0_.D1.81.D1.82.D0.B8.D1.80.D0.B0.D0.BD.D0.B8.D0.B5"><b>Компенсация за стирание</b></span></h2>
<p>Как мы видели, в результате стирания становится невозможным 
выполнение некоторых операций в параметризованном коде. Все, для чего 
необходима точная информация о типе во время выполнения, работать не 
будет:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Erased.java</span>
<span class="co1">// {CompileTimeError} (He компилируется)</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Erased<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw2">final</span> <span class="kw3">int</span> SIZE = <span class="nu0">100</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> f<span class="br0">(</span><span class="kw166">Object</span> arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw1">if</span><span class="br0">(</span>arg <span class="kw2">instanceof</span> T<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>          <span class="co1">// Error</span>
    T var = <span class="kw2">new</span> T<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>                 <span class="co1">// Error</span>
    T<span class="br0">[</span><span class="br0">]</span> array = <span class="kw2">new</span> T<span class="br0">[</span>SIZE<span class="br0">]</span><span class="sy0">;</span>         <span class="co1">// Error</span>
    T<span class="br0">[</span><span class="br0">]</span> array = <span class="br0">(</span>T<span class="br0">)</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span>SIZE<span class="br0">]</span><span class="sy0">;</span> <span class="co1">// Unchecked warning</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Иногда такие проблемы удается обойти на программном уровне, но в 
отдельных случаях стирание приходится компенсировать посредством 
введения метки типа. Другими словами, вы явно передаете объект <i><b>Class</b></i> для своего типа.
Например, попытка использования <i><b>instanceof</b></i> в предыдущем примере завершилась неудачей из-за того, что информация о типе была стерта. При введении метки типа вместо <i><b>instanceof</b></i> можно использовать динамический метод <i><b>isInstance()</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ClassTypeCapture.java</span>
<span class="kw2">class</span> Building <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> House <span class="kw2">extends</span> Building <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ClassTypeCapture<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> kind<span class="sy0">;</span>
  <span class="kw2">public</span> ClassTypeCapture<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> kind<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">this</span>.<span class="me1">kind</span> = kind<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">boolean</span> f<span class="br0">(</span><span class="kw166">Object</span> arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> kind.<span class="me1">isInstance</span><span class="br0">(</span>arg<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    ClassTypeCapture<span class="sy0">&lt;</span>Building<span class="sy0">&gt;</span> ctt1 =
      <span class="kw2">new</span> ClassTypeCapture<span class="sy0">&lt;</span>Building<span class="sy0">&gt;</span><span class="br0">(</span>Building.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ctt1.<span class="me1">f</span><span class="br0">(</span><span class="kw2">new</span> Building<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ctt1.<span class="me1">f</span><span class="br0">(</span><span class="kw2">new</span> House<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    ClassTypeCapture<span class="sy0">&lt;</span>House<span class="sy0">&gt;</span> ctt2 =
      <span class="kw2">new</span> ClassTypeCapture<span class="sy0">&lt;</span>House<span class="sy0">&gt;</span><span class="br0">(</span>House.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ctt2.<span class="me1">f</span><span class="br0">(</span><span class="kw2">new</span> Building<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>ctt2.<span class="me1">f</span><span class="br0">(</span><span class="kw2">new</span> House<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; 
</p>
<pre>true
true
false
true 
</pre>
<p>&lt;/spoiler&gt;
Компилятор следит за тем, чтобы метка типа соответствовала обобщенному аргументу.
</p>
<h2><span class="mw-headline" id=".D0.A1.D0.BE.D0.B7.D0.B4.D0.B0.D0.BD.D0.B8.D0.B5_.D1.8D.D0.BA.D0.B7.D0.B5.D0.BC.D0.BF.D0.BB.D1.8F.D1.80.D0.BE.D0.B2_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2"><b>Создание экземпляров типов</b></span></h2>
<p>Попытка создания <i><b>new T()</b></i> в <i><b>Erased.java</b></i> не работает отчасти из-за стирания, а отчасти из-за того, что компилятор не может убедиться в наличии у <i><b>Т</b></i> конструктора по умолчанию (без аргументов). Но в <i>C++</i> эта операция естественна, прямолинейна и безопасна (проверка выполняется во время компиляции):
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/InstantiateGenericType.java</span>
<span class="kw2">import</span> <span class="kw2">static</span> <span class="co2">net.mindview.util.Print.*</span><span class="sy0">;</span>
<span class="kw2">class</span> ClassAsFactory<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  T x<span class="sy0">;</span>
  <span class="kw2">public</span> ClassAsFactory<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> kind<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      x = kind.<span class="me1">newInstance</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">throw</span> <span class="kw2">new</span> <span class="kw21">RuntimeException</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Employee <span class="br0">{</span><span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> InstantiateGenericType <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    ClassAsFactory<span class="sy0">&lt;</span>Employee<span class="sy0">&gt;</span> fe =
      <span class="kw2">new</span> ClassAsFactory<span class="sy0">&lt;</span>Employee<span class="sy0">&gt;</span><span class="br0">(</span>Employee.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    print<span class="br0">(</span><span class="st0">"ClassAsFactory&lt;Employee&gt; успех"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      ClassAsFactory<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> fi =
        <span class="kw2">new</span> ClassAsFactory<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="kw21">Integer</span>.<span class="kw2">class</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span>
      print<span class="br0">(</span><span class="st0">"ClassAsFactory&lt;Integer&gt; неудача"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>ClassAsFactory&lt;Employee&gt; успех 
ClassAsFactory&lt;Integer&gt; неудача 
</pre>
<p>&lt;/spoiler&gt;
Программа компилируется, но с <i><b>ClassAsFactory&lt;Integer&gt;</b></i> происходит сбой, так как <i><b>Integer</b></i>
 не имеет конструктора по умолчанию. Ошибка не обнаруживается во время 
компиляции, поэтому специалисты из Sun считают такие решения 
нежелательными. Вместо этого рекомендуется использовать явную фабрику и 
ограничивать тип, чтобы принимался только класс, реализующий эту 
фабрику:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/FactoryConstraint.java</span>
<span class="kw2">interface</span> FactoryI<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  T create<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Foo2<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T x<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="sy0">&lt;</span>F <span class="kw2">extends</span> FactoryI<span class="sy0">&lt;</span>T<span class="sy0">&gt;&gt;</span> Foo2<span class="br0">(</span>F factory<span class="br0">)</span> <span class="br0">{</span>
    x = factory.<span class="me1">create</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="co1">// ...</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> IntegerFactory <span class="kw2">implements</span> FactoryI<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw21">Integer</span> create<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="kw2">new</span> <span class="kw21">Integer</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">class</span> Widget <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">class</span> Factory <span class="kw2">implements</span> FactoryI<span class="sy0">&lt;</span>Widget<span class="sy0">&gt;</span> <span class="br0">{</span>
    <span class="kw2">public</span> Widget create<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
      <span class="kw2">return</span> <span class="kw2">new</span> Widget<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> FactoryConstraint <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">new</span> Foo2<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> IntegerFactory<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">new</span> Foo2<span class="sy0">&lt;</span>Widget<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> Widget.<span class="me1">Factory</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>В сущности, это всего лишь разновидность передачи <i><b>Class&lt;T&gt;</b></i>. В обоих вариантах передаются объекты фабрик; просто в случае с <i><b>Class&lt;T&gt;</b></i>
 объект фабрики оказывается встроенным, а при предыдущем решении он 
создается явно. Тем не менее в обоих случаях реализуется проверка 
времени компиляции.
Другое решение основано на использовании паттерна «шаблонный метод». В 
следующем примере <i><b>get()</b></i> — шаблонный метод, a <i><b>create()</b></i> определяется в субклассе для получения объекта этого типа:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/CreatorGeneric.java</span>
<span class="kw2">abstract</span> <span class="kw2">class</span> GenericWithCreate<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">final</span> T element<span class="sy0">;</span>
  GenericWithCreate<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> element = create<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">abstract</span> T create<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> X <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Creator <span class="kw2">extends</span> GenericWithCreate<span class="sy0">&lt;</span>X<span class="sy0">&gt;</span> <span class="br0">{</span>
  X create<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw2">new</span> X<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>element.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CreatorGeneric <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Creator c = <span class="kw2">new</span> Creator<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    c.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>X
</pre>
<p>&lt;/spoiler&gt;
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.9C.D0.B0.D1.81.D1.81.D0.B8.D0.B2.D1.8B_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2"><b>Массивы параметризованных типов</b></span></h2>
<p>Как мы видели в <i><b>Erased.java</b></i>, создавать массивы 
параметризованных типов нельзя. Везде, где возникает необходимость в 
создании таких массивов, следует применять <i><b>ArrayList</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ListOfGenerics.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ListOfGenerics<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> array = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> add<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> array.<span class="me1">add</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="kw3">int</span> index<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> array.<span class="me1">get</span><span class="br0">(</span>index<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>При этом вы получаете поведение массивов с безопасностью типов на стадии компиляции, возможной для параметризации.
Впрочем, иногда бывает нужно создать именно массив параметризованных типов (скажем, во внутренней реализации <i><b>ArrayList</b></i> используются массивы). Оказывается, можно переопределить ссылку так, чтобы предотвратить протесты компилятора. Пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ArrayOfGenericReference.java</span>
<span class="kw2">class</span> Generic<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> ArrayOfGenericReference <span class="br0">{</span>
  <span class="kw2">static</span> Generic<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">[</span><span class="br0">]</span> gia<span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Компилятор принимает эту запись без каких-либо предупреждений. С 
другой стороны, вы не сможете создать массив указанного типа (включая 
параметры типа), поэтому все это сбивает с толку. Поскольку все массивы 
обладают одинаковой структурой (размер каждого элемента и способ 
размещения в памяти) независимо от типа хранящихся данных, создается 
впечатление, что вы сможете создать массив <i><b>Object</b></i> и преобразовать его к нужному типу. Код откомпилируется, но работать не будет — он выдает исключение <i><b>ClassCastException</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/ArrayOfGeneric.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> ArrayOfGeneric <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> SIZE = <span class="nu0">100</span><span class="sy0">;</span>
  <span class="kw2">static</span> Generic<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">[</span><span class="br0">]</span> gia<span class="sy0">;</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Компилируется, но приводит к ClassCastException:</span>
    <span class="co1">//! gia = (Generic&lt;Integer&gt;[])new Object[SIZE];</span>
    <span class="co1">// Тип времени выполнения является "стертым" type:</span>
    gia = <span class="br0">(</span>Generic<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw2">new</span> Generic<span class="br0">[</span>SIZE<span class="br0">]</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>gia.<span class="me1">getClass</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">getSimpleName</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    gia<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> = <span class="kw2">new</span> Generic<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">//! gia[1] = new Object(); // Ошибка компиляции</span>
    <span class="co1">// Обнаруживается несоответствие типов во время компиляции:</span>
    <span class="co1">//! gia[2] = new Generic&lt;Double&gt;();</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>Generic[]
</pre>
<p>&lt;/spoiler&gt;
Проблема в том, что массивы отслеживают свой фактический тип, который 
задается в точке создания массива. Таким образом, даже несмотря на то, 
что <i><b>gia</b></i> преобразуется в <i><b>Generic&lt;Integer&gt;[]</b></i>, эта информация существует только на стадии компиляции (а без директивы <i><b>@SuppressWarnings</b></i> вы получите предупреждение). Во время выполнения мы по-прежнему имеем дело с массивом <i><b>Object</b></i>,
 и это создает проблемы. Успешно создать массив параметризованного типа 
можно только одним способом — создать новый массив «стертого» типа и 
выполнить преобразование.
Рассмотрим чуть более сложный пример. Допустим, имеется простая 
параметризованная «обертка» для массива:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericArray.java</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GenericArray<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T<span class="br0">[</span><span class="br0">]</span> array<span class="sy0">;</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> GenericArray<span class="br0">(</span><span class="kw3">int</span> sz<span class="br0">)</span> <span class="br0">{</span>
    array = <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span>sz<span class="br0">]</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> put<span class="br0">(</span><span class="kw3">int</span> index, T item<span class="br0">)</span> <span class="br0">{</span>
    array<span class="br0">[</span>index<span class="br0">]</span> = item<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="kw3">int</span> index<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> array<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Метод, предоставляющий доступ к базовому представлению:</span>
  <span class="kw2">public</span> T<span class="br0">[</span><span class="br0">]</span> rep<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> array<span class="sy0">;</span> <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericArray<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> gai =
      <span class="kw2">new</span> GenericArray<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Приводит к ClassCastException:</span>
    <span class="co1">//! Integer[] ia = gai.rep();</span>
    <span class="co1">// А так можно</span>
    <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span> oa = gai.<span class="me1">rep</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Как и прежде, мы не можем использовать запись <i><b>Т[] array = new T[sz]</b></i>, поэтому мы создаем массив объектов и преобразуем его.
Метод <i><b>rер()</b></i> возвращает <i><b>Т[]</b></i>; в методе <i><b>main()</b></i> для <i><b>gai</b></i> это должен быть тип <i><b>Integer[]</b></i>, но при попытке вызова и сохранения результата по ссылке на <i><b>Integer[]</b></i> будет получено исключение <i><b>ClassCastException</b></i> — это снова происходит из-за того, что фактическим типом объекта времени выполнения является <i><b>Object[]</b></i>. Если мы немедленно проводим преобразование к <i><b>Т[]</b></i>,
 то на стадии компиляции фактический тип массива теряется и компилятор 
может упустить некоторые потенциальные ошибки. Из-за этого лучше 
использовать в коллекции <i><b>Object[]</b></i>, а затем добавить преобразование к <i><b>Т</b></i> при использовании элемента массива. Вот как это будет выглядеть в примере GenericArray.java:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericArray2.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> GenericArray2<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span> array<span class="sy0">;</span>
  <span class="kw2">public</span> GenericArray2<span class="br0">(</span><span class="kw3">int</span> sz<span class="br0">)</span> <span class="br0">{</span>
    array = <span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span>sz<span class="br0">]</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> put<span class="br0">(</span><span class="kw3">int</span> index, T item<span class="br0">)</span> <span class="br0">{</span>
    array<span class="br0">[</span>index<span class="br0">]</span> = item<span class="sy0">;</span>
  <span class="br0">}</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="kw3">int</span> index<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="br0">(</span>T<span class="br0">)</span>array<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">;</span> <span class="br0">}</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> T<span class="br0">[</span><span class="br0">]</span> rep<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span>array<span class="sy0">;</span> <span class="co1">// Предупреждение: непроверенное преобразование</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericArray2<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> gai =
      <span class="kw2">new</span> GenericArray2<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i ++<span class="br0">)</span>
      gai.<span class="me1">put</span><span class="br0">(</span>i, i<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> <span class="nu0">10</span><span class="sy0">;</span> i ++<span class="br0">)</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>gai.<span class="me1">get</span><span class="br0">(</span>i<span class="br0">)</span> + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> ia = gai.<span class="me1">rep</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>0 12 3 4 5 6 7 8 9
java.lang.ClassCastException: 
[Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;
</pre>
<p>&lt;/spoiler&gt;
На первый взгляд почти ничего не изменилось, разве что преобразование типа было перемещено. Без директив <i><b>@SuppressWarnings</b></i> вы по-прежнему будете получать предупреждения, но теперь во внутренней реализации используется <i><b>Object[]</b></i> вместо <i><b>Т[]</b></i>. При вызове <i><b>get()</b></i> объект преобразуется к <i><b> Т</b></i>; это правильный тип, поэтому преобразование безопасно. Но при вызове <i><b>rер()</b></i> снова делается попытка преобразования <i><b>Object[]</b></i> в <i><b>Т[]</b></i>,
 которое остается неверным; в результате вы получите предупреждение во 
время компиляции и исключение во время выполнения. Не существует способа
 обойти тип базового массива, которым может быть только <i><b>Object[]</b></i>. У внутренней интерпретации <i><b>array</b></i> как <i><b>Object[]</b></i> вместо <i><b>Т[]</b></i>
 есть свои преимущества: например, вы с меньшей вероятностью забудете 
тип массива, что приведет к случайному появлению ошибок (впрочем, 
подавляющее большинство таких ошибок будет быстро выявлено на стадии 
выполнения).
В новом коде следует передавать метку типа. В обновленной версии <i><b>GenericArray</b></i> выглядит так:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericArrayWithTypeToken.java</span>
<span class="kw2">import</span> <span class="co2">java.lang.reflect.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GenericArrayWithTypeToken<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T<span class="br0">[</span><span class="br0">]</span> array<span class="sy0">;</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> GenericArrayWithTypeToken<span class="br0">(</span><span class="kw21">Class</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> type, <span class="kw3">int</span> sz<span class="br0">)</span> <span class="br0">{</span>
    array = <span class="br0">(</span>T<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw166">Array</span>.<span class="me1">newInstance</span><span class="br0">(</span>type, sz<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> put<span class="br0">(</span><span class="kw3">int</span> index, T item<span class="br0">)</span> <span class="br0">{</span>
    array<span class="br0">[</span>index<span class="br0">]</span> = item<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="kw3">int</span> index<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> array<span class="br0">[</span>index<span class="br0">]</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Expose the underlying representation:</span>
  <span class="kw2">public</span> T<span class="br0">[</span><span class="br0">]</span> rep<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> array<span class="sy0">;</span> <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericArrayWithTypeToken<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span> gai =
      <span class="kw2">new</span> GenericArrayWithTypeToken<span class="sy0">&lt;</span><span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span>
        <span class="kw21">Integer</span>.<span class="kw2">class</span>, <span class="nu0">10</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// This now works:</span>
    <span class="kw21">Integer</span><span class="br0">[</span><span class="br0">]</span> ia = gai.<span class="me1">rep</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Метка типа <i><b>Class&lt;T&gt;</b></i> передается конструктору для 
восстановления информации после стирания, чтобы мы могли создать 
фактический тип нужного массива (предупреждения при преобразовании 
по-прежнему приходится подавлять <i><b>@SuppressWarnings</b></i>). Получив фактический тип, мы возвращаем его для получения желаемых результатов, как видно из <i><b>main()</b></i>.
К сожалению, просмотрев исходный код стандартных библиотек <i>Java</i> <i>SE5</i>, вы увидите, что преобразования массивов <i><b>Object</b></i> в параметризованные типы происходят повсеместно. Например, вот как выглядит копирующий конструктор для создания <i><b>ArrayList</b></i> из <i><b>Collection</b></i> после некоторой правки и упрощения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"> <span class="kw2">public</span> <span class="kw46">ArrayList</span><span class="br0">(</span><span class="kw46">Collection</span> с<span class="br0">)</span> <span class="br0">{</span> 
       size = c.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
       elementData = <span class="br0">(</span>E<span class="br0">[</span><span class="br0">]</span><span class="br0">)</span><span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
       с.<span class="me1">toArray</span><span class="br0">(</span>elementData<span class="br0">)</span>:
 <span class="br0">}</span></pre></div></div>
<p>В <i><b>ArrayList.java</b></i> подобные преобразования встречаются неоднократно. И конечно, при их компиляции выдается множество предупреждений.
</p>
<h2><span class="mw-headline" id=".D0.9E.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.B8.D1.8F"><b>Ограничения</b></span></h2>
<p>Ограничения, уже упоминавшиеся ранее в этой главе, сужают круг 
параметров типов, используемых при параметризации. Хотя это позволяет 
предъявлять требования к типам, к которым применяется ваш 
параметризованный код, у ог­раничений имеется и другой, потенциально 
более важный эффект: возможность вызова методов, определенных в 
ограничивающих типах.
Поскольку стирание уничтожает информацию о типе, при отсутствии 
ограничений для параметров типов могут вызываться только методы <i><b>Object</b></i>.
 Но, если ограничить параметр подмножеством типов, вы сможете вызвать 
методы из этого подмножества. Для установления ограничений в <i>Java</i> используется ключевое слово <i><b>extends</b></i>. Важно понимать, что в контексте параметризации <i><b>extends</b></i> имеет совершенно иной смысл, нежели в обычной ситуации. Следующий пример демонстрирует основы установления ограничений:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/BasicBounds.java</span>
&nbsp;
<span class="kw2">interface</span> HasColor <span class="br0">{</span> java.<span class="me1">awt</span>.<span class="kw6">Color</span> getColor<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Colored<span class="sy0">&lt;</span>T <span class="kw2">extends</span> HasColor<span class="sy0">&gt;</span> <span class="br0">{</span>
  T item<span class="sy0">;</span>
  Colored<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">item</span> = item<span class="sy0">;</span> <span class="br0">}</span>
  T getItem<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item<span class="sy0">;</span> <span class="br0">}</span>
  <span class="co1">// Ограничение позволяет вызвать метод:</span>
  java.<span class="me1">awt</span>.<span class="kw6">Color</span> color<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">getColor</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> <span class="kw6">Dimension</span> <span class="br0">{</span> <span class="kw2">public</span> <span class="kw3">int</span> x, y, z<span class="sy0">;</span> <span class="br0">}</span>
&nbsp;
<span class="co1">// Не работает -- сначала класс, потом интерфейсы:</span>
<span class="co1">// class ColoredDimension&lt;T extends HasColor &amp; Dimension&gt; {</span>
&nbsp;
<span class="co1">// Несколько ограничений-</span>
<span class="kw2">class</span> ColoredDimension<span class="sy0">&lt;</span>T <span class="kw2">extends</span> <span class="kw6">Dimension</span> <span class="sy0">&amp;</span> HasColor<span class="sy0">&gt;</span> <span class="br0">{</span>
  T item<span class="sy0">;</span>
  ColoredDimension<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">item</span> = item<span class="sy0">;</span> <span class="br0">}</span>
  T getItem<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item<span class="sy0">;</span> <span class="br0">}</span>
  java.<span class="me1">awt</span>.<span class="kw6">Color</span> color<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">getColor</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getX<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">x</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">y</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">z</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">interface</span> Weight <span class="br0">{</span> <span class="kw3">int</span> weight<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>	
&nbsp;
<span class="co1">// Как и при наследовании, конкретный класс может быть только один, </span>
<span class="co1">// а интерфейсов может быть несколько:</span>
<span class="kw2">class</span> Solid<span class="sy0">&lt;</span>T <span class="kw2">extends</span> <span class="kw6">Dimension</span> <span class="sy0">&amp;</span> HasColor <span class="sy0">&amp;</span> Weight<span class="sy0">&gt;</span> <span class="br0">{</span>
  T item<span class="sy0">;</span>
  Solid<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">item</span> = item<span class="sy0">;</span> <span class="br0">}</span>
  T getItem<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item<span class="sy0">;</span> <span class="br0">}</span>
  java.<span class="me1">awt</span>.<span class="kw6">Color</span> color<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">getColor</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getX<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">x</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">y</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">z</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> weight<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">weight</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Bounded
<span class="kw2">extends</span> <span class="kw6">Dimension</span> <span class="kw2">implements</span> HasColor, Weight <span class="br0">{</span>
  <span class="kw2">public</span> java.<span class="me1">awt</span>.<span class="kw6">Color</span> getColor<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="kw4">null</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">int</span> weight<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="nu0">0</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> BasicBounds <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Solid<span class="sy0">&lt;</span>Bounded<span class="sy0">&gt;</span> solid =
      <span class="kw2">new</span> Solid<span class="sy0">&lt;</span>Bounded<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> Bounded<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    solid.<span class="me1">color</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    solid.<span class="me1">getY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    solid.<span class="me1">weight</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Вероятно, вы заметили, что пример <i><b>BasicBounds.java</b></i> 
содержат некоторую избыточность, которая может быть устранена 
посредством наследования. С каждым уровнем наследования добавляются 
новые ограничения:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/InheritBounds.java</span>
<span class="kw2">class</span> HoldItem<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  T item<span class="sy0">;</span>
  HoldItem<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">item</span> = item<span class="sy0">;</span> <span class="br0">}</span>
  T getItem<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Colored2<span class="sy0">&lt;</span>T <span class="kw2">extends</span> HasColor<span class="sy0">&gt;</span> <span class="kw2">extends</span> HoldItem<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  Colored2<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">super</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  java.<span class="me1">awt</span>.<span class="kw6">Color</span> color<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">getColor</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> ColoredDimension2<span class="sy0">&lt;</span>T <span class="kw2">extends</span> <span class="kw6">Dimension</span> <span class="sy0">&amp;</span> HasColor<span class="sy0">&gt;</span>
<span class="kw2">extends</span> Colored2<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  ColoredDimension2<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span>  <span class="kw2">super</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getX<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">x</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getY<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">y</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> getZ<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">z</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Solid2<span class="sy0">&lt;</span>T <span class="kw2">extends</span> <span class="kw6">Dimension</span> <span class="sy0">&amp;</span> HasColor <span class="sy0">&amp;</span> Weight<span class="sy0">&gt;</span>
<span class="kw2">extends</span> ColoredDimension2<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  Solid2<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span>  <span class="kw2">super</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">int</span> weight<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> item.<span class="me1">weight</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> InheritBounds <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Solid2<span class="sy0">&lt;</span>Bounded<span class="sy0">&gt;</span> solid2 =
      <span class="kw2">new</span> Solid2<span class="sy0">&lt;</span>Bounded<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> Bounded<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    solid2.<span class="me1">color</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    solid2.<span class="me1">getY</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    solid2.<span class="me1">weight</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p><i><b>HoldItem</b></i> просто хранит объект; это поведение наследуется классом <i><b>Colored2</b></i>, который также требует, чтобы его параметр реализовывал <i><b>HasColor</b></i>. <i><b>ColoredDimension2</b></i> и <i><b>Solid2</b></i>
 продолжают расширение иерархии и добавляют на каждом уровне новые 
ограничения. Теперь методы наследуются, и их не нужно повторять в каждом
 классе.
Пример с большим количеством уровней:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/EpicBattle.java</span>
<span class="co1">// Demonstrating bounds in Java generics.</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">interface</span> SuperPower <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">interface</span> XRayVision <span class="kw2">extends</span> SuperPower <span class="br0">{</span>
  <span class="kw3">void</span> seeThroughWalls<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw2">interface</span> SuperHearing <span class="kw2">extends</span> SuperPower <span class="br0">{</span>
  <span class="kw3">void</span> hearSubtleNoises<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
<span class="kw2">interface</span> SuperSmell <span class="kw2">extends</span> SuperPower <span class="br0">{</span>
  <span class="kw3">void</span> trackBySmell<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> SuperHero<span class="sy0">&lt;</span>POWER <span class="kw2">extends</span> SuperPower<span class="sy0">&gt;</span> <span class="br0">{</span>
  POWER power<span class="sy0">;</span>
  SuperHero<span class="br0">(</span>POWER power<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">power</span> = power<span class="sy0">;</span> <span class="br0">}</span>
  POWER getPower<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> power<span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> SuperSleuth<span class="sy0">&lt;</span>POWER <span class="kw2">extends</span> XRayVision<span class="sy0">&gt;</span>
<span class="kw2">extends</span> SuperHero<span class="sy0">&lt;</span>POWER<span class="sy0">&gt;</span> <span class="br0">{</span>
  SuperSleuth<span class="br0">(</span>POWER power<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">super</span><span class="br0">(</span>power<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> see<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> power.<span class="me1">seeThroughWalls</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> CanineHero<span class="sy0">&lt;</span>POWER <span class="kw2">extends</span> SuperHearing <span class="sy0">&amp;</span> SuperSmell<span class="sy0">&gt;</span>
<span class="kw2">extends</span> SuperHero<span class="sy0">&lt;</span>POWER<span class="sy0">&gt;</span> <span class="br0">{</span>
  CanineHero<span class="br0">(</span>POWER power<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">super</span><span class="br0">(</span>power<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> hear<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> power.<span class="me1">hearSubtleNoises</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw3">void</span> smell<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> power.<span class="me1">trackBySmell</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> SuperHearSmell <span class="kw2">implements</span> SuperHearing, SuperSmell <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw3">void</span> hearSubtleNoises<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> trackBySmell<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> DogBoy <span class="kw2">extends</span> CanineHero<span class="sy0">&lt;</span>SuperHearSmell<span class="sy0">&gt;</span> <span class="br0">{</span>
  DogBoy<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">super</span><span class="br0">(</span><span class="kw2">new</span> SuperHearSmell<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> EpicBattle <span class="br0">{</span>
  <span class="co1">// Ограничения в параметризованных методах:</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>POWER <span class="kw2">extends</span> SuperHearing<span class="sy0">&gt;</span>
  <span class="kw3">void</span> useSuperHearing<span class="br0">(</span>SuperHero<span class="sy0">&lt;</span>POWER<span class="sy0">&gt;</span> hero<span class="br0">)</span> <span class="br0">{</span>
    hero.<span class="me1">getPower</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">hearSubtleNoises</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>POWER <span class="kw2">extends</span> SuperHearing <span class="sy0">&amp;</span> SuperSmell<span class="sy0">&gt;</span>
  <span class="kw3">void</span> superFind<span class="br0">(</span>SuperHero<span class="sy0">&lt;</span>POWER<span class="sy0">&gt;</span> hero<span class="br0">)</span> <span class="br0">{</span>
    hero.<span class="me1">getPower</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">hearSubtleNoises</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    hero.<span class="me1">getPower</span><span class="br0">(</span><span class="br0">)</span>.<span class="me1">trackBySmell</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    DogBoy dogBoy = <span class="kw2">new</span> DogBoy<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    useSuperHearing<span class="br0">(</span>dogBoy<span class="br0">)</span><span class="sy0">;</span>
    superFind<span class="br0">(</span>dogBoy<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Так можно:</span>
    <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> SuperHearing<span class="sy0">&gt;</span> audioBoys<span class="sy0">;</span>
    <span class="co1">// А так нельзя:</span>
    <span class="co1">// List&lt;? extends SuperHearing &amp; SuperSmell&gt; dogBoys;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h2><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.B0.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B"><b>Метасимволы</b></span></h2>
<p>Мы уже встречали простые примеры использования метасимволов — 
вопросительных знаков в выражениях аргументов параметризации — в главах 
11 и 13. В этом разделе тема будет рассмотрена более подробно.
Начнем с примера, демонстрирующего одну особенность массивов: массив 
производного типа можно присвоить ссылке на массив базового типа:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/CovariantArrays.java</span>
<span class="kw2">class</span> Fruit <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Apple <span class="kw2">extends</span> Fruit <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Jonathan <span class="kw2">extends</span> Apple <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Orange <span class="kw2">extends</span> Fruit <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CovariantArrays <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Fruit<span class="br0">[</span><span class="br0">]</span> fruit = <span class="kw2">new</span> Apple<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy0">;</span>
    fruit<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> = <span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// OK</span>
    fruit<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> = <span class="kw2">new</span> Jonathan<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// OK</span>
    <span class="co1">// Тип времени выполнения - Apple[], а не Fruit[] или Orange[]:</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="co1">// Компилятор позволяет добавлять объекты Fruit:</span>
      fruit<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> = <span class="kw2">new</span> Fruit<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// ArrayStoreException</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      <span class="co1">// Компилятор позволяет добавлять объекты Orange:</span>
      fruit<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> = <span class="kw2">new</span> Orange<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// ArrayStoreException</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>java.1ang.ArrayStoreException: Fruit 
java.1ang.ArrayStoreException: Orange 
</pre>
<p>&lt;/spoiler&gt;
Первая строка <i><b>main()</b></i> создает массив <i><b>Apple</b></i> и присваивает его ссылке на массив <i><b>Fruit</b></i>. Выглядит логично — <i><b>Apple</b></i> является разновидностью <i><b>Fruit</b></i>, поэтому массив <i><b>Apple</b></i> также одновременно должен быть массивом <i><b>Fruit</b></i>.
С другой стороны, если фактическим типом массива является <i><b>Аррlе[]</b></i>, в массиве можно разместить только <i><b>Apple</b></i> или субтип <i><b>Apple</b></i>,
 причем это правило должно соблюдаться как во время компиляции, так и во
 время выполнения. Но обратите внимание на то, что компилятор также 
позволит разместить в массиве ссылку на объект <i><b>Fruit</b></i>. Для компилятора это вполне логично, потому что он имеет дело со ссылкой <i><b>Fruit[]</b></i> — так почему бы не разрешить занести в массив объект <i><b>Fruit</b></i> или любого типа, производного от <i><b>Fruit</b></i>, — скажем, <i><b>Orange</b></i>? Во время компиляции это разрешено. Однако механизм времени выполнения знает, что он имеет дело с <i><b>Apple[]</b></i>,
 и при попытке занесения постороннего типа происходит исключение.
Впрочем, для массивов это не создает особых проблем, потому что при 
вставке объекта неверного типа вы об этом очень быстро узнаете во время 
выполнения. Но одна из основных целей параметризации как раз и состоит в
 том, чтобы по возможности переместить выявление подобных ошибок на 
стадию выполнения. Итак, что же произойдет при использовании 
параметризованных контейнеров вместо массивов?
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/NonCovariantGenerics.java</span>
<span class="co1">// {CompileTimeError} (Won't compile)</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> NonCovariantGenerics <span class="br0">{</span>
  <span class="co1">// Ошибка компиляции: несовместимые типы</span>
  <span class="kw166">List</span><span class="sy0">&lt;</span>Fruit<span class="sy0">&gt;</span> flist = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>На первый взгляд это выглядит как утверждение «Контейнер с элементами <i><b>Apple</b></i> нельзя присвоить контейнеру с элементами <i><b>Fruit</b></i>»,
 но следует вспомнить, что параметризация — это не только контейнеры. В 
действительности утверждение следует трактовать шире: «Параметризованный
 тип, в котором задействован тип <i><b>Apple</b></i>, нельзя присвоить параметризованному типу, в котором задействован тип <i><b>Fruit</b></i>».
 Если бы, как в случае с массивами, компилятор располагал достаточной 
информацией и мог понять, что речь идет о контейнерах, он мог бы 
проявить некоторую снисходительность. Но компилятор такой информацией не
 располагает, поэтому он отказывается выполнить «восходящее 
преобразование». Впрочем, это и не является восходящим преобразованием —
 <i><b>List</b></i> с элементами <i><b>Apple</b></i> не является «частным случаем» <i><b>List</b></i> с элементами <i><b>Fruit</b></i>. Первый может хранить <i><b>Apple</b></i> и подтипы <i><b>Apple</b></i>, а второй — любые разновидности <i><b>Fruit</b></i>... да, в том числе и <i><b>Apple</b></i>, но от этого он не становится <i><b>List</b></i> с элементами <i><b>Apple</b></i>, а по-прежнему остается <i><b>List</b></i> с элементами <i><b>Fruit</b></i>.
Проблема в том, что речь идет о типе контейнера, а не о типе элементов, 
которые в этом контейнере хранятся. В отличие от массивов, 
параметризованные типы не обладают встроенной ковариантностью. Это 
связано с тем, что массивы полностью определяются в языке и для них 
могут быть реализованы встроенные проверки как во время компиляции, так и
 во время выполнения, но с параметризованными типами компилятор и 
система времени выполнения не знают, что вы собираетесь делать с типами и
 какие правила при этом должны действовать.
Но иногда между двумя разновидностями параметризованных типов все же 
требуется установить некоторую связь, аналогичную восходящему 
преобразованию. Именно это и позволяют сделать метасимволы.
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericsAndCovariance.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
<span class="kw2">public</span> <span class="kw2">class</span> GenericsAndCovariance <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// Метасимволы обеспечивают ковариантность:</span>
    <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Fruit<span class="sy0">&gt;</span> flist = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Ошибка компиляции: добавление объекта</span>
    <span class="co1">// произвольного типа невозможно</span>
    <span class="co1">// flist.add(new Apple());</span>
    <span class="co1">// flist.add(new Fruit());</span>
    <span class="co1">// flist.add(new Object());</span>
    flist.<span class="me1">add</span><span class="br0">(</span><span class="kw4">null</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Можно, но неинтересно</span>
    <span class="co1">// Мы знаем, что возвращается по крайней мере Fruit:</span>
    Fruit f = flist.<span class="me1">get</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Теперь <i><b>flist</b></i> относится к типу <i><b>List&lt;? extends Fruit&gt;</b></i>, что можно прочитать как «список с элементами любого типа, производного от <i><b>Fruit</b></i>». Однако в действительности это не означает, что <i><b>List</b></i> будет содержать именно типы из семейства <i><b>Fruit</b></i>. Метасимвол обозначает «некоторый конкретный тип, не указанный в ссылке <i><b>flist</b></i>». Таким образом, присваиваемый <i><b>List</b></i> должен содержать некий конкретный тип (например, <i><b>Fruit</b></i> или <i><b>Apple</b></i>), но для восходящего преобразования к <i><b>flist</b></i> этот тип несущественен.
Если единственное ограничение состоит в том, что <i><b>List</b></i> содержит <i><b>Fruit</b></i>
 или один из его подтипов, но вас не интересует, какой именно, что же с 
ним можно сделать? Если вы не знаете, какие типы хранятся в <i><b>List</b></i>, возможно ли безопасное добавление объекта? Нет, как и в случае с <i><b> CovariantArrays.java</b></i>, но на этот раз ошибка выявляется компилятором, а не системой времени выполнения.
Может показаться, что такой подход не совсем логичен — вам не удастся даже добавить <i><b>Apple</b></i> в <i><b>List</b></i>, в котором, как вы только что указали, должны храниться <i><b>Apple</b></i>. Да, конечно, но компилятор-то этого не знает! <i><b>List&lt;? extends Fruit&gt;</b></i> вполне может указывать на <i><b>List&lt;Orange&gt;</b></i>.
С другой стороны, вызов метода, возвращающего <i><b>Fruit</b></i>, безопасен; мы знаем, что все элементы <i><b>List</b></i> должны по меньшей мере относиться к <i><b>Fruit</b></i>, поэтому компилятор это позволит.
</p>
<h2><span class="mw-headline" id=".D0.9D.D0.B0.D1.81.D0.BA.D0.BE.D0.BB.D1.8C.D0.BA.D0.BE_.D1.83.D0.BC.D0.B5.D0.BD_.D0.BA.D0.BE.D0.BC.D0.BF.D0.B8.D0.BB.D1.8F.D1.82.D0.BE.D1.80.3F"><b>Насколько умен компилятор?</b></span></h2>
<p>Казалось бы, из всего сказанного следует, что вызов любых методов с аргументами невозможен, но рассмотрим следующий пример:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/CompilerIntelligence.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> CompilerIntelligence <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> Fruit<span class="sy0">&gt;</span> flist =
      <span class="kw46">Arrays</span>.<span class="me1">asList</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    Apple a = <span class="br0">(</span>Apple<span class="br0">)</span>flist.<span class="me1">get</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// No warning</span>
    flist.<span class="me1">contains</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Argument is 'Object'</span>
    flist.<span class="me1">indexOf</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Argument is 'Object'</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Как видите, вызовы <i><b>contains()</b></i> и <i><b>indexOf()</b></i> с аргументами<i><b> Apple</b></i>
 воспринимаются нормально. Означает ли это, что компилятор действительно
 анализирует код, чтобы узнать, модифицирует ли некоторый метод свой 
объект?
Просмотр документации <i><b>ArrayList</b></i> показывает, что компилятор не настолько умен. Если <i><b>add()</b></i> получает аргумент параметризующего типа, <i><b>contains()</b></i> и <i><b>indexOf(</b></i>) получают аргумент типа <i><b> Object</b></i>. Таким образом, когда вы указываете <i><b>ArrayList&lt;? extends Fruit&gt;</b></i>, аргумент <i><b>add()</b></i> превращается в <i><b>&lt;? extends Fruit&gt;</b></i>. По этому описанию компилятор не может определить, какой именно подтип <i><b>Fruit</b></i> требуется в данном случае, поэтому не принимает никакие типы <i><b>Fruit</b></i>. Даже если вы предварительно преобразуете <i><b>Apple</b></i> в <i><b>Fruit</b></i>, компилятор все равно откажется вызывать метод (например, <i><b>add()</b></i>), если в списке аргументов присутствует метасимвол.
У методов <i><b>contains()</b></i> и <i><b>indexOf()</b></i> аргументы относятся к типу <i><b>Object</b></i>,
 метасимволы в них отсутствуют, поэтому компилятор разрешает вызов. Это 
означает, что проектировщик параметризованного класса должен сам решить,
 какие вызовы «безопасны», и использовать типы <i><b>Object</b></i> для 
их аргументов. Чтобы сделать невозможным вызов при использовании типа с 
метасимволами, включите параметр типа в список аргументов.
В качестве примера рассмотрим очень простой класс <i><b>Holder</b></i>:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericHolder.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> GenericHolder<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T obj<span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span>T obj<span class="br0">)</span> <span class="br0">{</span> <span class="kw2">this</span>.<span class="me1">obj</span> = obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> obj<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    GenericHolder<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> holder =
      <span class="kw2">new</span> GenericHolder<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    holder.<span class="me1">set</span><span class="br0">(</span><span class="st0">"Item"</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">String</span> s = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span>
<span class="co1">//---------------------------------------</span>
<span class="co1">//: generics/Holder.java</span>
<span class="kw2">public</span> <span class="kw2">class</span> Holder<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> T value<span class="sy0">;</span>
  <span class="kw2">public</span> Holder<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw2">public</span> Holder<span class="br0">(</span>T val<span class="br0">)</span> <span class="br0">{</span> value = val<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> set<span class="br0">(</span>T val<span class="br0">)</span> <span class="br0">{</span> value = val<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> T get<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> value<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">boolean</span> equals<span class="br0">(</span><span class="kw166">Object</span> obj<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw2">return</span> value.<span class="me1">equals</span><span class="br0">(</span>obj<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Holder<span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span> Apple = <span class="kw2">new</span> Holder<span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    Apple d = Apple.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Apple.<span class="me1">set</span><span class="br0">(</span>d<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Holder&lt;Fruit&gt; Fruit = Apple; // Повышение невозможно</span>
    Holder<span class="sy0">&lt;?</span> <span class="kw2">extends</span> Fruit<span class="sy0">&gt;</span> fruit = Apple<span class="sy0">;</span> <span class="co1">// OK</span>
    Fruit p = fruit.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    d = <span class="br0">(</span>Apple<span class="br0">)</span>fruit.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Возвращает 'Object'</span>
    <span class="kw2">try</span> <span class="br0">{</span>
      Orange c = <span class="br0">(</span>Orange<span class="br0">)</span>fruit.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Предупреждения нет</span>
    <span class="br0">}</span> <span class="kw2">catch</span><span class="br0">(</span><span class="kw21">Exception</span> e<span class="br0">)</span> <span class="br0">{</span> <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>e<span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
    <span class="co1">// fruit.set(new Apple()); // Вызов set() невозможен </span>
    <span class="co1">// fruit.set(new Fruit()); // Вызов set() невозможен </span>
    <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">println</span><span class="br0">(</span>fruit.<span class="me1">equals</span><span class="br0">(</span>d<span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span> <span class="co1">// OK</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt; (Sample)
</p>
<pre>java.lang.ClassCastException. Apple cannot be cast to Orange
true
</pre>
<p>&lt;/spoiler&gt;
<i><b>Holder</b></i> содержит метод <i><b>set()</b></i>, получающий <i><b>T</b></i>; метод <i><b>get()</b></i>, возвращающий <i><b> Т</b></i>; и метод <i><b>equals()</b></i>, получающий <i><b>Object</b></i>. Как вы уже видели, <i><b>Holder&lt;Apple&gt;</b></i> невозможно преобразовать в <i><b>Holder&lt;Fruit&gt;</b></i>, но зато можно в <i><b>Holder&lt;? extends Fruit&gt;</b></i>. При вызове <i><b>get()</b></i> будет возвращен только тип <i><b>Fruit</b></i> — то, что известно компилятору по ограничению «все, что расширяет <i><b>Fruit</b></i>». Если вы располагаете дополнительной информацией, то сможете выполнить преобразование к конкретному типу <i><b>Fruit</b></i> и обойтись без предупреждений, но с риском исключения <i><b>ClassCastException</b></i>. Метод <i><b>set(</b></i>) не работает ни с <i><b> Apple</b></i>, ни с <i><b>Fruit</b></i>, потому что аргумент <i><b>set()</b></i> тоже содержит <i><b>«? extends Fruit»</b></i>; по сути, он может быть чем угодно, а компилятор не может проверить безопасность типов для «чего угодно».
Впрочем, метод <i><b>equals()</b></i> работает нормально, потому что он получает <i><b>Object</b></i> вместо <i><b>Т</b></i>.
 Таким образом, компилятор обращает внимание только на типы передаваемых
 и возвращаемых объектов. Он не анализирует код, проверяя, выпол­няются 
ли реальные операции чтения или записи.
</p>
<h2><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.82.D1.80.D0.B0.D0.B2.D0.B0.D1.80.D0.B8.D0.B0.D0.BD.D1.82.D0.BD.D0.BE.D1.81.D1.82.D1.8C"><b>Контравариантность</b></span></h2>
<p>Также можно пойти другим путем и использовать метасимволы супертипов.
 В этом случае вы сообщаете, что метасимвол ограничивается базовым 
классом некоторого класса; при этом используется запись <i><b>&lt;? super MyClass&gt;</b></i>, и даже с па­раметром типа <i><b>&lt;? super Т&gt;</b></i>.
 Это позволяет безопасно передавать типизованный объект 
параметризованному типу. Таким образом, с использованием метасимволов 
супертипов становится возможной запись в коллекцию:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/SuperTypeWildcards.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> SuperTypeWildcards <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw3">void</span> writeTo<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">super</span> Apple<span class="sy0">&gt;</span> apples<span class="br0">)</span> <span class="br0">{</span>
    apples.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    apples.<span class="me1">add</span><span class="br0">(</span><span class="kw2">new</span> Jonathan<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// apples.add(new Fruit()); // Error</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Аргумент apples является контейнером <i><b>List</b></i> для некоторого типа, являющегося базовым для <i><b>Apple</b></i>; из этого следует, что <i><b>Apple</b></i> и производные от <i><b>Apple</b></i> типы могут безопасно включаться в контейнер. Но, поскольку нижним ограничением является <i><b>Apple</b></i>, мы не знаем, безопасно ли включать <i><b>Fruit</b></i> в такой <i><b>List</b></i>, так как это откроет <i><b>List</b></i> для добавления типов, отличных от<i><b> Apple</b></i>, с нарушением статической безопасности типов.
Ограничения супертипов расширяют возможности по передаче аргументов методу:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericWriting.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GenericWriting <span class="br0">{</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw3">void</span> writeExact<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> list, T item<span class="br0">)</span> <span class="br0">{</span>
    list.<span class="me1">add</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span> apples = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Apple<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;</span>Fruit<span class="sy0">&gt;</span> fruit = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span>Fruit<span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">void</span> f1<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    writeExact<span class="br0">(</span>apples, <span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// writeExact(fruit, new Apple()); // Ошибка:</span>
    <span class="co1">// Несовместимые типы: обнаружен Fruit, требуется Apple</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="kw3">void</span>
  writeWithWildcard<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">super</span> T<span class="sy0">&gt;</span> list, T item<span class="br0">)</span> <span class="br0">{</span>
    list.<span class="me1">add</span><span class="br0">(</span>item<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">static</span> <span class="kw3">void</span> f2<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
    writeWithWildcard<span class="br0">(</span>apples, <span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    writeWithWildcard<span class="br0">(</span>fruit, <span class="kw2">new</span> Apple<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span> f1<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> f2<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Метод <i><b>writeExact()</b></i> использует параметр типа «как есть», без метасимволов. На примере <i><b>f1()</b></i>  мы видим, что этот способ отлично работает — при условии, что в <i><b>List&lt;Apple&gt;</b></i> помещаются только объекты <i><b>Apple</b></i>. Однако <i><b>writeExact()</b></i> не позволяет поместить<i><b> Apple</b></i> в <i><b>List&lt;Fruit&gt;</b></i>, хотя мы знаем, что это должно быть возможно.
В <i><b>writeWithWildcard()</b></i> используется аргумент <i><b>List&lt;? super Т&gt;</b></i>, поэтому <i><b>List</b></i> содержит конкретный тип, производный от <i><b>Т</b></i>; следовательно, <i><b>Т</b></i> или производные от него типы могут безопасно передаваться в аргументе методов <i><b>List</b></i>. Пример встречается в <i><b>f2</b></i>: как и прежде, <i><b>Apple</b></i> можно поместить в <i><b>List&lt;Apple&gt;</b></i>, но, как и предполагалось, также стало можно поместить<i><b> Apple</b></i> в <i><b>List&lt;Fruit&gt;</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9D.D0.B5.D0.BE.D0.B3.D1.80.D0.B0.D0.BD.D0.B8.D1.87.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.BC.D0.B5.D1.82.D0.B0.D1.81.D0.B8.D0.BC.D0.B2.D0.BE.D0.BB.D1.8B"><b>Неограниченные метасимволы</b></span></h2>
<p>Казалось бы, неограниченный метасимвол <i><b>&lt;?&gt;</b></i> должен
 означать «все, что угодно», а его использование эквивалентно 
использованию низкоуровневого типа. В самом деле, на первый взгляд 
компилятор подтверждает эту оценку:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/UnboundedWildcards1.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UnboundedWildcards1 <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw166">List</span> list1<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;?&gt;</span> list2<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw166">Object</span><span class="sy0">&gt;</span> list3<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">void</span> assign1<span class="br0">(</span><span class="kw166">List</span> list<span class="br0">)</span> <span class="br0">{</span>
    list1 = list<span class="sy0">;</span>
    list2 = list<span class="sy0">;</span>
    <span class="co1">// list3 = list;// Предупреждение: непроверенное преобразование</span>
    <span class="co1">// Обнаружен List, требуется List&lt;? extends Object&gt;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> assign2<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;?&gt;</span> list<span class="br0">)</span> <span class="br0">{</span>
    list1 = list<span class="sy0">;</span>
    list2 = list<span class="sy0">;</span>
    list3 = list<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">static</span> <span class="kw3">void</span> assign3<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw166">Object</span><span class="sy0">&gt;</span> list<span class="br0">)</span> <span class="br0">{</span>
    list1 = list<span class="sy0">;</span>
    list2 = list<span class="sy0">;</span>
    list3 = list<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    assign1<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign2<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// assign3(new ArrayList());// Предупреждение- </span>
    <span class="co1">// Непроверенное преобразование. Обнаружен- ArrayList </span>
    <span class="co1">// Требуется: List&lt;? extends Object&gt; </span>
    assign1<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign2<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign3<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Приемлемы обе формы- List&lt;?&gt;</span>
    <span class="kw166">List</span><span class="sy0">&lt;?&gt;</span> wildList = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    wildList = <span class="kw2">new</span> <span class="kw46">ArrayList</span><span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    assign1<span class="br0">(</span>wildList<span class="br0">)</span><span class="sy0">;</span>
    assign2<span class="br0">(</span>wildList<span class="br0">)</span><span class="sy0">;</span>
    assign3<span class="br0">(</span>wildList<span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Во многих ситуациях, подобных рассмотренной, для компилятора совершенно не существенно, используется низкоуровневый тип или <i><b>&lt;?&gt;</b></i>. Конструкцию <i><b>&lt;?&gt;</b></i>
 можно считать обычным украшением; впрочем, она обладает некоторой 
практи­ческой ценностью, потому что фактически означает: «Код написан с 
учетом параметризации <i>Java</i>, и здесь эта конструкция означает не 
то, что я использую низкоуровневый тип, а то, что параметр 
параметризации может содержать про­извольный тип».
Второй пример демонстрирует важное практическое использование 
неограниченных метасимволов. Когда вы имеете дело с несколькими 
параметрами, иногда важно указать, что один параметр может относиться к 
произвольному типу, а другой ограничить определенным типом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/UnboundedWildcards2.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UnboundedWildcards2 <span class="br0">{</span>
  <span class="kw2">static</span> <span class="kw46">Map</span> map1<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw46">Map</span><span class="sy0">&lt;?</span>,<span class="sy0">?&gt;</span> map2<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="sy0">?&gt;</span> map3<span class="sy0">;</span>
  <span class="kw2">static</span> <span class="kw3">void</span> assign1<span class="br0">(</span><span class="kw46">Map</span> map<span class="br0">)</span> <span class="br0">{</span> map1 = map<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> assign2<span class="br0">(</span><span class="kw46">Map</span><span class="sy0">&lt;?</span>,<span class="sy0">?&gt;</span> map<span class="br0">)</span> <span class="br0">{</span> map2 = map<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">static</span> <span class="kw3">void</span> assign3<span class="br0">(</span><span class="kw46">Map</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="sy0">?&gt;</span> map<span class="br0">)</span> <span class="br0">{</span> map3 = map<span class="sy0">;</span> <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    assign1<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">HashMap</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign2<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">HashMap</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// assign3(new HashMap()); // Предупреждение: </span>
    <span class="co1">// Непроверенное преобразование. Обнаружен: HashMap </span>
    <span class="co1">// Требуется: Map&lt;String,?&gt;</span>
    assign1<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign2<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
    assign3<span class="br0">(</span><span class="kw2">new</span> <span class="kw46">HashMap</span><span class="sy0">&lt;</span><span class="kw21">String</span>,<span class="kw21">Integer</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Когда в записи используются только неограниченные метасимволы, как в примере <i><b>Мар&lt;?,?&gt;</b></i>, компилятор не отличает такой тип от <i><b>Map</b></i>. Кроме того, пример <i><b>UnboundedWildcardsl.java</b></i> показывает, что компилятор по-разному интерпретирует <i><b>List&lt;?&gt;</b></i> и <i><b>List&lt;? extends Object&gt;</b></i>.
Ситуация осложняется тем, что компилятор не всегда интересуется различиями между <i><b>List</b></i> и <i><b>List&lt;?&gt;</b></i>
 (например), поэтому может показаться, что это одно и то же. В самом 
деле, поскольку параметризованный аргумент стирается до первого 
ограничения, <i><b>List&lt;?&gt;</b></i> кажется эквивалентным <i><b>List&lt;Object&gt;</b></i>, a <i><b>List</b></i>, по сути, тоже является <i><b>List&lt;Object&gt;</b></i> — однако ни одно из этих утверждений не является в полной мере истинным. <i><b>List</b></i> в действительности означает «низкоуровневый <i><b>List</b></i>, содержащий любой тип <i><b>Object</b></i>», тогда как <i><b>List&lt;?&gt;</b></i> означает «не-низкоуровневый <i><b>List</b></i>,
 содержащий какой-то конкретный тип, хотя мы не знаем, какой именно».
Когда же компилятор различает низкоуровневые типы и типы с 
неограниченными метасимволами? В следующем примере используется класс <i><b>Holder&lt;T&gt;</b></i>, определение которого приводилось ранее. Класс содержит методы, получающие аргумент <i><b>Holder</b></i>, но в разных формах: в виде низкоуровневого типа, с конкретным параметром типа, с неограниченным метасимволом:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/Wildcards.java</span>
<span class="co1">// Exploring the meaning of wildcards.</span>
<span class="co1">// Исследование значения метасимволов</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> Wildcards <span class="br0">{</span>
   <span class="co1">// Низкоуровневый аргумент:</span>
  <span class="kw2">static</span> <span class="kw3">void</span> rawArgs<span class="br0">(</span>Holder holder, <span class="kw166">Object</span> arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// holder.set(arg); // Предупреждение</span>
    <span class="co1">// Непроверенный вызов set(T) как члена </span>
    <span class="co1">// низкоуровневого типа Holder</span>
    <span class="co1">// holder.set(new Wildcards());// To же предупреждение</span>
    <span class="co1">// Невозможно: нет информации о 'Т'</span>
    <span class="co1">// T t = holder.get();</span>
&nbsp;
    <span class="co1">// Допустимо, но информация типа теряется </span>
    <span class="kw166">Object</span> obj = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="co1">// По аналогии с rawArgs(), но ошибки вместо предупреждений:</span>
  <span class="kw2">static</span> <span class="kw3">void</span> unboundedArg<span class="br0">(</span>Holder<span class="sy0">&lt;?&gt;</span> holder, <span class="kw166">Object</span> arg<span class="br0">)</span> <span class="br0">{</span>
    <span class="co1">// holder.set(arg); // Ошибка:</span>
       <span class="co1">// set(capture of&nbsp;?) в Holder&lt;capture of&nbsp;?&gt;</span>
       <span class="co1">// не может применяться к (Object)</span>
    <span class="co1">// holder.set(new Wildcards()); // Та же ошибка</span>
&nbsp;
      <span class="co1">// Невозможно; нет информации о 'T':</span>
      <span class="co1">// T t = holder.get();</span>
&nbsp;
      <span class="co1">// Допустимо, но информация типа теряется:</span>
    <span class="kw166">Object</span> obj = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> T exact1<span class="br0">(</span>Holder<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder<span class="br0">)</span> <span class="br0">{</span>
    T t = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> t<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> T exact2<span class="br0">(</span>Holder<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> holder, T arg<span class="br0">)</span> <span class="br0">{</span>
    holder.<span class="me1">set</span><span class="br0">(</span>arg<span class="br0">)</span><span class="sy0">;</span>
    T t = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> t<span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
  T wildSubtype<span class="br0">(</span>Holder<span class="sy0">&lt;?</span> <span class="kw2">extends</span> T<span class="sy0">&gt;</span> holder, T arg<span class="br0">)</span> <span class="br0">{</span>
      <span class="co1">// holder.set(arg); // Ошибка:</span>
      <span class="co1">// set(capture of&nbsp;? extends T) in</span>
      <span class="co1">// Holder&lt;capture of&nbsp;? extends T&gt;</span>
      <span class="co1">// cannot be applied to (T)</span>
    T t = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw2">return</span> t<span class="sy0">;</span>
  <span class="br0">}</span>	
  <span class="kw2">static</span> <span class="sy0">&lt;</span>T<span class="sy0">&gt;</span>
  <span class="kw3">void</span> wildSupertype<span class="br0">(</span>Holder<span class="sy0">&lt;?</span> <span class="kw2">super</span> T<span class="sy0">&gt;</span> holder, T arg<span class="br0">)</span> <span class="br0">{</span>
    holder.<span class="me1">set</span><span class="br0">(</span>arg<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// T t = holder.get();  // Ошибка:</span>
       <span class="co1">// Несовместимые типы: обнаружен Object, требуется T</span>
&nbsp;
    <span class="co1">// Допустимо, но информация типа теряется:</span>
    <span class="kw166">Object</span> obj = holder.<span class="me1">get</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    Holder raw = <span class="kw2">new</span> Holder<span class="sy0">&lt;</span><span class="kw21">Long</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Или:</span>
    raw = <span class="kw2">new</span> Holder<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Holder<span class="sy0">&lt;</span><span class="kw21">Long</span><span class="sy0">&gt;</span> qualified = <span class="kw2">new</span> Holder<span class="sy0">&lt;</span><span class="kw21">Long</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Holder<span class="sy0">&lt;?&gt;</span> unbounded = <span class="kw2">new</span> Holder<span class="sy0">&lt;</span><span class="kw21">Long</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    Holder<span class="sy0">&lt;?</span> <span class="kw2">extends</span> <span class="kw21">Long</span><span class="sy0">&gt;</span> bounded = <span class="kw2">new</span> Holder<span class="sy0">&lt;</span><span class="kw21">Long</span><span class="sy0">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">Long</span> lng = 1L<span class="sy0">;</span>
&nbsp;
    rawArgs<span class="br0">(</span>raw, lng<span class="br0">)</span><span class="sy0">;</span>
    rawArgs<span class="br0">(</span>qualified, lng<span class="br0">)</span><span class="sy0">;</span>
    rawArgs<span class="br0">(</span>unbounded, lng<span class="br0">)</span><span class="sy0">;</span>
    rawArgs<span class="br0">(</span>bounded, lng<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    unboundedArg<span class="br0">(</span>raw, lng<span class="br0">)</span><span class="sy0">;</span>
    unboundedArg<span class="br0">(</span>qualified, lng<span class="br0">)</span><span class="sy0">;</span>
    unboundedArg<span class="br0">(</span>unbounded, lng<span class="br0">)</span><span class="sy0">;</span>
    unboundedArg<span class="br0">(</span>bounded, lng<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Object r1 = exact1(raw);// Предупреждение </span>
    <span class="co1">// Непроверенное преобразование Holder в Holder&lt;T&gt; </span>
    <span class="co1">// Непроверенный вызов метода: exactl(Holder&lt;T&gt;) </span>
    <span class="co1">// применяется к (Holder)</span>
    <span class="kw21">Long</span> r2 = exact1<span class="br0">(</span>qualified<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw166">Object</span> r3 = exact1<span class="br0">(</span>unbounded<span class="br0">)</span><span class="sy0">;</span> <span class="co1">// Должен возвращать Object </span>
    <span class="kw21">Long</span> r4 = exact1<span class="br0">(</span>bounded<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
    <span class="co1">// Long r5 = exact2(raw, lng); // Предупреждения-</span>
       <span class="co1">// Непроверенное преобразование Holder в Holder&lt;Long&gt;</span>
       <span class="co1">// Непроверенный вызов метода. exact2(Holder&lt;T&gt;,T)</span>
       <span class="co1">// применяется к (Holder,Long)</span>
    <span class="kw21">Long</span> r6 = exact2<span class="br0">(</span>qualified, lng<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// Long r7 = exact2(unbounded, lng);// Ошибка:</span>
       <span class="co1">// exact2(Holder&lt;T&gt;.T) не может применяться к</span>
       <span class="co1">// (Holder&lt;capture of&nbsp;?&gt;.Long)</span>
    <span class="co1">// Long r8 = exact2(bounded, lng); // Ошибка:</span>
       <span class="co1">// exact2(Holder&lt;T&gt;.T) не может применяться</span>
       <span class="co1">// к (Holder&lt;capture of&nbsp;? extends Long&gt;,Long)</span>
    <span class="co1">// Long r9 = wildSubtype(raw, lng); // Предупреждения</span>
       <span class="co1">// Непроверенное преобразование Holder</span>
       <span class="co1">// к Holder&lt;? extends Long&gt;</span>
       <span class="co1">// Непроверенный вызов метода-</span>
       <span class="co1">// wildSubtype(Holder&lt;? extends T&gt;,T)</span>
       <span class="co1">// применяется к (Holder.Long) </span>
    <span class="kw21">Long</span> r10 = wildSubtype<span class="br0">(</span>qualified, lng<span class="br0">)</span><span class="sy0">;</span>
       <span class="co1">// Допустимо, но возвращать может только Object-</span>
    <span class="kw166">Object</span> r11 = wildSubtype<span class="br0">(</span>unbounded, lng<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw21">Long</span> r12 = wildSubtype<span class="br0">(</span>bounded, lng<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// wildSupertype(raw, lng);// Предупреждения. </span>
       <span class="co1">// Непроверенное преобразование Holder</span>
       <span class="co1">// к Holder&lt;? super Long&gt;  </span>
       <span class="co1">// Непроверенный вызов метода:</span>
       <span class="co1">// wildSupertype(Holder&lt;? super T&gt;,T)</span>
       <span class="co1">// применяется к (Holder.Long) </span>
    wildSupertype<span class="br0">(</span>qualified, lng<span class="br0">)</span><span class="sy0">;</span>
    <span class="co1">// wildSupertype(unbounded, lng); // Ошибка:</span>
       <span class="co1">// wi1dSupertype(Hoider&lt;? super T&gt;,T) не может                </span>
       <span class="co1">// применяться к (Holder&lt;capture of&nbsp;?&gt;,Long)</span>
    <span class="co1">// wildSupertype(bounded, lng); // Ошибка: </span>
       <span class="co1">// wildSupertype(Holder&lt;? super T&gt;,T) не может </span>
       <span class="co1">// применяться к (Holder&lt;capture of&nbsp;? extends Long&gt;.Long)</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>В методе <i><b>rawArgs()</b></i> компилятор знает, что <i><b>Holder</b></i>
 является параметризованным типом, поэтому несмотря на то, что здесь он 
выражен как низкоуровневый тип, компилятору известно, что передача <i><b>Object</b></i> методу <i><b>set(</b></i>) небезопасна. Так как в данном случае используется низкоуровневый тип, методу <i><b>set()</b></i> можно передать объект произвольного типа, и он будет преобразован в <i><b>Object</b></i>. Таким образом, при использовании низкоуровневого типа вы лишаетесь проверки на стадии компиляции. Вызов <i><b>get()</b></i> демонстрирует ту же проблему: никакого <i><b>Т</b></i> нет, поэтому результатом может быть только <i><b>Object</b></i>.
Может создаться впечатление, что низкоуровневый <i><b>Holder</b></i> и <i><b>Holder&lt;?&gt;</b></i> — приблизительно одно и то же. Однако метод <i><b>unboundedArgs()</b></i>
 демонстрирует различия между ними — в нем выявляются те же проблемы, но
 информация о них выдается в виде ошибок, а не предупреждений, поскольку
 низкоуровневый Holder может содержать разнородные комбинации типов, 
тогда как <i><b>Holder&lt;?&gt;</b></i> содержит однородную коллекцию одного конкретного типа.
В <i><b>exact1()</b></i> и <i><b>exact2()</b></i> используются точные параметры типов (то есть без метасимволов). Мы видим, что exact2() обладает иными ограничениями, нежели <i><b>exact1()</b></i>, из-за дополнительного аргумента.
В <i><b>wildSubtype()</b></i> ограничения на тип <i><b>Holder</b></i> опускаются до <i><b>Holder</b></i> с элементами любого типа, удовлетворяющими условию extends <i><b>Т</b></i>. И снова это означает, что <i><b>Т</b></i> может быть типом <i><b>Fruit</b></i>, a <i><b>holder</b></i> сможет вполне законно стать <i><b>Holder &lt;Apple&gt;</b></i>. Чтобы предотвратить возможное размещение <i><b>Orange</b></i> в <i><b>Holder&lt;Apple&gt;</b></i>, вызовы <i><b>set()</b></i> (и любых других методов, получающих в аргументах параметр типа) запрещены. Однако мы знаем, что все объекты, полученные из <i><b>Holder&lt;? extends Fruit&gt;</b></i>, по меньшей мере, являются <i><b>Fruit</b></i>, поэтому вызов <i><b> get()</b></i> (или любого метода с возвращаемым значением параметра типа) допустим.
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.B8.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.BD.D1.8B.D1.85_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.BE.D0.B2"><b>Реализация параметризованных интерфейсов</b></span></h2>
<p>Класс не может реализовать две разновидности одного 
параметризованного интерфейса — вследствие стирания они будут считаться 
одним и тем же интерфейсом. Пример конфликта такого рода:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/MultipleInterfaceVariants.java</span>
<span class="co1">// {CompileTimeError} (He компилируется)</span>
&nbsp;
<span class="kw2">interface</span> Payable<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
<span class="kw2">class</span> Employee <span class="kw2">implements</span> Payable<span class="sy0">&lt;</span>Employee<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span>
<span class="kw2">class</span> Hourly <span class="kw2">extends</span> Employee
  <span class="kw2">implements</span> Payable<span class="sy0">&lt;</span>Hourly<span class="sy0">&gt;</span> <span class="br0">{</span><span class="br0">}</span></pre></div></div>
<p>Класс <i><b>Hourly</b></i> компилироваться не будет, потому что стирание сокращает <i><b>Payable&lt;Employee&gt;</b></i> и <i><b>Payable&lt;Hourly&gt;</b></i> до <i><b>Payable</b></i>,
 а в приведенном примере это означало бы двукратную реализацию одного 
интерфейса. Интересная подробность: если удалить параметризованные 
аргументы из обоих упоминаний <i><b>Payable</b></i>, как это делает компилятор при стирании, программа откомпилируется.
</p>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B5.D0.BE.D0.B1.D1.80.D0.B0.D0.B7.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_.D1.82.D0.B8.D0.BF.D0.BE.D0.B2_.D0.B8_.D0.BF.D1.80.D0.B5.D0.B4.D1.83.D0.BF.D1.80.D0.B5.D0.B6.D0.B4.D0.B5.D0.BD.D0.B8.D1.8F"><b>Преобразования типов и предупреждения</b></span></h2>
<p>Преобразование типа или <i><b>instanceof</b></i> с параметром типа не приводит ни к какому эффекту. В следующем контейнере данные хранятся во внутреннем представлении в форме <i><b>Object</b></i> и преобразуются к <i><b>Т</b></i> при выборке:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/GenericCast.java</span>
&nbsp;
<span class="kw2">class</span> FixedSizeStack<span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw2">private</span> <span class="kw3">int</span> index = <span class="nu0">0</span><span class="sy0">;</span>
  <span class="kw2">private</span> <span class="kw166">Object</span><span class="br0">[</span><span class="br0">]</span> storage<span class="sy0">;</span>
  <span class="kw2">public</span> FixedSizeStack<span class="br0">(</span><span class="kw3">int</span> size<span class="br0">)</span> <span class="br0">{</span>
    storage = <span class="kw2">new</span> <span class="kw166">Object</span><span class="br0">[</span>size<span class="br0">]</span><span class="sy0">;</span>
  <span class="br0">}</span>
  <span class="kw2">public</span> <span class="kw3">void</span> push<span class="br0">(</span>T item<span class="br0">)</span> <span class="br0">{</span> storage<span class="br0">[</span>index++<span class="br0">]</span> = item<span class="sy0">;</span> <span class="br0">}</span>
  @<span class="kw21">SuppressWarnings</span><span class="br0">(</span><span class="st0">"unchecked"</span><span class="br0">)</span>
  <span class="kw2">public</span> T pop<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw2">return</span> <span class="br0">(</span>T<span class="br0">)</span>storage<span class="br0">[</span>--index<span class="br0">]</span><span class="sy0">;</span> <span class="br0">}</span>
<span class="br0">}</span>	
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> GenericCast <span class="br0">{</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw2">final</span> <span class="kw3">int</span> SIZE = <span class="nu0">10</span><span class="sy0">;</span>
  <span class="kw2">public</span> <span class="kw2">static</span> <span class="kw3">void</span> main<span class="br0">(</span><span class="kw21">String</span><span class="br0">[</span><span class="br0">]</span> args<span class="br0">)</span> <span class="br0">{</span>
    FixedSizeStack<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span> strings =
      <span class="kw2">new</span> FixedSizeStack<span class="sy0">&lt;</span><span class="kw21">String</span><span class="sy0">&gt;</span><span class="br0">(</span>SIZE<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw21">String</span> s&nbsp;: <span class="st0">"A B C D E F G H I J"</span>.<span class="me1">split</span><span class="br0">(</span><span class="st0">" "</span><span class="br0">)</span><span class="br0">)</span>
      strings.<span class="me1">push</span><span class="br0">(</span>s<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">for</span><span class="br0">(</span><span class="kw3">int</span> i = <span class="nu0">0</span><span class="sy0">;</span> i <span class="sy0">&lt;</span> SIZE<span class="sy0">;</span> i++<span class="br0">)</span> <span class="br0">{</span>
      <span class="kw21">String</span> s = strings.<span class="me1">pop</span><span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
      <span class="kw21">System</span>.<span class="me1">out</span>.<span class="me1">print</span><span class="br0">(</span>s + <span class="st0">" "</span><span class="br0">)</span><span class="sy0">;</span>
    <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>&lt;spoiler text="Output:"&gt;
</p>
<pre>J I H G F E D C B A
</pre>
<p>&lt;/spoiler&gt;
Без директивы <i><b>@SuppressWarnings</b></i> компилятор выдает для <i><b>рор()</b></i>
 предупреждение о «непроверенном преобразовании». Вследствие стирания он
 не знает, безопасно преобразование или нет, поэтому метод<i><b> рор()</b></i> никакого преобразования не выполняет. <i><b>Т</b></i> стирается до первого ограничения, которым по умолчанию является <i><b>Object</b></i>, так что <i><b>рор()</b></i> на самом деле преобразует <i><b>Object</b></i> в <i><b>Object</b></i>.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.B3.D1.80.D1.83.D0.B7.D0.BA.D0.B0"><b>Перегрузка</b></span></h2>
<p>Следующий пример не компилируется, хотя на первый взгляд выглядит вполне разумно:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/UseList.java</span>
<span class="co1">// {CompileTimeError} (He компилируется)</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UseList<span class="sy0">&lt;</span>W,T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> f<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span>W<span class="sy0">&gt;</span> v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Перегрузка метода создает идентичную сигнатуру типа вследствие 
стирания. В таких случаях следует определять методы с различающимися 
именами:
</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr"><div class="java5 source-java5"><pre class="de1"><span class="co1">//: generics/UseList2.java</span>
<span class="kw2">import</span> <span class="co2">java.util.*</span><span class="sy0">;</span>
&nbsp;
<span class="kw2">public</span> <span class="kw2">class</span> UseList2<span class="sy0">&lt;</span>W,T<span class="sy0">&gt;</span> <span class="br0">{</span>
  <span class="kw3">void</span> f1<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span>T<span class="sy0">&gt;</span> v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
  <span class="kw3">void</span> f2<span class="br0">(</span><span class="kw166">List</span><span class="sy0">&lt;</span>W<span class="sy0">&gt;</span> v<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>К счастью, проблемы такого рода обнаруживаются компилятором.
</p><p><br>
</p>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D1.8E.D0.BC.D0.B5"><b>Резюме</b></span></h2>
<p>Мне довелось работать с шаблонами <i>C++</i> с момента их появления. 
Скорее всего, приведенный далее аргумент я выдвигал в спорах чаще, чем 
большинство моих единомышленников. Лишь недавно я задумался над тем, 
насколько в действительности справедлив этот аргумент, — сколько раз 
проблема, которую я сейчас опишу, проникала в рабочий код?
</p><p>Аргумент такой: одним из самых логичных мест для использования механизма параметризации являются контейнерные классы: <i><b>List, Set, Map</b></i> и т. д. До выхода <i>Java</i> <i>SE5</i> объект, помещаемый в контейнер, преобразовывался в <i><b>Object</b></i>,
 и информация типа терялась. Если же вы хотели снова извлечь объект из 
контейнера, его приходилось преобразовывать к нужному типу. Я пояснял 
происходящее на примере <i><b>List</b></i> с элементами <i><b>Cat</b></i> (разновидность этого примера с <i><b>Apple</b></i> и <i><b>Orange</b></i> приведена в начале главы 11). Без параметризованной версии контейнера из <i>Java</i> <i>SE5</i> вы помещаете и извлекаете из контейнера <i><b>Object</b></i>, поэтому в <i><b>List</b></i> с элементами <i><b>Cat</b></i> легко поместить объект <i><b>Dog</b></i>.
</p><p>Однако версии <i>Java</i>, существовавшие до появления параметризации, не допускали злоупотреблений объектами, помещаемыми в контейнер. Если вы помещали <i><b>Dog</b></i> в контейнер <i><b>Cat</b></i>, а затем пытались интерпретировать все элементы контейнера как <i><b>Cat</b></i>, то при извлечении ссылки на <i><b>Dog</b></i> и ее преобразовании к <i><b>Cat</b></i> происходило преобразование <i><b>RuntimeException</b></i>. Проблема обнаруживалась, пусть и на стадии выполнения, а не во время компиляции.
</p><p>В предыдущих изданиях книги я писал:
«Это не просто мелкая неприятность, а потенциальный источник 
трудноуловимых ошибок. Если одна часть (или несколько частей) программы 
вставляет объекты в контейнер, а в другой части программы 
обнаруживается, что в контейнер был помещен недопустимый объект, вам 
придется искать, где именно была выполнена неверная операция вставки».
</p><p>Но позже я задумался над этим аргументом, и у меня появились 
сомнения. Во-первых, насколько часто это происходит? Не помню, чтобы 
такая ошибка встретилась в моей программе. Когда я спрашивал людей на 
конференциях, мне тоже не удалось найти никого, с кем бы это случилось. В
 другой книге использовался пример списка с именем <i><b>files</b></i>, содержащего объекты <i><b>String</b></i>, — в этом примере казалось абсолютно логичным добавить в список объект типа <i><b>File</b></i>, так что объекту, вероятно, стоило присвоить имя <i><b>fileNames</b></i>. Какую бы проверку типов ни обеспечивал язык <i>Java</i>,
 программист все равно может написать малопонятную программу — а плохо 
написанная программа, даже если она компилируется, все равно остается 
плохо написанной. Вероятно, нормальный разработчик присвоит контейнеру 
понятное имя вроде <i><b>cats</b></i>, которое послужит предупреждением для программиста, пытающегося занести в контейнер другой объект, отличный от <i><b>Cat</b></i>.
 Но, даже если это и произойдет, как долго такая ошибка останется 
скрытой? Здравый смысл подсказывает, что исключение произойдет вскоре 
после начала тестирования с реальными данными.
</p><p>Один автор даже предположил, что такая ошибка может «оставаться 
скрытой несколько лет». Но я что-то не помню потока сообщений от людей, у
 которых возникали проблемы с поиском ошибок «<i><b>Dog</b></i> в списке <i><b>Cat</b></i>»,
 или хотя бы с их частым появлением. Так неужели такая заметная и 
довольно сложная возможность, как параметризация, была включена в <i>Java</i> из-за проблем такого рода?
Я считаю, что побудительной причиной для включения параметризации в язык (не обязательно конкретной реализации ее в <i>Java</i>!)
 является выразительность, а не создание типизованных контейнеров. 
Типизованные контейнеры — всего лишь побочный эффект возможности 
создания универсального кода. Таким образом, хотя аргумент «<i><b>Dog</b></i> в списке <i><b>Cat</b></i>» часто используется для оправдания параметризации, этот аргумент спорен.
</p><p>Из-за того, что параметризация была «встроена» в <i>Java</i> (а 
не проектировалась как составная часть языка с самого начала), некоторые
 контейнеры получились не такими мощными, как хотелось бы. Для примера 
взгляните на <i><b>Map</b></i>, особенно на методы <i><b>containsKey(Object key</b></i>) и <i><b>get(Object key)</b></i>. Если бы эти классы проектировались в расчете на параметризацию, в этих методах вместо <i><b>Object</b></i>
 использовались бы параметризованные типы; тем самым обеспечивались бы 
необходимые проверки стадии компиляции. Скажем, в аналогичных 
контейнерах <i>C++</i> тип ключа всегда проверяется во время компиляции.
</p><p>Бесспорно, введение любого механизма параметризации в более 
позднюю версию языка, получившего широкое распространение, — крайне 
хлопотная затея. В <i>C++</i> шаблоны были включены в исходную ISO-версию языка, так что они фактически всегда являлись его составной частью. В <i>Java</i>
 параметризация была введена лишь спустя 10 лет после выхода первой 
версии. Этот факт породил немало проблем с миграцией кода, а также 
оказал значительное влияние на архитектуру. В результате программисты 
страдают из-за близорукости, проявленной проектировщиками языка при 
создании версии 1.0. Конечно, при создании исходной версии они знали о 
шаблонах <i>C++</i> и даже рассматривали возможность включения их в 
язык, но по тем или иным причинам решили этого не делать (скорее всего, 
просто торопились). В результате пострадал как язык, так и работающие на
 нем программисты. Только время покажет, как подход к параметризации в <i>Java</i> отразится на самом языке.

</p>
                <p><br>
                </p>
                <hr>
                <p><a href="http://wikijava.it-cache.net/index.php" title="Thinking in Java 4th edition">назад в Оглавление</a>
                </p><p><br>
                </p>
<!-- 
NewPP limit report
CPU time usage: 7.409 seconds
Real time usage: 7.493 seconds
Preprocessor visited node count: 844/1000000
Preprocessor generated node count: 1774/1000000
Post‐expand include size: 243/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wjava2-wj_:pcache:idhash:28-0!*!*!!ru!*!* and timestamp 20140813055456
 -->
</div>								<div class="printfooter">
				Источник — «<a href="http://wikijava.org.ua/index.php?title=Glava_14_Thinking_in_Java_4th_edition&amp;oldid=38">http://wikijava.org.ua/index.php?title=Глава_14_Thinking_in_Java_4th_edition&amp;oldid=38</a>»				</div>
                                <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B8" title="Служебная:Категории">Категории</a>: <ul><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8" title="Категория:Книги">Книги</a></li><li><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F:Java" title="Категория:Java">Java</a></li></ul></div></div>												<div class="visualClear"></div>
            </div>

        </div>
		<div id="mw-navigation">
			<h2>Навигация</h2>
			<div id="mw-head">
				<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
	<h3 id="p-personal-label">Персональные инструменты</h3>
	<ul>
<li id="pt-login"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%92%D1%85%D0%BE%D0%B4&amp;returnto=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0+14+Thinking+in+Java+4th+edition" title="Здесь можно зарегистрироваться в системе, но это необязательно. [o]" accesskey="o">Представиться системе</a></li>	</ul>
</div>
				<div id="left-navigation">
					<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
	<h3 id="p-namespaces-label">Пространства имён</h3>
	<ul>
					<!--<li  id="ca-nstab-main" class="selected"><span><a href="index.php@title=Glava_14_Thinking_in_Java_4th_edition.html"  title="Просмотр основной страницы [c]" accesskey="c">Статья</a></span></li>-->
					<!--<li  id="ca-talk" class="new"><span><a href="http://wikijava.org.ua/index.php?title=%D0%9E%D0%B1%D1%81%D1%83%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5:%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;action=edit&amp;redlink=1"  title="Обсуждение основной страницы [t]" accesskey="t">Обсуждение</a></span></li>-->
			</ul>
</div>
<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
	<h3 id="mw-vector-current-variant">
		</h3>
	<h3 id="p-variants-label"><span>Варианты</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
				</div>
				<div id="right-navigation">
					<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
	<h3 id="p-views-label">Просмотры</h3>
	<ul>
					<!--<li id="ca-view" class="selected"><span><a href="index.php@title=Glava_14_Thinking_in_Java_4th_edition.html" >Читать</a></span></li>-->
					<!--<li id="ca-viewsource"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;action=edit"  title="Эта страница защищена от изменений, но вы можете посмотреть и скопировать её исходный текст [e]" accesskey="e">Просмотр</a></span></li>-->
					<!--<li id="ca-history" class="collapsible"><span><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;action=history"  title="Журнал изменений страницы [h]" accesskey="h">История</a></span></li>-->
			</ul>
</div>
<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
	<h3 id="p-cactions-label"><span>Действия</span><a href="http://wikijava.it-cache.net/index.php@title=Glava_14_Thinking_in_Java_4th_edition.html#"></a></h3>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>
<div id="p-search" role="search">
	<h3><label for="searchInput">Поиск</label></h3>
	<form action="http://wikijava.org.ua/index.php" id="searchform">
				<div id="simpleSearch">
						<input name="search" placeholder="Поиск" title="Искать в WikiJava: Wiki of Java: викифицированные книги и статьи по Java [f]" accesskey="f" id="searchInput">						<button type="submit" name="button" title="Найти страницы, содержащие указанный текст" id="searchButton"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/search-ltr.asc" alt="Найти" height="13" width="12"></button>								<input name="title" value="Служебная:Поиск" type="hidden">
		</div>
	</form>
</div>
				</div>
			</div>
			<div id="mw-panel">
					<!--<div id="p-logo" role="banner"><a style="background-image: url(/skins/common/images/wikijava.png);" href="index.php@title=Заглавная_страница.html"  title="Перейти на заглавную страницу"></a></div>-->
				<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
	<h3 id="p-navigation-label">Навигация</h3>
	<div class="body">
        <ul>
            <li id="n-mainpage-description"><a href="http://wikijava.org.ua/index.php?title=%D0%97%D0%B0%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D0%B0" title="Перейти на заглавную страницу [z]" accesskey="z">Заглавная страница</a></li>
            <li id="n-recentchanges"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D0%B5%D0%B6%D0%B8%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8" title="Список последних изменений [r]" accesskey="r">Свежие правки</a></li>
            <li id="n-.D0.9A.D0.BD.D0.B8.D0.B3.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%9A%D0%BD%D0%B8%D0%B3%D0%B8_Java">Книги Java</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D1.8C.D0.B8-Java"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D1%8C%D0%B8_Java">Статьи Java</a></li>
            <li id="n-Java-.D0.BF.D0.BE.D1.80.D1.82.D0.B0.D0.BB"><a href="http://wikijava.org.ua/index.php?title=Java-portal">Java портал</a></li>
            <li id="n-help"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0:%D0%A1%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D0%BD%D0%B8%D0%B5" title="Место, где можно получить справку">Справка</a></li>
            <li id="n-.D0.A1.D1.82.D0.B0.D1.82.D0.B8.D1.81.D1.82.D0.B8.D0.BA.D0.B0"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0">Статистика</a></li>
        </ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
	<h3 id="p-tb-label">Инструменты</h3>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8_%D1%81%D1%8E%D0%B4%D0%B0/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition" title="Список всех страниц, ссылающихся на данную [j]" accesskey="j">Ссылки сюда</a></li>
			<li id="t-recentchangeslinked"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B8/%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition" title="Последние изменения в страницах, на которые ссылается эта страница [k]" accesskey="k">Связанные правки</a></li>
			<li id="t-specialpages"><a href="http://wikijava.org.ua/index.php?title=%D0%A1%D0%BB%D1%83%D0%B6%D0%B5%D0%B1%D0%BD%D0%B0%D1%8F:%D0%A1%D0%BF%D0%B5%D1%86%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86%D1%8B" title="Список служебных страниц [q]" accesskey="q">Спецстраницы</a></li>
			<li id="t-print"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;printable=yes" rel="alternate" title="Версия этой страницы для печати [p]" accesskey="p">Версия для печати</a></li>
			<li id="t-permalink"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;oldid=38" title="Постоянная ссылка на эту версию страницы">Постоянная ссылка</a></li>
			<li id="t-info"><a href="http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_14_Thinking_in_Java_4th_edition&amp;action=info">Сведения о странице</a></li>
		</ul>
	</div>
</div>
<div class="portal" role="navigation" id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B" aria-labelledby="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">
	<h3 id="p-.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.8B-label">Другие проекты</h3>
	<div class="body">
		<ul>
			<li id="n-rastafara.com.ua"><a href="http://rastafara.com.ua/" rel="nofollow">rastafara.com.ua</a></li>
			<li id="n-rastafara-blog"><a href="http://sergey-rastafara.blogspot.com/" rel="nofollow">rastafara blog</a></li>
			<li id="n-rastaban"><a href="http://rastaban.com.ua/" rel="nofollow">rastaban</a></li>
		</ul>
	</div>
</div>
			</div>
		</div>
		<div id="footer" role="contentinfo">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> Последнее изменение этой страницы: 21:57, 16 февраля 2014.</li>
											<li id="footer-info-viewcount">К этой странице обращались 2473 раз.</li>
											<li id="footer-info-copyright">Содержимое доступно по лицензии <a class="external" rel="nofollow" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License 1.3 или более поздняя</a> (если не указано иное).</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9F%D0%BE%D0%BB%D0%B8%D1%82%D0%B8%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B4%D0%B5%D0%BD%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Политика конфиденциальности">Политика конфиденциальности</a></li>
											<li id="footer-places-about"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Описание">Описание WikiJava: Wiki of Java: викифицированные книги и статьи по Java</a></li>
											<li id="footer-places-disclaimer"><a href="http://wikijava.org.ua/index.php?title=WikiJava:_Wiki_of_Java:_%D0%B2%D0%B8%D0%BA%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BA%D0%BD%D0%B8%D0%B3%D0%B8_%D0%B8_%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8_%D0%BF%D0%BE_Java:%D0%9E%D1%82%D0%BA%D0%B0%D0%B7_%D0%BE%D1%82_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8" title="WikiJava: Wiki of Java: викифицированные книги и статьи по Java:Отказ от ответственности">Отказ от ответственности</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-copyrightico">
						<a href="http://www.gnu.org/copyleft/fdl.html"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/gnu-fdl.png" alt="GNU Free Documentation License 1.3 или более поздняя" height="31" width="88"></a>
					</li>
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2014_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" height="31" width="88"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<script>/*<![CDATA[*/window.jQuery && jQuery.ready();/*]]>*/</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest","ext.vector.collapsibleNav","ext.vector.collapsibleTabs","ext.vector.editWarning","ext.vector.simpleSearch","skins.vector.collapsibleNav"],null,true);
}</script>
<script>if(window.mw){
mw.loader.state({"site":"ready"});
}</script>
<!-- Served in 0.248 secs. -->
	

</body></html>