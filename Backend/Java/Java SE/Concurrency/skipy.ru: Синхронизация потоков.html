<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/main.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/header.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/print.css" media="print"><link rel="icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="shortcut icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="alternate" type="application/rss+xml" title="Новости сайта skipy.ru" href="http://www.skipy.ru/rss2.xml"><title>skipy.ru: Записки трезвого практика -&gt;
                Техника -&gt;
                Синхронизация потоков</title></head><body><script type="text/javascript">
            new Image().src = "//counter.yadro.ru/hit?r"+
            escape(document.referrer)+((typeof(screen)=="undefined")?"":
            ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
            ";"+Math.random();</script><div id="counter"><a href="http://www.liveinternet.ru/click" target="_blank"><img class="pcfykmqlcrtplekulgcu" src="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/logo.gif" title="LiveInternet" alt="" height="31" width="31" border="0"></a></div><table class="formatting" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div id="header"><table class="head" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/head_left.jpg" alt="Заголовок страницы"></td><td align="right"><img src="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/head_right.jpg" alt="Заголовок страницы"></td></tr></tbody></table><div id="headDelim"><span></span></div><div id="rootlink"><a href="http://www.skipy.ru/index.html" style="border: none;"><img src="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/dot.gif" alt="" height="130" width="120"></a></div><div id="menu"><table bgcolor="#264A84"><tbody><tr><td><a href="http://www.skipy.ru/index.html">Главная</a></td><td><a href="http://www.skipy.ru/philosophy.html">Философия</a></td><td class="current"><a href="http://www.skipy.ru/technics.html">Техника</a></td><td><a href="http://www.skipy.ru/architecture.html">Архитектура</a></td><td><a href="http://www.skipy.ru/useful.html">Полезное</a></td></tr></tbody></table></div><div id="submenu"><table bgcolor="#F49B2E"><tbody><tr><td><a href="http://www.skipy.ru/technics.html#general">Общее</a></td><td><a href="http://www.skipy.ru/technics.html#gui">GUI</a></td><td class="current"><a href="http://www.skipy.ru/technics.html#lang">java.lang</a></td><td><a href="http://www.skipy.ru/technics.html#io">java.io</a></td><td><a href="http://www.skipy.ru/technics.html#dyk">Знаете ли вы?..</a></td></tr></tbody></table></div></div></td></tr><tr><td><div id="content"><br>
        <p class="lastChange">Последнее изменение: 28 июля 2011г.</p>

<h2 id="top">Синхронизация потоков</h2>

<p class="epigraph-w">...Клетчатый специалист-хормейстер проорал:<br>
– До-ми-соль-до! – вытащил наиболее застенчивых из-за шкафов, где они пытались спастись от
пения, Косарчуку сказал, что у него абсолютный слух, заныл, заскулил, просил уважить старого регента-певуна, стучал
камертоном по пальцам, умоляя грянуть "Славное море".<br><br>
Грянули. И славно грянули. Клетчатый, действительно, понимал свое дело...</p>

<p class="epigraph"><i>М.А. Булгаков, "Мастер и Маргарита"</i></p>

<p>Вам приходилось когда-нибудь дирижировать оркестром? Или хотя бы хором? Второе мне довелось. Тридцать человек, два голоса.
И пусть каждый знает свою партию наизусть – сделать так, чтобы пятнадцать человек первого голоса и пятнадцать человек второго
пели в унисон, очень сложно. А уж чтобы не сбивались и каждый голос вел свою партию – и вовсе задача запредельная. Вот так я
впервые в жизни столкнулся с синхронизацией. :)</p>

<p>В современном, многопоточном, ПО проблемы синхронизации встают не менее остро. От их решения зависит очень и очень много.
Между тем, далеко не все знают, что, как, и, самое главное, зачем делать. Вот этим что, как и зачем применительно к Java и
посвящена эта статья.</p>

<p>Мы коснемся следующих тем:</p>

<ul>
    <li> <a href="#intro">Введение</a></li>
    <li> <a href="#threads">Потоки в Java</a></li>
    <li> <a href="#management">Управление выполнением потоков</a></li>
    <li> <a href="#monitors">Мониторы</a></li>
    <li> <a href="#deadlocks">Взаимные блокировки</a></li>
    <li> <a href="#data">Синхронизация данных</a></li>
    <li> <a href="#technique">Приемы синхронизации</a>
        <ul type="square">
            <li> <a href="#wait_notify">Системная синхронизация с использованием <code>wait/notify</code></a></li>
            <li> <a href="#join">Системная синхронизация с использованием <code>join</code></a></li>
            <li> <a href="#program_sync">Программная синхронизация – шаблоны и библиотеки</a></li>
        </ul>
    </li>
    <li> <a href="#practical_sync">Синхронизация на практике – Java SE и Java EE</a>
        <ul type="square">
            <li> <a href="#collections_sync">Синхронизация коллекций</a></li>
            <li> <a href="#gui_sync">Синхронизация GUI</a></li>
            <li> <a href="#servlets_sync">Синхронизация сервлетов</a></li>
        </ul>
    </li>
</ul>

<p>Итак, поехали.</p>

<h3 id="intro">Введение</h3>

<p>Для начала простейший вопрос – что такое потоки и для чего они вообще нужны? Жили ведь без них в течение долгого времени?
Жили. Но плохо и недолго. :)</p>

<p class="note">Сразу хочу сделать одно замечание. Так получилось, что при переводе на русский ДВА английских термина имеют
одинаковое значение – поток. Это "stream" и "thread". У второго из них есть еще один перевод – нить. Однако мне как-то
привычнее использовать именно термин "поток". Потому, в этой статье, если я говорю о потоке, то имею в виду именно thread.
</p>

<p>А что такое вообще поток как явление? Это набор исполняемых инструкций. Практически все современные ОС позволяют исполнять
несколько таких наборов одновременно. Ну, одновременно – понятие, конечно, относительное. Правильно было бы сказать –
одновременно с точки зрения пользователя. Ибо процессор один и исполнять он может только один набор инструкций. Потому, для
создания видимости одновременной работы процессор исполняет определенное количество инструкций одного потока, после чего
переключается на другой. Это происходит очень часто, в результате чего создается иллюзия одновременной работы.</p>

<p>Для чего это нужно. Современное ПО по большей часто асинхронно. 
Приложение ждет реакции пользователя, приложение ждет
прихода данных по сети, приложение ждет готовности устройства. 
Приложение ждет. Если вы посмотрите на загрузку процессора, то
увидите, что чаще всего 99% времени он простаивает. Соответственно, пока
 одна задача находится в стадии ожидания, можно
заниматься другой. Например, во время ожидания прихода данных по сети 
можно отрисовать то, что уже пришло. Это если говорить
о браузере. Да и вообще, в ОС одновременно происходит множество разных 
событий. Если бы всеми ими занимался один единственный поток
– все работало бы значительно медленнее. Если бы вообще работало.</p>

<p>Хочу еще разграничить два понятия – поток и процесс. Процесс – это задача операционной системы. У него собственное
адресное пространство. С ним может быть проассоциировано несколько потоков. Поток же – это гораздо более мелкая единица. Все
потоки разделяют адресное пространство породившего их процесса и имеют доступ к одним данным.</p>

<p>Вот тут-то и зарыта собака. Поскольку несколько потоков имеют доступ к одним данным, они их могут менять. Иногда это
может привести в большим и очень большим проблемам. Для решения этих проблем и нужна синхронизация.</p>

<p>С введением закончили, переходим к следующей теме –</p>

<h3 id="threads">Потоки в Java</h3>

<p>Итак, потоки в Java. Основа их – класс <code>java.lang.Thread</code> (<a target="_blank" href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Thread.html">http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Thread.html</a>).
Этот класс позволяет создать поток и запустить его на выполнение.</p>

<p>Существует два пути создания потока. Первый – наследование от класса <code>java.lang.Thread</code> и переопределение его
метода <code>run</code>. Второй – реализация интерфейса <code>java.lang.Runnable</code> и создание потока на основе этой
реализации. В принципе это методы эквивалентны, разница в деталях. Наследование от <code>java.lang.Thread</code> делает его
единственным родителем класса, что не всегда удобно. Я лично предпочитаю реализовывать <code>java.lang.Runnable</code>.</p>

<p>Таким образом, простейший поток может быть реализован так:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>public class</b> SampleThread <b>extends</b> Thread{

    <b>public</b> SampleThread(){
        <b>super</b>();
    }

    <b>public void</b> run(){
        System.out.println("Hello, threads world!");
    }

    <b>public static void</b> main(String[] args){
        Thread t = <b>new</b> SampleThread();
        t.start();
    }

}</pre>

<p>Или так:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>public class</b> SampleRunnable <b>implements</b> Runnable{

    <b>public</b> SampleRunnable(){
        <b>super</b>();
    }

    <b>public void</b> run(){
        System.out.println("Hello, threads world!");
    }

    <b>public static void</b> main(String[] args){
        Runnable r = <b>new</b> SampleRunnable();
        Thread t = <b>new</b> Thread(r);
        t.start();
    }

}</pre>

<p>Как я уже говорил, эти методы практически эквивалентны.</p>

<p>В приведенных примерах в методах <code>main</code> создаются потоки, после чего они запускаются на выполнение. Поток
завершается, когда произошел выход из метода <code>run</code>, либо если в методе <code>run</code> было выброшено
исключение, которое не было обработано. Чаще всего это <code>RuntimeException</code> или наследник, реже – <code>Error</code>
или наследник. После того, как поток завершил работу, перестартовать его НЕЛЬЗЯ. Попытка вторичного вызова <code>start</code>
приведет к исключению <code>IllegalThreadStateException</code>.</p>

<p>Для того, чтобы уже закончить с классом <code>Thread</code>, коснемся еще нескольких его возможностей.</p>

<p>Во-первых, у потоков могут быть различные приоритеты. Существует несколько констант – <code>Thread.MIN_PRIORITY == 1</code>,
<code>Thread.NORM_PRIORITY == 5</code> и <code>Thread.MAX_PRIORITY == 10</code>. Значения эти внутренние и с реальными
приоритетами потоков в операционной системе соотносятся слабо. </p>

<p>Во-вторых, потоки могу быть т.н. <em>демонами</em>. Такой поток отличается от обычного тем, что он не препятствует
окончанию работы виртуальной машины. Т.е. можно сказать, что виртуальная машина работает, пока существует хотя бы один поток,
не являющийся демоном. Потоки-демоны удобно использовать для фоновых задач.
</p>

<p>В-третьих, поток можно приостановить на определенный промежуток времени. Изнутри. Делается это через статический метод
<code>Thread.sleep()</code> с параметром – количеством миллисекунд, на которое приостанавливается поток. До истечения этого
времени поток может быть выведен из состояния ожидания вызовом <code>interrupt</code>, о котором мы поговорим в следующей
части.</p>

<p>И последнее, чего бы я тут хотел коснуться – статический метод <code>yield</code>. Он служит для передачи управления
другим потокам. Т.е. в результате его вызова происходит переключение контекста и процессор начинает исполнять код другого
потока. Это нужно как в ситуациях, когда работа на текущий момент завершена и можно дать поработать другим (например, поток
обрабатывает данные, все обработал, а новые еще не пришли), так и в ситуациях, когда поток занимается какими-нибудь
интенсивными действиями, съедает большую часть процессора и не дает другим потокам работать. Правда, последний подход я
встречал только в программировании под Java ME, в условиях ограниченных ресурсов. Обратите внимание, что этот метод
статический и действует только на <b>текущий</b> поток. Заставить таким образом чужой поток поделиться своим временем нельзя!
</p>

<p>Следующая тема –</p>

<h3 id="management">Управление выполнением потоков</h3>

<p>На данный момент мы знаем, как запустить поток на выполнение. Естественный вопрос – а как его остановить? Ответ может
оказаться обескураживающим. В Java НЕТ средств для принудительной остановки потока. Вернее, они есть, но использовать их
не стоит – метод <code>stop</code> объявлен <code>deprecated</code>. А вместе с ним – и <code>suspend</code> c <code>
resume</code>.</p>

<p>Почему это так сделано? Причины, несомненно, есть. Дело в том, что при принудительной остановке (приостановке) потока
совершенно непонятно, что делать с ресурсами. Поток может открыть сетевое соединение, например. Что делать с данными, которые
еще не вычитаны? Где гарантия, что после дальнейшего запуска потока (в случае приостановки) он сможет их дочитать? То же
самое и про соединение с базой данных. И еще много про что. А если поток остановят посередине транзакции? Кто ее будет
закрывать? Кто будет разблокировать ресурсы? В общем, проблем тут существенно больше, чем преимуществ.</p>

<p>Потому – в Java принят уведомительный порядок остановки потока. Вариантов реализации два: либо воспользоваться
существующими механизмами, либо создавать такие механизмы вручную. Мы рассмотрим оба варианта и проблемы, связаные с ними.
</p>

<p>Вариант первый – использовать существующий механизм. У класса <code>Thread</code> есть такой метод – <code>
interrupt</code>. Этот метод выставляет некоторый флаг в дебрях native-кода. В дальнейшем состояние этого флага можно
проверить с помощью метода <code>isInterrupted</code>. Существует также статический метод <code>interrupted</code>, который
производит проверку для текущего потока. Обратите внимание – вызов этого метода <b>сбрасывает</b> флаг, что подразумевает
ответственность разработчика по обработке этой ситуации. </p>

<p class="note">Кстати, если вам придется прерывать поток извне – это один из немногих случаев когда удобнее унаследоваться
от <code>Thread</code>. Если у вас будет ссылка на экземпляр <code>Thread</code>, вызвать у него <code>interrupt</code> не
составит труда. Если же вы будете держать ссылку на экземпляр <code>Runnable</code> – придется в начале метода <code>run
</code> сохранять ссылку на связаный с этим <code>Runnable</code> поток, реализовывать метод для получения этой ссылки и т.п.
В общем, много ненужной возни.</p>

<p>Что хорошо в методе <code>interrupt</code>? Он способен вывести поток из состояния ожидания. Т.е. если у потока были
вызваны методы <code>sleep</code> или <code>wait</code> (мы поговорим о нем ниже) – ожидание прервется и будет выброшено
исключение <code>InterruptedException</code>. Флаг в этом случае <b>не выставляется</b>, т.к. на брошеное исключение
разработчик отреагирует незамедлительно.</p>

<p>Таким образом, действовать нужно так. Реализуете поток (удобнее через наследование от <code>Thread</code>). В потоке
периодически вставляете проверки <code>isInterrupted</code>. Если проверка сработала или выброшено исключение во время
ожидания – поток пытаются остановить извне. Обращаю внимание – именно <b>остановить</b>, а не <b>ПРИостановить</b>. Вам
надо принять решение – либо вы продолжаете работу (если по каким-то причинам не можете остановиться), либо вы освобождаете
ресурсы и выходите из метода <code>run</code>. Что вы выберете – зависит от ситуации. Главное – у вас есть возможность
маневрировать и делать то, что сочтете нужным. В том числе и продолжать работу. В случае вызова <code>stop</code> такой
возможности нет.</p>

<p>Возможная проблема, которую я сейчас вижу в этом подходе – блокировки на потоковом вводе-выводе. Если поток заблокирован
на чтении данных (из какого-либо наследника <code>InputStream</code> или <code>Reader</code>) – вызов <code>interrupt</code>
его из этого состояния не выведет. Решение тут различается в зависимости от типа источника данных. Если чтение идет из файла
– долговременная блокировка крайне маловероятна. И тогда можно просто дождаться выхода из метода <code>read</code>. Если же
чтение каким-то образом связано с сетью – можно использовать неблокирующий ввод-вывод (Java NIO).</p>

<p class="off">Пара слов по поводу NIO. Официальной информации по этой технологии сейчас немного, во всяком случае внятного
руководства я не нашел. Есть какое-то количество примеров вот тут – <a href="http://java.sun.com/j2se/1.4/nio/index.html" target="_blank">http://java.sun.com/j2se/1.4/nio/index.html</a>. Есть также очень хорошая книга – Ron Hitchens. Java NIO.
ISBN: 0-596-00288-2. Правда, на английском, для кого-то это может быть минусом. Книга эта есть у меня в формате PDF, желающим
могу послать по почте.</p>

<p id="second_impl">Второй вариант реализации метода остановки (а также и приостановки) – сделать аналог
<code>interrupt</code>, но руками. Т.е. организовать в собственной реализации потока флаги – на остановку и приостановку, –
и выставлять их путем вызова методов извне. Методика действия та же – проверять установку флагов.</p>

<p>Недостатки такого подхода. Во-первых, потоки в состоянии ожидания таким способом не расшевелить. И это серьезный минус по
сравнению с первым методом. А во-вторых, выставление флага одним потоком совсем не означает, что второй поток тут же его
увидит. Для увеличения производительности виртуальная машина использует кеш данных потока, в результате чего обновление
переменной у второго потока может произойти через неопределенный промежуток времени. Можно, конечно, объявить эту переменную
<code>volatile</code>, но это поможет только в случае примитивных типов данных. Подробнее этого вопроса мы коснемся
<a href="#data">ниже</a>.</p>

<p>В связи со всем вышесказаным, я рекомендую использовать существующий механизм, основаный на выставлении native-флага и
использовании метода <code>interrupt</code>. Он намного удобнее и функциональнее.</p>

<p>Пойдем дальше. На очереди ...</p>

<h3 id="monitors">Мониторы</h3>

<p>Многие из вас явно встречались с объявлениями <code>synchronized</code>-методов и <code>synchronized</code>-блоков.
Пришла пора закопаться в то, что обеспечивает их работу. Называется это что-то – <em>монитор</em>.</p>

<p>Итак, что такое монитор. Я бы сказал так – это средство обеспечения контроля за доступом к ресурсу. У монитора может быть
максимум один владелец в каждый текущий момент времени. Следовательно, если кто-то использует ресурс и захватил монитор для
обеспечения единоличного доступа, то другой, желающий использовать тот же ресурс, должен подождать освобождения монитора,
захватить его и только потом начать использовать ресурс.</p>

<p>Удобно представлять монитор как <code>id</code> захватившего его объекта. Если этот <code>id</code> равен 0 – ресурс
свободен. Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.</p>

<p>Это была общая теория. Перейдем к Java. Здесь у <b>каждого экземпляра</b> объекта есть монитор. Реализован он где-то в
недрах native-кода и контролируется виртуальной машиной. Используется он так: любой <u id="nonstatic">нестатический</u>
<code>synchronized</code>-метод при своем вызове прежде всего пытается захватить монитор того объекта, у которого он
вызван (на который он может сослаться как на <code>this</code>). Если это удалось – метод исполняется. Если нет – поток
останавливается и ждет, пока монитор будет отпущен.</p>

<p>Как работает <code>synchronized</code>-блок. Пусть у нас есть следующий код:</p>

<pre>Object sync = <b>new</b> Object();
...
<b>synchronized</b>(sync){

}</pre>

<p>В этом случае (синхронизация блока) захватывается монитор у объекта <code>sync</code>. Таким образом, объявление
<code>synchronized</code>-метода ...
</p>

<pre><b>public synchronized void</b> someMethod(){
    // code
}</pre>

<p>... полностью эквивалентно следующей конструкции:</p>

<pre><b>public void</b> someMethod(){
    <b>synchronized</b>(<b>this</b>){
        // code
    }
}</pre>

<p>Выше я неслучайно <a href="#nonstatic">акцентировал внимание</a> на том, что это верно для нестатического метода.
Действительно, у статического метода нет ссылки <code>this</code>. А синхронизированый статический метод – реальность. Чей же
монитор он захватывает? Все просто. Пусть у него нет ссылки <code>this</code>, но есть класс. В смысле, объект класса
<code>Class</code>.  И есть он в одном экземпляре. Идеальный кандидат на использование его монитора для синхронизации
статических методов. Собственно, именно так и делается. Таким образом, следующая конструкция:</p>

<pre><b>public class</b> SomeClass{

    <b>public static synchronized void</b> someMethod(){
        //code
    }

}</pre>

<p>... эквивалентна такой:</p>

<pre><b>public class</b> SomeClass{

    <b>public static void</b> someMethod(){
        <b>synchronized</b>(SomeClass.<b>class</b>){
            //code
        }
    }

}</pre>

<p>Итак, резюме. Если два нестатических метода объявлены как <code>synchronized</code>, то в каждый момент времени <em>из
разных потоков</em> <b>на одном объекте</b> может быть вызван только один из них. Поток, который вызывает метод первым,
захватит монитор, и второму потоку придется ждать. Заостряю ваше внимание на трех моментах:</p>

<ul>
    <li>Это верно только для <b>разных</b> потоков. Один и тот же поток может вызвать синхронизированный метод, внутри него –
    другой синхронизированный метод на том же экземпляре. Поскольку этот поток владеет монитором, проблем второй вызов не
    создаст.</li>
    <li>Это верно только для вызовов методов <b>одного</b> экземпляра. У разных экземпляров разные мониторы, потому
    одновременный вызов нестатических методов проблем не создаст</li>
    <li>В случае статических методов имеет значение только одно – разные ли потоки, вызывающие синхронизированные методы,
    или нет. Об экземпляре тут речи не идет, его роль исполняет объект класса.</li>
</ul>

<p>Еще одно замечание. Объекты класса <code>Class</code> существуют в единственном экземпляре только в пределах одного
ClassLoader-а. Следовательно, если вы установите контекстный загрузчик классов потоку – у разных потоков могут быть разные
экземпляры одного и того же класса <code>Class</code> и, следовательно, будет возможен одновременный вызов синхронизированных
статических методов. Если эти методы используют одни и те же ресурсы – это может вызвать проблемы.</p>

<p>Сразу же возникает вопрос о взаимодействии синхронизированных методов с несинхронизированными. Т.е. – возможен ли
одновременный их вызов из двух потоков. Да, возможен. Ибо несинхронизированный метод при вызове не пытается захватить
монитор, и, следовательно, ничто ему не может помешать. А потому – надо очень аккуратно подходить к синхронизации методов.</p>

<p>Для чего же все-таки нужно два различных варианта синхронизации – на уровне метода и на уровне блока? Почему нельзя
обойтись одним?</p>

<p>Синхронизация на уровне метода имеет очевидный недостаток – метод может быть долгим. Если, скажем, нужно менять данные
в некой реализации <code>Runnable</code> (например, выставлять флаг окончания работы потока, как я описывал
<a href="#second_impl">выше</a>) и при этом синхронизировать метод <code>run</code> – ничего хорошего не получится. Ибо
<code>run</code> захватит монитор при старте и любой вызов любого синхронизированного метода из любого другого потока будет
блокирован.</p>

<p>Можно было бы, конечно, ограничиться только синхронизацией на уровне блока. Функционально это то же самое. Но менее
удобно. У синхронизированного метода ключевое слово <code>synchronized</code> фигурирует в сигнатуре, что сразу дает
разработчику много информации о поведении данного метода. Если же синхронизация будет внутри, блоком от начала до конца
метода – о том, что она есть, нужно будет упоминать в комментариях к методу. Учитывая любовь разработчиков к написанию
комментариев, а также к их чтению (а тем паче – к чтению документации!) – лучше включить подобное указание в сигнатуру.</p>

<p>С механизмом синхронизации (захватом монитора) неразрывно связан такой неприятный феномен, как взаимные блокировки,
<em>deadlocks</em>. О них мы поговорим в следующей части.</p>

<h3 id="deadlocks">Взаимные блокировки</h3>

<p>Что такое взаимная блокировка по своей сути? Все достаточно просто. Предположим, что один поток уже захватил монитор на
некотором объекте <code>x</code> и для продолжения работы ему нужно захватить монитор на объекте <code>y</code>. В другом
же потоке ситуация ровно обратная – он уже захватил монитор на объекте <code>y</code> и ему нужен монитор объекта
<code>x</code>. В результате оба потока будут ждать, пока нужный монитор освободится. Как вы сами прекрасно понимаете,
ждать они будут до бесконечности. Эта ситуация и называется <em>взаимной блокировкой</em> – <em>deadlock</em>.</p>

<p>Рассмотрим вполне невинный пример:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

/**
 * DeadLockTest
 *
 * @author Eugene Matyushkin
 * @version 1.0
 */
<b>public class</b> DeadLockTest{

    <b>public static void</b> main(String[] args){
        A a1 = <b>new</b> A();
        A a2 = <b>new</b> A();
        Thread t1 = <b>new</b> Thread(<b>new</b> Tester(a1,a2));
        Thread t2 = <b>new</b> Thread(<b>new</b> Tester(a2,a1));
        t1.start();
        t2.start();
    }

    <b>public static class</b> Tester <b>implements</b> Runnable{

        <b>static int</b> nextId = 1;

        <b>private</b> A obj1;
        <b>private</b> A obj2;
        <b>private int</b> id = 0;

        <b>public</b> Tester(A obj1, A obj2){
            <b>this</b>.obj1 = obj1;
            <b>this</b>.obj2 = obj2;
            id = nextId++;
        }

        <b>public void</b> run(){
            print("Setting value to obj1... ");
            obj1.setValue(id);
            print("done.");
            print("Comparing objects... ");
            print("Done. Result: "+((obj1.equals(obj2)) ? "equal" : "not equal"));
        }

        <b>private void</b> print(String msg){
            System.out.println("Thread #"+id+": "+msg);
        }
    }

    <b>public static class</b> A{

        <b>private int</b> value = 0;

        <b>synchronized void</b> setValue(<b>int</b> value){
            <b>this</b>.value = value;
        }

        <b>synchronized int</b> getValue(){
            <b>return</b> value;
        }

        <b>public synchronized boolean</b> equals(Object o){
            A a = (A) o;
            <b>try</b>{
                Thread.sleep(1000);
            }<b>catch</b>(InterruptedException ex){
                System.err.println("Interrupted!");
            }
            return value == a.getValue();
        }
    }
}</pre>

<p>В центре примера – класс <code>A</code>. Тривиальный контейнер для единственного числа, с синхронизированными методами
установки значения, его чтения и сравнения. (Разумеется, было бы нравственно вместе с <code>equals</code> переопределить еще
и <code>hashCode</code>, но для данного примера это абсолютно некритично.) Задержка в методе <code>equals</code> нужна
как имитация долгой работы.</p>

<p>Далее, поток <code>Tester</code>, реализация <code>Runnable</code>. Тоже ничего криминального – установка значения одному
из объектов и сравнение с другим объектом. Ну и метод <code>main</code> – создание двух объектов, двух потоков и запуск всего
этого хозяйства.</p>

<p>Можете попробовать запустить этот тест. У меня он гарантированно виснет. Оба потока останавливаются на стадии <em>
"Comparing objects... "</em>.</p>

<p>Что же тут происходит? Рассмотрим все по шагам. Для определенности будем предполагать, что поток <code>t1</code> имеет
<code>id=1</code>, а <code>t2</code> – <code>id=2</code>.</p>

<p>Итак, создание экземпляров класса <code>Tester</code>. Для потока <code>t1</code> <code>obj1=a1, obj2=a2</code>. Для
<code>t2</code> наоборот – <code>obj1 = a2, obj2=a1</code>.</p>

<p>Исполнение. В потоке <code>t1</code> объекту <code>a1</code> выставляется значение 1, в потоке <code>t2</code> объекту
<code>a2</code> – значение 2. При этом на время вызова <code>setValue</code> захватываются мониторы на соответствующих
объектах.</p>

<p>А вот дальше начинается самое интересное. Вызов <code>equals</code>. Поток <code>t1</code> захватывает монитор на объекте
<code>a1</code>. И ждет секунду. Приблизительно в то же самое время поток <code>t2</code> захватывает монитор на объекте
<code>a2</code>. И тоже ждет. А после ожидания каждый поток пытается захватить монитор другого объекта – <code>a2</code>
для <code>t1</code> и <code>a1</code> для <code>t2</code>. Поскольку мониторы уже захвачены другим потоком – происходит
взаимная блокировка: потоки входят в состояние бесконечного ожидания.</p>

<p>В данном случае определить источник проблем сравнительно просто – не так много мест, где используется синхронизация.
Можно найти методом исключения. Как только вы уберете ключевое слово <code>synchronized</code> у <code>equals</code> или у
<code>getValue</code> – проблема уйдет. В случае же сложной логики поиск источника взаимной блокировки – страшная вещь. Не
поможет даже отладчик – пока вы будете по шагам идти по одной линии исполнения, другая уже может закончиться. Возможна,
кстати, и обратная ситуация – спонтанные блокировки при работе в отладчике, а при исполнении все будет нормально. Просто
потоки пересеклись в нужное время в нужном месте.</p>

<p>Способов определить случившуюся взаимную блокировку в Java нет. Виртуальная машина никак не отслеживает подобных ситуаций.
Теоретически могут помочь профайлеры, из тех, кто умеет отслеживать состояние потоков. Однако все это лишь костыли. Реально
делу может помочь только тщательное продумывание синхронизации. Что мы синхронизируем, зачем и как.</p>

<p class="off">На самом деле, утверждение, что взаимные блокировки не отслеживаются, не совсем верно. Если попросить
виртуальную машину выдать дамп всех потоков (для Windows-систем это <em>Ctrl+Break</em>, для *NIX – <em>kill -3</em>, если я
правильно помню), то взаимно заблокированные потоки определяются и соответствующим образом помечаются. Другое дело, что
это чистая информация – предпринять какие-либо действия по этому поводу все равно не получится.</p>

<p>Приведенный выше пример может показаться надуманным. Следующий же взят из реальной жизни.</p>

<div class="example">
<h5 id="selfExp1">Собственный опыт</h5>

<p class="ex">Случилось мне с полгода назад реализовывать библиотеку для распределенной блокировки ресурсов. Фактически,
монитор, доступный в нескольких виртуальных машинах, в виде Java-объекта. Ну и полный сопутствующий набор методов – захватить
(<code>lock</code>), отпустить (<code>release</code>). Естественно, методы синхронизированы. Логика при этом была следующей –
если поток, вызывающий <code>lock</code>, не может в действительности захватить монитор (он уже захвачен другим потоком), то
он входит в состояние ожидания, вызывая <code>wait</code> на объекте монитора. Когда владелец монитора отпускает его, он
вызывает у него <code>notify</code>, в результате чего ожидающий поток может продолжить работу и захватить монитор. Подробнее
о механизме синхронизации через <code>wait/notify</code> мы поговорим <a href="#wait_notify">ниже</a>.
</p>

<p class="ex">Все замечательно работало. Однако в какой-то момент мы нашли потенциальную проблему. Поскольку поток ожидает
своей очереди на захват монитора на самом объекте монитора – <code>notify</code> может вызвать кто угодно. Со всеми
вытекающими последствиями. Надо бы сделать ожидание на внутреннем объекте.
</p>

<p class="ex">Сделали. Пока поток один – все в порядке. Как только появляется поток, ждущий захвата монитора – владелец
монитора отпустить его не может. Останавливается на входе в <code>release</code>. В чем дело?</p>

<p class="ex">Как обычно – в синхронизации. Методы были синхронизированы? Были. Что означает, что на входе в них захватывался
системный монитор. При вызове <code>wait</code> в методе <code>lock</code> системный монитор отпускался, что давало
возможность другому потоку войти в <code>release</code>. После рефакторинга метод <code>wait</code> стал вызываться на
внутреннем объекте синхронизации, следовательно, системный монитор продолжал быть захваченым! И вызов <code>release</code> из
другого потока закономерно блокировался до отпускания системного монитора. А он не может быть отпущен, пока ожидающий поток
не выйдет из <code>lock</code>, что не может произойти, пока на внутреннем объекте синхронизации не будет вызван
<code>notify</code>, что и должно произойти в <code>release</code>, в который невозможно войти. Взаимная блокировка в
действии!
</p>

<p class="ex">Ошибка заключалась в том, что методы <code>lock</code> и <code>release</code> остались синхронизированными,
хотя синхронизация уже осуществлялась на внутреннем объекте.</p>
</div>


<p>Подводя итог: взаимные блокировки легко создать и трудно обнаружить. А потому – к синхронизации надо относиться очень и
очень ответственно. Впрочем, как и ко всему остальному.</p>

<p>Следующий немаловажный момент в понимании синхронизации как явления – </p>

<h3 id="data">Синхронизация данных</h3>

<p>Одной из проблем при работе с данными из разных потоков является их синхронизация. И даже не столько в случае
одновременного изменения. Чтение данных в одном потоке после изменения их другим потоком тоже может давать неверный
результат. Происходит это по той причине, что, как я уже упоминал, поток держит у себя локальные копии данных, которые
использует для чтения. И обновление их происходит в тот момент времени, который сочтет для этого удобным виртуальная машина.
Сразу подчеркиваю, мы говорим о том случае, когда никаких усилий по синхронизации не предпринимается.</p>

<p id="volatile">В теории поле объекта можно объявить с модификатором <code>volatile</code>. Этот модификатор вынуждает
    потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной. К сожалению, спасает это не
    всегда. Если переменная примитивного типа – этого будет достаточно. Если же переменная является ссылкой на
    объект – синхронизировано будет исключительно значение этой ссылки. Все же данные, содержащиеся в объекте,
    синхронизированы не будут! Кстати, синхронизации ссылок будет достаточно и в том случае, если переменная имеет тип
    перечисления – <code>enum</code>. Все элементы перечисления существуют в единственном экземпляре и могут
    сравниваться по ссылкам.</p>

<p>Действительным спасением является обычная синхронизация. При входе в синхронизированный метод или блок все данные,
используемые в них, синхронизируются автоматически. И проблем с чтением актуальных значений не возникает.</p>

<p>Проблемы могут проявиться в другом. А именно – в производительности. Синхронизация – это все-таки некоторые дополнительные
издержки. При большой интенсивности использования синхронизированных методов исключительно для доступа к данным эти издержки
могут дать отрицательный эффект и вызвать желание избавиться от синхронизации. Я об этом говорил в статье о реализации
шаблона Singleton, в разделе <a href="http://www.skipy.ru/technics/singleton.html#initAndSync">инициализация и синхронизация</a>. В некоторых случаях
от синхронизации действительно можно отказаться. Если рассматривать пример реализации того же Singleton-а, то при его
интенсивном использовании можно отложенную инициализацию заменить обычной, тогда метод для получения экземпляра можно не
синхронизировать. В общем, варианты найти можно. Однако я не уверен, что синхронизация может дать ощутимое падение
производительности. И потому, как я и говорил неоднократно – сначала синхронизируйте. Потом, когда выяснится (<em>если</em>
выяснится!), что именно синхронизация является причиной падения производительности и ее отсутствие поможет делу – только
тогда думайте о том, как бы ее убрать. Да, и обязательно напишите мне об этом случае!</p>

<p>С синхронизацией данных связано еще такое понятие как <em>thread safety</em>. Я затрудняюсь перевести этот термин на
русский. Объект является <em>thread-safe</em>, если его методы могут вызываться из различных потоков без ущерба для его
состояния. Никаких усилий по синхронизации при этом прилагать не требуется, об этом заботится сам объект. Мы с этим понятием
еще встретимся <a href="#practical_sync">ниже</a>.</p>

<p>Вот мы и подошли к самому, пожалуй, интересному разделу. А именно – </p>

<h3 id="technique">Приемы синхронизации</h3>

<p>По уровню, на котором производится синхронизация потоков, ее можно разделить на две области – системная и программная.
Как, наверное, понятно из названия, системная осуществляется с использованием средств (мониторов и пр.) виртуальной машины,
в то время как в программной роль объектов, на которых происходит синхронизация, играют Java-объекты. Начнем с системной.
Советую всем еще раз просмотреть API классов <code>java.lang.Object</code> (методы <code>wait/notify</code>) и <code>
java.lang.Thread</code>.</p>

<h4 id="wait_notify">Системная синхронизация с использованием <code>wait/notify</code></h4>

<p>Пожалуй, это наиболее часто использующийся тип синхронизации. Суть его проста. Берется некий объект. Поток, который ждет
выполнения каких-либо условий, вызывает у этого объекта метод <code>wait</code>, предварительно захватив его монитор. На этом
его работа приостанавливается. Другой поток может вызвать на этом же самом объекте метод <code>notify</code> (опять же,
предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток "просыпается" и продолжает свое
выполнение. Подчеркиваю, в обоих случаях монитор надо захватывать в явном виде, через <code>synchronized</code>-блок, ибо
методы семейства <code>wait/notify</code> не синхронизированы! Для меня загадка, почему это так, но примем как данность.</p>

<p>Вот простой пример.</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>public class</b> SyncTest {

    <b>public static void</b> main(String[] args) {
        Object sync = <b>new</b> Object();
        Data data = <b>new</b> Data();
        Thread t = <b>new</b> Thread(<b>new</b> WaitingThread(sync, data));
        t.start();
        <b>try</b>{
            System.out.println("main::Sleeping");
            Thread.sleep(500);
        }<b>catch</b>(InterruptedException ex){
            System.err.println("main::Interrupted: "+ex.getMessage());
        }
        <span class="red_b">synchronized (sync)</span>{
            System.out.println("main::setting value to 1");
            data.value = 1;
            System.out.println("main::notifying thread");
            <span class="red_b">sync.notify();</span>
            System.out.println("main::Thread notified");
        }
    }

    <b>static class</b> Data {
        <b>public int</b> value = 0;
    }

    <b>static class</b> WaitingThread <b>implements</b> Runnable {

        <b>private</b> Object sync;
        <b>private</b> Data data;

        <b>public</b> WaitingThread(Object sync, Data data) {
            <b>this</b>.sync = sync;
            <b>this</b>.data = data;
        }

        <b>public void</b> run() {
            System.out.println("own:: Thread started");
            <span class="red_b">synchronized(sync)</span> {
                <b>if</b> (data.value == 0) {
                    <b>try</b> {
                        System.out.println("own:: Waiting");
                        <span class="red_b">sync.wait();</span>
                        System.out.println("own:: Running again");
                    } <b>catch</b> (InterruptedException ex) {
                        System.err.println("own:: Interrupted: "+ex.getMessage());
                    }
                }
                System.out.println("own:: data.value = "+data.value);
            }
        }
    }
}</pre>

<p>Как вы видите, условием для продолжения работы потока в <code>WaitingThread</code> является <code>data.value!=0</code>.
Если это условие не выполняется – поток ждет. Причем СНАЧАЛА он получает монитор объекта, на котором идет синхронизация –
<code>sync</code>, – а уж потом проверяет условие. Это сделано для синхронизации данных, а именно – значения <code>
data.value</code>. Далее вызывается <code>sync.wait()</code>. Основной же поток задерживается на небольшое время, чтобы дать
второму потоку стартовать, после чего выставляет нужное значение (перед этим захватив монитор!) и вызывает <code>
sync.notify()</code>. После этого второй поток продолжает работу и, как мы видим, у него значение <code>data.value =
1</code>.</p>

<p>Самые внимательные, вероятно, обратили внимание на один тонкий момент. Каждый поток перед вызовом <code>wait</code>
или <code>notify</code> захватывает монитор на объекте <code>sync</code>. Причем в потоке main это происходит в то время,
когда поток own ждет в точке вызова <code>wait</code>, т.е. – еще <b>не вышел</b> из синхронизированного блока! Нас где-то
кидают?</p>

<p>Нет. Все законно. Дело в том, что если поток останавливается внутри метода <code>wait</code>, то системный монитор
<b>отпускается</b>! В противном случае будет невозможно вызвать <code>notify</code>. И этот факт обязательно надо знать,
ибо из него следует много очень важных тонкостей.</p>

<p>Зададимся вот каким вопросом. Вызов <code>wait</code> происходит в синхронизированном блоке. Следовательно, прямо после
вызова монитор должен быть захвачен, ибо выйти из блока мы еще не успели. Внутри же метода <code>wait</code> монитор
отпускается и захватывается потоком, вызывающим <code>notify</code>. Внимание, вопрос: в какой момент происходит обратный
захват монитора потоком, ждущим в <code>wait</code>? Ответить на него поможет следующий несложный тест:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>public class</b> MonitorCaptureTest {

    <b>public static void</b> main(String[] args) {
        Object sync = <b>new</b> Object();
        Thread t = <b>new</b> Thread(<b>new</b> WaitingThread(sync));
        t.start();
        <b>try</b> {
            Thread.sleep(1000);
        } <b>catch</b> (InterruptedException ex) {
            System.err.println("main::Interrupted: " + ex.getMessage());
        }
        <b>synchronized</b> (sync) {
            System.out.println("main::Calling notify");
            sync.notify();
            System.out.println("main::Sleeping for 5 seconds");
            <b>try</b> {
                Thread.sleep(5000);
            } <b>catch</b> (InterruptedException ex) {
                System.err.println("main::Interrupted: " + ex.getMessage());
            }
            System.out.println("main::Exiting synchronized block");
        }
    }

    <b>static class</b> WaitingThread <b>implements</b> Runnable {

        <b>private</b> Object sync;

        <b>public</b> WaitingThread(Object sync) {
            <b>this</b>.sync = sync;
        }

        <b>public void</b> run() {
            <b>synchronized</b> (sync) {
                System.out.println("own:: Waiting");
                <b>try</b> {
                    sync.wait();
                } <b>catch</b> (InterruptedException ex) {
                    System.err.println("own:: Interrupted: " + ex.getMessage());
                }
                System.out.println("own:: Running again");
            }
        }
    }
}</pre>

<p>В общем-то тест прозрачен. Мы запускаем поток, ждем немного, чтобы он добрался до вызова <code>wait</code>, потом вызываем
<code>notify</code> в основном потоке и... ждем. И смотрим, что будет. Результат, в общем-то предсказуем:</p>

<pre><span class="blue">own</span>:: Waiting
<span class="green">main</span>::Calling notify
<span class="green">main</span>::Sleeping for 5 seconds
<span class="green">main</span>::Exiting synchronized block
<span class="blue">own</span>:: Running again</pre>

<p>Итак, несмотря на то, что <code>notify</code> уже вызван, ждущий поток все еще стоит до того момента, пока не будет
отпущен монитор. Это происходит при выходе из синхронизированного блока в потоке, вызвавшем <code>notify</code>. Сразу
после этого ждущий поток захватывает монитор обратно и продолжает работу.</p>

<p>То же самое происходит и при вызове <code>wait</code> с параметром – временем ожидания в миллисекундах. Выполним следующий
код:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>import</b> java.text.DateFormat;
<b>import</b> java.text.SimpleDateFormat;
<b>import</b> java.util.Date;

<b>public class</b> WaitWithTOTest {

    <b>static final</b> DateFormat FORMAT = <b>new</b> SimpleDateFormat("HH:mm:ss");

    <b>public static void</b> main(String[] args) {
        Object sync = <b>new</b> Object();
        Thread t = <b>new</b> Thread(<b>new</b> WaitingThread(sync));
        t.start();
        <b>try</b> {
            Thread.sleep(1000);
        } <b>catch</b> (InterruptedException ex) {
            log("main::Interrupted: " + ex.getMessage());
        }
        <b>synchronized</b> (sync) {
            log("main::Sleeping for 5 seconds");
            <b>try</b> {
                Thread.sleep(5000);
            } <b>catch</b> (InterruptedException ex) {
                log("main::Interrupted: " + ex.getMessage());
            }
            log("main::Exiting synchronized block");
        }
    }

    <b>static void</b> log(String msg){
        System.out.println(FORMAT.format(<b>new</b> Date())+": "+msg);
    }

    <b>static class</b> WaitingThread <b>implements</b> Runnable {

        <b>private</b> Object sync;

        <b>public</b> WaitingThread(Object sync) {
            <b>this</b>.sync = sync;
        }

        <b>public void</b> run() {
            <b>synchronized</b> (sync) {
                log("own:: Waiting for 2 seconds");
                <b>try</b> {
                    sync.wait(2000);
                } <b>catch</b> (InterruptedException ex) {
                    log("own:: Interrupted: " + ex.getMessage());
                }
                log("own:: Running again");
            }
        }
    }
}</pre>

<p>Этот код не менее прозрачен, нежели предыдущий. Мы запускаем поток, ждем, чтобы он добрался до вызова <code>wait</code> с
двухсекундным временем ожидания. Затем захватываем монитор и засыпаем, на 5 секунд. Это время гарантированно больше того,
которое еще осталось ждать другому потоку. Вот результат:</p>

<pre>12:32:09: <span class="blue">own</span>:: Waiting for 2 seconds
12:32:10: <span class="green">main</span>::Sleeping for 5 seconds
12:32:15: <span class="green">main</span>::Exiting synchronized block
12:32:15: <span class="blue">own</span>:: Running again</pre>

<p>Для удобства в этом тесте я добавил временные засечки<sup><a href="#ref1">1</a></sup>. Итак, наш поток останавливается в 12:32:09 на две секунды, т.е.
продолжить работу он должен в 12:32:11. Монитор он при этом, естественно, отпускает. Далее, в 12:32:10 в основном потоке
монитор захватывается и отпускается только через 5 секунд, в 12:32:15. Соответственно, пока это не произошло, ждущий поток
не может захватить монитор обратно и продолжить работу. Кстати, этот тест дает еще немножко информации по поводу метода
<code>Thread.sleep</code>. При его вызове никакие мониторы <b>не отпускаются</b>!</p>

<p>Теперь совершим краткий экскурс в API <code>java.lang.Object</code>. Помимо трех <code>wait</code> и одного <code>
notify</code>, с которыми мы уже знакомы, там есть еще и метод <code>notifyAll</code>. Что это за зверь и с чем его едят?</p>

<p>Представьте себе, что один поток вызвал <code>wait</code> на каком-либо объекте и ждет. Внимание, вопрос: мешает ли
кто-нибудь другому потоку вызвать на этом же объекте <code>wait</code>? Учитывая, что монитор отпущен – вряд ли. И вот уже
ДВА потока ждут у моря погоды. Мешает ли кто-нибудь третьему потоку присоединиться к ним? А четвертому? Пятому?</p>

<p><code>notifyAll</code> служит для одной цели – отправить в плаванье ВСЕ ждущие потоки. В то время как вызов <code>notify
</code> подействует только на один.</p>

<p>Кстати, хороший вопрос. А на какой именно из пяти ждущих потоков подействует вызов <code>notify</code>? Знаете, какой
правильный ответ? <b>А черт его знает!</b> :) Это действительно так – <code>notify</code> выводит из состояния ожидания
<b>произвольный</b> поток.</p>

<p>Еще один хороший вопрос. А в каком порядке выводит из состояния ожидания потоки вызов <code>notifyAll</code>? Догадались,
какой правильный ответ?.. :)</p>

<p>Еще один тест, суммирующий все вышесказаное. На этот раз у нас ПЯТЬ ждущих потоков:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>import</b> java.util.Date;
<b>import</b> java.text.DateFormat;
<b>import</b> java.text.SimpleDateFormat;

<b>public class</b> NotifyAllTest {

    <b>static final</b> DateFormat FORMAT = <b>new</b> SimpleDateFormat("HH:mm:ss");

    <b>public static void</b> main(String[] args) {
        Object sync = <b>new</b> Object();
        <b>for</b>(<b>int</b> i=0; i&lt;5; i++){
            Thread t = <b>new</b> Thread(<b>new</b> WaitingThread(sync));
            t.start();
        }
        <b>try</b>{
            Thread.sleep(1000);
        }<b>catch</b>(InterruptedException ex){
            System.err.println("main::  Interrupted: "+ex.getMessage());
        }
        <b>synchronized</b>(sync){
            log("main::  Calling notifyAll");
            sync.notifyAll();
            log("main::  Sleeping for 3 seconds");
            <b>try</b>{
                Thread.sleep(3000);
            }<b>catch</b>(InterruptedException ex){
                System.err.println("main::  Interrupted: "+ex.getMessage());
            }
            log("main::  Exiting synchronized block");
        }
    }

    <b>static void</b> log(String msg){
        System.out.println(FORMAT.format(<b>new</b> Date())+": "+msg);
    }

    <b>static class</b> WaitingThread <b>implements</b> Runnable{

        <b>static int</b> nextId = 1;

        <b>private</b> Object sync;
        <b>private int</b> id;

        <b>public</b> WaitingThread(Object sync) {
            <b>this</b>.sync = sync;
            id = nextId++;
        }

        <b>public void</b> run() {
            <b>synchronized</b> (sync) {
                log("own("+id+")::Waiting");
                <b>try</b> {
                    sync.wait();
                } <b>catch</b> (InterruptedException ex) {
                    log("own("+id+")::Interrupted: " + ex.getMessage());
                }
                log("own("+id+")::Running again");
                log("own("+id+")::Sleeping for 1 second");
                <b>try</b> {
                    Thread.sleep(1000);
                } <b>catch</b> (InterruptedException ex) {
                    log("own("+id+")::Interrupted: " + ex.getMessage());
                }
                log("own("+id+")::Finishing");
            }
        }
    }
}</pre>

<p>Результат:</p>

<pre>13:20:37: <span class="blue">own(1)</span>::Waiting
13:20:37: <span class="blue">own(2)</span>::Waiting
13:20:37: <span class="blue">own(4)</span>::Waiting
13:20:37: <span class="blue">own(3)</span>::Waiting
13:20:37: <span class="blue">own(5)</span>::Waiting
13:20:38: <span class="green">main</span>::  Calling notifyAll
13:20:38: <span class="green">main</span>::  Sleeping for 3 seconds
13:20:41: <span class="green">main</span>::  Exiting synchronized block
13:20:41: <span class="blue">own(2)</span>::Running again
13:20:41: <span class="blue">own(2)</span>::Sleeping for 1 second
13:20:42: <span class="blue">own(2)</span>::Finishing
13:20:42: <span class="blue">own(1)</span>::Running again
13:20:42: <span class="blue">own(1)</span>::Sleeping for 1 second
13:20:43: <span class="blue">own(1)</span>::Finishing
13:20:43: <span class="blue">own(4)</span>::Running again
13:20:43: <span class="blue">own(4)</span>::Sleeping for 1 second
13:20:44: <span class="blue">own(4)</span>::Finishing
13:20:44: <span class="blue">own(3)</span>::Running again
13:20:44: <span class="blue">own(3)</span>::Sleeping for 1 second
13:20:45: <span class="blue">own(3)</span>::Finishing
13:20:45: <span class="blue">own(5)</span>::Running again
13:20:45: <span class="blue">own(5)</span>::Sleeping for 1 second
13:20:46: <span class="blue">own(5)</span>::Finishing</pre>

<p>Итак, что мы видим. Первое. Несмотря на то, что потоки создавались с <code>id</code> по порядку, к вызову wait они могут
придти в другом порядке. И зависит это буквально от малейшего чиха. Если в конструктор <code>WaitingThread</code> добавить
синхронизацию на присваивание <code>id</code>:</p>

<pre><b>public</b> WaitingThread(Object sync) {
    <b>this</b>.sync = sync;
    <b>synchronized</b>(sync){
        id = nextId++;
    }
}</pre>

<p>..., то порядок может измениться. У меня, во всяком случае, он меняется. (Кстати, а нужна ли тут такая синхронизация?
Ответ <a href="#answer1">в конце статьи, №1</a>.)</p>

<p>Что еще мы видим? Порядок выхода из состояния ожидания вообще произволен. Запустите тест несколько раз, скорее всего
порядок будет меняться от вызова к вызову. Ну и наконец, то, что мы уже обсуждали – из состояния ожидания потоки выходят
строго по очереди. Каждый из них захватывает монитор, отрабатывает до конца, выходит из синхронизированного блока, после
чего монитор захватывает следующий поток и т.д. Кстати, еще вопрос – можно ли в этом примере синхронизированный блок в методе
<code>run</code> заменить синхронизацией самого метода <code>run</code>? Ответ <a href="#answer2">в конце статьи, №2</a>.</p>

<p>И последнее, пожалуй, на что я бы хотел обратить ваше внимание в связи с использованием <code>wait</code>. Это опять-таки
следует из того факта, что монитор внутри <code>wait</code> отпускается. Если вы синхронизируете доступ к данным на уровне
методов, и при этом в каком-либо из методов вызываете <code>wait</code> – в промежутке ожидания другой поток может вызвать
синхронизированный метод и изменить данные. Т.е., фактически, данные в начале синхронизированного метода будут одни, а в
конце – другие. Эта возможность часто упускается. А потом становится причиной головной боли. Вот еще один простой пример:</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;


<b>import</b> java.util.Date;
<b>import</b> java.text.DateFormat;
<b>import</b> java.text.SimpleDateFormat;

<b>public class</b> ReentranceTest {

    <b>static final</b> DateFormat FORMAT = <b>new</b> SimpleDateFormat("HH:mm:ss.SSS");

    <b>public static void</b> main(String[] args) {
        SynchronizedObject object = <b>new</b> SynchronizedObject();
        object.setValue(1);
        Thread t = <b>new</b> Thread(<b>new</b> ProcessingThread(object));
        t.start();
        <b>try</b>{
            Thread.sleep(1000);
        }<b>catch</b>(InterruptedException ex){
            System.err.println("main::Interrupted: "+ex.getMessage());
        }
        log("main::Setting value");
        object.setValue(2);
        log("main::Value set");
    }

    <b>static void</b> log(String msg){
        System.out.println(FORMAT.format(<b>new</b> Date())+": "+msg);
    }

    <b>static class</b> SynchronizedObject{

        <b>private int</b> value;

        <b>public synchronized void</b> setValue(<b>int</b> value){
            <b>this</b>.value = value;
        }

        <b>public synchronized void</b> process(){
            log("own:: value: "+value);
            <b>try</b>{
                log("own:: Sleeping");
                Thread.sleep(2000);
                log("own:: Waiting");
                wait(1000);
            }<b>catch</b>(InterruptedException ex){
                System.err.println("own:: Interrupted: "+ex.getMessage());
            }
            log("own:: value: "+value);
        }
    }

    <b>static class</b> ProcessingThread <b>implements</b> Runnable{

        <b>private</b> SynchronizedObject object;

        <b>public</b> ProcessingThread(SynchronizedObject object){
            <b>this</b>.object = object;
        }

        <b>public void</b> run() {
            object.process();
        }
    }
}</pre>

<p>Итак, у нас два потока: основной, и тот, в котором вызывается синхронизированный метод <code>process</code>. Мы запускаем
его, он засыпает на две секунды, а мы тем временем пытаемся вызвать синхронизированный метод <code>setValue</code>. Дальше
второй поток уходит в состояние ожидания на секунду и продолжает работу. Посмотрим на результат:</p>

<pre>14:43:55.763: <span class="blue">own</span>:: value: 1
14:43:55.763: <span class="blue">own</span>:: Sleeping
14:43:56.762: <span class="green">main</span>::Setting value
14:43:57.761: <span class="blue">own</span>:: Waiting
14:43:57.761: <span class="green">main</span>::Value set
14:43:58.760: <span class="blue">own</span>:: value: 2</pre>

<p>В начале исполнения синхронизированного метода значение <code>value = 1</code>. Далее этот поток засыпает, в 14:43:55, на
2 секунды. В 14:43:56 основной поток пытается установить новое значение, но у него ничего не выходит – монитор объекта
захвачен другим потоком. Остается только ждать... до 14:43:57, когда второй поток просыпается и уходит в состояние ожидания.
Как только это происходит, монитор отпущен и новое значение установлено. Вы можете видеть по засечкам времени, что между
уходом второго потока в состояние ожидания и установкой основным потоком нового значения прошло менее одной миллисекунды.
</p>

<p>Таким образом, в начале синхронизированного метода значение поля было 1, а в конце – 2. Причем менялось это значение с
помощью другого синхронизированного метода из другого потока. Забавно, правда? На самом деле, это зависит от того, по какую
сторону баррикад находишься. Если приходится искать ошибку, связаную с такой синхронизацией... Приятного мало. Но у вас есть
большое преимущество – теперь вы знаете, что такое тоже возможно.</p>

<p>Еще пара слов по поводу вызова метода <code>wait</code>. Это уже из разряда чистой техники. Рекомендуется вызывать <code>
wait</code> изнутри цикла <code>while</code>. Т.е., писать не </p>

<pre><b>if</b> (some condition){
    obj.wait()
}</pre>

<p>..., а </p>

<pre><b>while</b> (some condition){
    obj.wait()
}</pre>

<p>Зачем это надо. Дело в том, что <code>notify</code> может вызвать кто угодно. Просто по ошибке, от которой никто не
застрахован. В том случае из моего опыта, о котором я <a href="#selfExp1">рассказывал выше</a>, мы взялись за переделку
именно для того, чтобы избежать такой возможности. Просто спрятали объект, на котором происходит синхронизация. И доступ к
нему имел только наш код. Это хорошая практика, но не всегда возможно, к сожалению. Так вот, если поток ждет выполнения
некоторого условия – вариант с <code>while</code> надежнее. Если поток пустили по ошибке – он опять проверит условие и, если
надо, будет ждать дальше.</p>

<p>Кроме того, не исключена возможность и простого выхода из ожидания <strong>без</strong> вызова notify. Я честно
    признаюсь, что не видел этого в спецификации виртуальной машины, хотя специально искал. Но некоторые «гуру»
    утверждают, что VM может выйти из состояния ожидания самопроизвольно. И более того, периодически это наблюдается.
    Если кто-нибудь даст ссылку на соответствующую спецификацию – буду благодарен!
</p>

<p>Уф! Похоже, с <code>wait/notify</code> мы покончили. Следующий вариант синхронизации – </p>

<h4 id="join">Системная синхронизация с использованием <code>join</code></h4>

<p>Тут все намного проще. Метод <code>join</code>, вызванный у экземпляра класса <code>Thread</code>, позволяет текущему
потоку остановиться до того момента, как поток, связаный с этим экземпляром, закончит работу. Это удобно во многих случаях.
Например, запустили мы чтение данных в отдельном потоке и занялись подготовкой инфраструктуры для их обработки. Закончили
подготовку – а данные еще не готовы. Вот тогда можно подождать окончания потока, в котором они читаются. Подводных камней я
тут не вижу, честно сказать.
</p>

<p class="off">Кстати, с этим методом связан очень любопытный прием. К сожалению, напрочь не помню авторства, я его видел
в форуме juga.ru. Если автор мне напишет – обязательно напишу, что это его творение.</p>

<p class="off">Так вот, при работе с сетевыми соединениями не всегда можно указать таймаут. В частности, при использовании
<code>java.net.URL</code>. С версии 1.5 у <code>java.net.URLConnection</code> уже появились методы <code>setConnectTimeout
</code> и <code>setReadTimeout</code>, но до нее такого способа не было. И, соответственно, бывали случаи, когда вызов
<code>connect</code> у <code>URLConnection</code> блокировал поток всерьез и надолго.</p>

<p class="off">Предложеное решение оказалось весьма оригинальным.</p>

<pre class="off">URL url = <b>new</b> URL(...)
<b>final</b> URLConnection connection = url.openConnection();
// connection initialization
<b>long</b> timeout = 5000;
Thread t = <b>new</b> Thread(<b>new</b> Runnable(){
    <b>public void</b> run(){
        connection.connect();
    }
});
t.start();
t.join(timeout);</pre>

<p class="off">Т.е. соединение осуществляется в отдельном потоке, а текущий поток ждет его окончания в течение 5 секунд. Если
соединение не произошло – текущий поток во всяком случае не блокируется.</p>

<p>С системной синхронизацией вроде разобрались. Поговорим теперь о программной.</p>

<h4 id="program_sync">Программная синхронизация – шаблоны и библиотеки</h4>

<p>Так получилось, что практически вся программная синхронизация неразрывно связана с одним единственным именем – <em>Doug
Lea</em> (<em>Дуг Ли</em>). В 1999 году вышла его книга <em>Concurrent Programming in Java™: Design Principles and
Pattern</em>, в которой собрано множество различных шаблонов программной синхронизации. Более того, у него на сайте
(<a target="_blank" href="http://g.oswego.edu/">http://g.oswego.edu/</a>) есть полная реализация этих шаблонов – библиотека
<em>util.concurrent</em> (<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html" target="blank">http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html</a>). Эта реализация оказалась
настолько удачной, что с версии Java 1.5 она включена в ядро в виде пакетов <code>java.util.concurrent</code>, <code>
java.util.concurrent.atomic</code> и <code>java.util.concurrent.locks</code>. Пожалуй, я не буду подробно останавливаться
на этих пакетах. Для того, чтобы их использовать, достаточно почитать документацию. Ее у Sun немало. Вот, например, хорошая
статья: <a href="http://java.sun.com/developer/technicalArticles/J2SE/concurrency/" target="_blank">
http://java.sun.com/developer/technicalArticles/J2SE/concurrency/</a>. Вот еще: <a target="_blank" href="http://java.sun.com/developer/JDCTechTips/2005/tt0816.html#2">
http://java.sun.com/developer/JDCTechTips/2005/tt0816.html#2</a>.</p>

<p>Программная синхронизация хороша тем, что она гораздо более гибкая. Можно реализовать блокирующие очереди, барьеры, замки,
семафоры и много другого. Все это уже есть в Java 1.5. Остается только изучить API.</p>

<p>Пожалуй, с теорией можно закончить. Обратимся теперь к практике.</p>

<h3 id="practical_sync">Синхронизация на практике</h3>

<p>Рассмотрим применение синхронизации в Java SE и Java EE.</p>

<h4 id="collections_sync">Синхронизация коллекций</h4>

<p>Начнем мы, пожалуй, с коллекций. С классов <code>java.util.Vector</code> и <code>java.util.ArrayList</code>. Оба они
хранят данные в массивах. Оба они реализуют интерфейс <code>java.util.List</code>. Различия между ними минимальны. Вопрос.
Зачем их два?</p>

<p>Ответы я слышал самые разнообразные. От того, что <code>Vector</code> оставлен для совместимости (он был с версии 1.0,
а <code>ArrayList</code> появился в 1.2), до того, что у них разные алгоритмы работы и <code>ArrayList</code> существенно
быстрее (что с версии 1.3.1 не соответствует действительности – по производительности они уже сравнимы).</p>

<p>На самом же деле различие между ними вплотную касается обсуждаемой темы. Дело в том, что <code>Vector</code>
синхронизирован, а <code>ArrayList</code> – нет. Практически все методы класса <code>Vector</code> объявлены как
<code>synchronized</code>, за исключением разве что <code>iterator()</code>. Однако, возвращаемый итератор опирается на
те же синхронизированные методы вектора. Т.е. можно сказать, что класс <code>Vector</code> – thread-safe.</p>

<p>В случае с <code>ArrayList</code> применен кардинально другой подход. Для него поддерживается счетчик обновлений. Если
в каком-нибудь критичном к обновлениям методе (вроде <code>next</code> итератора) ожидаемое значение счетчика не совпадает
с реальным – инициируется исключение <code>java.util.ConcurrentModificationException</code>.</p>

<p>Что дают эти два подхода. Как мы видели выше, синхронизация способна приостановить поток, пока не будет отпущен монитор.
В ситуации, когда данные изменяются нечасто, синхронизация их чтения может дать падение производительности. В этом случае
лучше использовать <code>ArrayList</code>. Т.е., скажем, два потока могут одновременно пройтись по одному и тому же <code>
ArrayList</code>-у, в то время как по <code>Vector</code>-у – нет. Потому – использовать <code>Vector</code> стоит лишь там,
где синхронизация действительно необходима. Он способен решить многие проблемы, но добавить может не меньше.</p>

<p>Точно такая же разница и между ассоциативными коллекциями – <code>java.util.Hashtable</code> и <code>
java.util.HashMap</code>. <code>Hashtable</code> синхронизирован (thread-safe), <code>HashMap</code> – нет. Преимущества и
недостатки абсолютно те же.</p>

<p>Ну ладно, у <code>ArrayList</code> есть синхронизированный аналог, у <code>HashMap</code> тоже. А как быть с остальными?
Есть еще, например, <code>java.util.LinkedList</code>. Есть <code>java.util.LinkedHashMap</code> и <code>
java.util.TreeMap</code>. Есть, наконец, целый класс множеств, унаследованных от <code>java.util.Set</code> –
<code>java.util.HashSet</code>, <code>java.util.TreeSet</code>, <code>java.util.LinkedHashSet</code>. Как быть с ними, если
очень хочется? Писать самостоятельно?</p>

<p>К счастью, этого не требуется. Ввиду наличия присутствия такого класса как <code>java.util.Collections</code>. Класс этот
сервисный. Он содержит множество статических методов, из которых нам интересно шесть:</p>

<pre>static java.util.Collection synchronizedCollection(Collection)
static java.util.List       synchronizedList(List)
static java.util.Map        synchronizedMap(Map)
static java.util.Set        synchronizedSet(Set)
static java.util.SortedMap  synchronizedSortedMap(SortedMap)
static java.util.SortedSet  synchronizedSortedSet(SortedSet)</pre>

<p>Каждый из этих методов возвращает синхронизированную оболочку над переданным параметром. Единственное "но": <b>
возвращаемые оболочками итераторы не синхронизированы</b>! Их надо синхронизировать вручную. Как – подробно описано в API, в
описании самих методов.
</p>

<p>Те же из вас, кто используют версию 1.5, имеют в своем распоряжении несколько классов, появившихся вместе с пакетом
<code>java.util.concurrent</code> – <code>ConcurrentHashMap</code>, <code>ConcurrentLinkedQueue</code>, <code>
CopyOnWriteArrayList</code> и <code>CopyOnWriteArraySet</code>. Все эти классы являются синхронизированными. А в версии
1.6 к ним прибавилось еще несколько (вот тут можно найти описание: <a href="http://java.sun.com/javase/6/docs/technotes/guides/collections/changes6.html" target="_blank">http://java.sun.com/javase/6/docs/technotes/guides/collections/changes6.html</a>).</p>

<h4 id="gui_sync">Синхронизация GUI</h4>

<p>Теперь обсудим синхронизацию GUI. Здесь тоже есть о чем поговорить.</p>

<p>Прежде всего, существует отдельный поток, обслуживающий GUI, с именем <em>AWT-EventQueue</em>. Этот поток отвечает,
во-первых, за отрисовку всех компонентов, во-вторых, за реакцию на все события – нажатия клавиш на клавиатуре, движение мыши,
ввод текста, нажатие кнопок, – в общем, за всю интерактивную часть. С другой стороны, некоторые действия, потенциально
затрагивающие GUI, могут производиться и в других потоках. Классический пример – отображения статуса длительной операции,
progress bar. Вопрос, собственно, заключается в следующем – как обеспечить корректное взаимодействие между такими потоками
и компонентами пользовательского интерфейса, которыми заведует другой поток – <em>AWT-EventQueue</em>.</p>

<p>В документации по этому поводу говорится следующее. Компоненты UI, как Swing, так и AWT, должны рассматриваться как
<b>не</b>-thread-safe. Иначе говоря, вызов всех их методов должен производится в GUI-потоке. Исключение составляет <code>
repaint()</code>, который можно вызывать из любого потока. Создавать компоненты можно тоже в любом потоке. И даже вызывать
их методы, если компоненты не видны. Но с того момента, как в первый раз компонент был показан на экране – работать с ним
можно только в GUI-потоке.</p>

<p class="off">Нет, можно, конечно, и в любом другом. Я видел кучу приложений, написаных именно так. Но мы сейчас говорим
о том, как это делать ПРАВИЛЬНО. В противном случае корректную работу UI гарантировать никто не может.</p>

<p>Итак, работать только в GUI-потоке. Легко сказать! Нет, конечно, подавляющее большинство действий в визуальном приложении
происходит именно после действий пользователя, которые обрабатываются именно в GUI-потоке. Но запустить в нем по нажатию
кнопки длительный рассчетный процесс, загрузку файла по сети или что-нибудь еще – значит, похоронить приложение. Потому
как до того момента, как управление выйдет из обработчика события, GUI-поток не сможет делать ничего другого, вплоть до
отрисовки интерфейса. Следовательно, длительные процессы просто НЕОБХОДИМО запускать в другом потоке. Как быть?</p>

<p>Как обычно, "все уже украдено до нас"! В смысле, об этом тоже позаботились разработчики Sun. Существует такой класс как
<code>javax.swing.SwingUtilities</code>. Помимо всего прочего он содержит два интересующих нас статических метода –
<code>invokeAndWait(Runnable)</code> и <code>invokeLater(Runnable)</code>. Оба они выполняют метод <code>run</code>
переданного им <code>Runnable</code> в GUI-потоке. Разница в том, что первый из них синхронный – т.е. вызывающий его поток
ждет завершения выполнения метода <code>run</code>, – а второй асинхронный – т.е. этот метод <code>run</code> выполнится
гарантированно, но тогда, когда это будет удобно виртуальной машине. Последнее звучит страшнее, чем есть на самом деле – я
не замечал задержек в выполнении. Так что "когда будет удобно" на практике не превышает долей секунды. И при прочих равных
стоит использовать именно метод <code>invokeLater</code>.</p>

<p>Кроме этих двух методов класс <code>SwingUtilities</code> содержит полезный метод – <code>isEventDispatchThread</code>, –
позволяющий определить, в каком потоке выполняется текущий код – в GUI или нет. Соответственно, если это GUI-поток, то в
использовании методов <code>invokeAndWait(Runnable)</code> и <code>invokeLater(Runnable)</code> нет необходимости.</p>

<p>Таким образом, правильный вызов методов компонента выглядит где-то так (для примера – установим текст какому-либо полю):
</p>

<pre><b>package</b> ru.skipy.juga_ru.tests.threads;

<b>import</b> javax.swing.*;

<b>public class</b> FileEditor <b>extends</b> JFrame{

    <b>private</b> JTextArea dataField;
    <b>private</b> String fileName;

    <b>public</b> FileEditor(String fileName){
        <b>super</b>();
        <b>this</b>.fileName = fileName;
        dataField = <b>new</b> JTextArea(40,20);

        // ... some other initialisation

        Thread dataLoader = <b>new</b> Thread(<b>new</b> FileLoader());
        dataLoader.start();
    }

    <b>private class</b> FileLoader <b>implements</b> Runnable{

        <b>public void</b> run(){
            <b>final</b> StringBuffer content = <b>new</b> StringBuffer();

            //... loading file data here into buffer

            <b>if</b> (SwingUtilities.isEventDispatchThread()){
                dataField.setText(content.toString());
            }<b>else</b>{
                SwingUtilities.invokeLater(<b>new</b> Runnable(){
                    <b>public void</b> run(){
                        dataField.setText(content.toString());
                    }
                });
            }
        }
    }
}</pre>

<p>Это пример гипотетического редактора файла, вернее, его фрагмент. В конструкторе мы запускаем поток, который загрузит
содержимое этого файла. После окончания загрузки содержимое устанавливается в качестве текста компоненты, причем с гарантией
выполнения этого действия в GUI-потоке. Замечу, что проверка <code>if (SwingUtilities.isEventDispatchThread())</code> в
данном случае всегда даст <code>false</code>, т.к. код всегда будет выполняться в одном, не-GUI, потоке. Однако, если есть
вероятность выполнения кода как в GUI-, так и в обычном потоке, – стоит применять этот прием.</p>

<p>Еще один момент. Если вы посмотрите на класс <code>java.awt.EventQueue</code>, то найдете там те же самые три метода. С
той только разницей, что <code>isEventDispatchThread</code> там называется <code>isDispatchThread</code>. На самом деле,
методы класса <code>SwingUtilities</code> просто являются оболочками для этих. И какие использовать – дело вкуса. Один
лишний вызов в стеке.</p>

<p>И последний вопрос, которого я бы хотел коснуться –</p>

<h4 id="servlets_sync">Синхронизация сервлетов</h4>

<p>Изначально в Java EE API существовал такой интерфейс как <code>javax.servlet.SingleThreadModel</code>. Реализация
сервлетом этого интерфейса гарантировала, что на одном экземпляре сервлета метод <code>service</code> исполняется только в
одном потоке. Это достигалось либо использованием единственного экземпляра сервлета (что влияло на производительность), либо
использованием пула сервлетов (что вело к большему потреблению ресурсов).
</p>

<p>В какой-то момент в Sun сочли такой подход неудачным. В самом деле, гораздо эффективнее отдать синхронизацию разработчику.
Он во всяком случае знает, какие блоки действительно нужно синхронизировать вместо синхронизации всего метода <code>
service</code>, который может работать очень и очень долго. Соответственно, в версии Java Servlet API 2.4 этот интерфейс был
объявлен как <code>deprecated</code>, без какой-либо замены ему.</p>

<p>Это приводит нас к следующему выводу. При проектировании сервлетов нужно уделить особое внимание тому, чтобы сервлет был
thread-safe. Не использовать переменные экземпляра, например. Либо синхронизировать к ним доступ. В общем, рассчитывайте
на то, что методы сервлета <em>будут</em> вызываться из разных потоков.</p>

<p class="delim">* * *</p>

<p>Итак, мы дошли до финиша. Ура! Это действительно очень важная тема, вызывающая много вопросов и проблем. Надеюсь, теперь
их станет меньше. Всем спасибо!</p>

<hr style="margin-right:10pt">
<p class="footnote" id="ref1">1. Хочу напомнить, что класс <code>java.text.SimpleDateFormat</code> не является потоконезависимым.
При использовании одного экземпляра в нескольких потоках возможны нарушения внутреннего состояния, вследствие чего
результат форматирования будет непредсказуемым. В примерах я использую этот класс именно так, но только по той причине,
что это всего лишь примеры. Правильность форматирования тут некритична. В реальных приложениях необходимо либо создавать
экземпляр этого класса непосредственно в том месте, где он будет применяться, либо использовать класс <code>
java.lang.ThreadLocal</code>, реализуя его метод <code>initialValue</code> для создания нужного экземпляра <code>
java.text.SimpleDateFormat</code>. Спасибо читателю <b>Даниле Галимову</b> за напоминание!
</p>

<p class="footnote" id="answer1">Ответ №1. Вопрос на засыпку – в каком потоке вызывается конструктор <code>
WaitingThread</code>? ТОЛЬКО в основном, в методе <code>main</code>. Соответственно, о доступе из разных потоков к
статическому полю <code>nextId</code> говорить не приходится. Следовательно, <b>синхронизация не нужна</b>!</p>

<p class="footnote" id="answer2">Ответ №2. Аналогом синхронизации нестатического метода является блок <code>
synchronized(this)</code>. В нашем же случае синхронизация производится не на объекте <code>this</code>, а на объекте
<code>sync</code>. Следовательно, <b>заменить блок синхронизации на синхронизацию метода в данном случае нельзя</b>!</p>
    <br><p class="top_link"><a href="#top">В начало</a></p></div></td></tr><tr><td><div id="copyright">
                    Copyright © 2004-2013 Евгений Матюшкин aka Skipy
                    (e-mail: skiрy<img src="skipy.ru:%20%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%B2_files/at_sm.gif" alt="@">skipy.ru)<br><a href="http://www.skipy.ru/about_copying.html">Копирование и воспроизведение материалов</a> этого сайта возможно
                    только с согласия автора!
                </div></td></tr></tbody></table></body></html>