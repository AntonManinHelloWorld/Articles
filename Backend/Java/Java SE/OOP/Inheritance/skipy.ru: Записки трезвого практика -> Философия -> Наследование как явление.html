<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/main.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/header.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/print.css" media="print"><link rel="icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="shortcut icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="alternate" type="application/rss+xml" title="Новости сайта skipy.ru" href="http://www.skipy.ru/rss2.xml"><title>skipy.ru: Записки трезвого практика -&gt;
                Философия -&gt;
                Наследование как явление</title></head><body><script type="text/javascript">
            new Image().src = "//counter.yadro.ru/hit?r"+
            escape(document.referrer)+((typeof(screen)=="undefined")?"":
            ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
            ";"+Math.random();</script><div id="counter"><a href="http://www.liveinternet.ru/click" target="_blank"><img class="pcfykmqlcrtplekulgcu" src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/logo.gif" title="LiveInternet" alt="" height="31" width="31" border="0"></a></div><table class="formatting" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div id="header"><table class="head" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/head_left.jpg" alt="Заголовок страницы"></td><td align="right"><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/head_right.jpg" alt="Заголовок страницы"></td></tr></tbody></table><div id="headDelim"><span></span></div><div id="rootlink"><a href="http://www.skipy.ru/index.html" style="border: none;"><img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/dot.gif" alt="" height="130" width="120"></a></div><div id="menu"><table bgcolor="#264A84"><tbody><tr><td><a href="http://www.skipy.ru/index.html">Главная</a></td><td class="current"><a href="http://www.skipy.ru/philosophy.html">Философия</a></td><td><a href="http://www.skipy.ru/technics.html">Техника</a></td><td><a href="http://www.skipy.ru/architecture.html">Архитектура</a></td><td><a href="http://www.skipy.ru/useful.html">Полезное</a></td></tr></tbody></table></div><div id="submenu"><table bgcolor="#F49B2E"><tbody><tr><td class="current"><a href="http://www.skipy.ru/philosophy.html#lang">... языка</a></td><td><a href="http://www.skipy.ru/philosophy.html#development">... разработки</a></td><td><a href="http://www.skipy.ru/philosophy.html#developer">... разработчика</a></td></tr></tbody></table></div></div></td></tr><tr><td><div id="content"><br>
    <p class="lastChange">Последнее изменение: 1 сентября 2007г.</p>

<h2 id="top">Наследование как явление</h2>

<p>Сказать по правде, изначально я этой статьи не планировал. Я считал вопросы, которые хочу тут обсудить, тривиальными,
не стоящими даже упоминания. Однако в процессе написания статей для этого сайта я поднял в одном из форумов обсуждение
множественного наследования. В результате чего выяснилось, что больш<b>а</b>я часть разработчиков имеет весьма смутное
представление о наследовании. И, соответственно, допускает очень много ошибок. Поскольку наследование является одной из
важнейших черт ООП (если не самой важной!) – я решил посвятить этому явлению отдельную статью.</p>

<p style="text-align:center">* * *</p>

<p>Сначала я хочу разграничить два понятия – <em>объект</em> и <em>класс</em>. Эти понятия постоянно путают. Между
тем, они являются центральными в ООП. И знать различия между ними, на мой взгляд, необходимо.</p>

<p>Итак, объект. По сути, это что угодно. Вот кубик лежит. Деревянный, синий. Длина ребра 5 см. Это объект. А вон пирамидка.
Пластмассовая, красная. 10 см ребро. Это тоже объект. Что между ними общего? Разные размеры. Разная форма. Разный материал.
</p>

<p>Однако, общее у них есть. Прежде всего, и кубик, и пирамидка – правильные многогранники. Т.е. сумма количества вершин и
количества граней на 2 больше количества ребер. Далее. У обоих фигур есть грани, ребра и вершины. У обоих фигур есть такая
характеристика, как размер ребра. Обе фигуры можно вращать. Обе фигуры можно рисовать. Два последних свойства – это уже
поведение. Ну и так далее.</p>

<p>Практика программирования показывает, что с однородными объектами оперировать существенно проще, нежели с разнородными.
А поскольку между этими фигурами все-таки есть что-то общее, то возникает желание это общее как-то выделить. Вот тут и
выплывает такое понятие как <em>класс</em>.</p>

<p>Итак, определение.</p>

<p class="important">Класс – это описатель общих свойств группы объектов. Этими свойствами могут быть как характеристики
объектов (размер, вес, цвет и т.п.), так и поведения, роли и т.п.</p>

<p>Замечание. Слово "всех" (описатель <em>всех</em> свойств) произнесено не было. Что означает, что любой объект может
принадлежать к нескольким разным классам.</p>

<img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/figures_hierarchy.gif" class="left" alt="Иерархия фигур" hspace="5" align="left">

<p>Возьмем за основу тот же пример с геометрическими фигурами. Самое общее описание – <em>правильный многогранник</em>.
Безотносительно размера ребра, количества граней и вершин. Единственное, что мы знаем – что у этой фигуры есть вершины,
ребра и грани, и что длины ребер равны.</p>

<p>Дальше. Мы можем конкретизировать описание. Допустим, мы хотим нарисовать этот многогранник. Введем такое понятие как
<em>отрисовываемый правильный многогранник</em>. Что нам нужно для рисования? Описание общего способа отрисовки, не
зависящего от конкретных координат вершин. Возможно, цвет объекта.</p>

<p>Теперь введем классы <em>Куб</em> и <em>Тетраэдр</em>. Объекты, принадлежащие к этим классам, безусловно являются
правильными многогранниками. Единственное отличие – числа вершин, ребер и граней уже жестко фиксированы для каждого из
новых классов. Далее, зная вид конкретной фигуры, мы можем дать описание способа отрисовки. А значит, любой объект
классов <em>Куб</em> или <em>Тетраэдр</em> также является и объектом класса <em>отрисовываемый правильный многогранник</em>.
Налицо иерархия классов.</p>

<p>В этой иерархии мы спускаемся от самого общего описания к наиболее конкретизированному. Заметьте, что объект любого
класса также подходит под описание любого более общего класса по иерархии. Такое отношение классов и называется
<em>наследованием</em>. Каждый дочерний класс наследует все свойства родительского, более общего, и (возможно) добавляет
к этим свойствам какие-то свои. Либо переопределяет какие-то свойства родительского класса.</p>

<p>Здесь я хочу привести цитату из классической уже книги<sup><a href="#inh_def">1</a></sup> Гради Буча по
объектно-ориентированному дизайну:</p>

<p class="important">Inheritance, therefore, defines an "is a" hierarchy among classes, in which subclass inherits from one
or more superclasses. This is in fact the litmus test for inheritance. Given classes A and B, if A "is not a" kind of B,
then A shouldn't be a subclass of B.</p>

<p>В переводе это звучит так:</p>

<p class="important">Наследование, таким образом, определяет иерархию "является" между классами, в которой подкласс
наследует от одного или более суперклассов. Это, фактически, определяющий тест (дословно – лакмусовый тест, прим. моё) для
наследования. Если у нас есть классы А и В и если класс А <em>"не является"</em> разновидностью класса В, то А <em>не должен
быть</em> подклассом В.</p>

<p>Дочитавшие до этого места, возможно, недоуменно покрутят пальцем у виска. Первая мысль – это же тривиально! Так и есть.
Но если бы вы знали, сколько безумных иерархий наследования я видел! В той дискуссии, о которой я упомянул в самом
начале, один из участников совершенно серьезно унаследовал танк от... пулемета!!! На том простом основании, что у танка
ЕСТЬ пулемет. И это – самая распространенная ошибка. Наследование путают с агрегированием – включением одного объекта
в состав другого. Танк не является пулеметом, он его содержит. И из-за этой ошибки чаще всего и возникает желание
воспользоваться множественным наследованием.</p>

<p>Перейдем теперь непосредственно к Java. Что тут есть в плане наследования? В языке есть два типа классов – способные
содержать реализацию, и неспособные на это. Вторые называются интерфейсами, хотя по сути – это полностью абстрактные классы.
</p>

<img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/mul_inh.gif" alt="Множественное наследование" hspace="5" align="left">

<p>Так вот, язык позволяет унаследовать класс от другого класса, потенциально содержащего реализацию. НО ТОЛЬКО ОТ ОДНОГО!
Поясню, зачем это сделано. Дело в том, что каждая реализация может иметь дело только со своей частью – с теми переменными
и методами, о которых она знает. И если даже мы унаследуем класс С от А и В, то метод <em>processA</em>, унаследованный из
класса А, может работать только с внутренней переменной <em>а</em>, ибо о <em>b</em> он ничего не знает, равно как ничего
он не знает и о <em>c</em>, и о методе <em>processC</em>. Точно так же и метод <em>processB</em> может работать только с
переменной <em>b</em>. Т.е., по сути, унаследованные части оказываются изолированными. Класс С, безусловно, может с ними
работать, но точно так же он может работать с этими частями, если они будут просто включены в его состав, а не унаследованы.
</p>

<p>Однако тут есть еще одна неприятность, заключающаяся в перекрытии имен. Если бы методы <em>processA</em> и <em>processB
</em> назывались одинаково, допустим, <em>process</em>, то какой эффект дало бы обращение к методу <em>process</em> класса
С? Какой из двух методов был бы вызван? Разумеется, в С++ есть средства управления в этой ситуации, однако стройности языку
это не добавляет.</p>

<p>Итак, преимуществ наследование реализации не дает, а недостатки есть. По этой причине это наследования реализации в Java
отказались. Однако, разработчикам оставили такой вариант множественного наследования, как наследование от интерфейса. В
терминах Java – реализация интерфейса.</p>

<p>Что представляет собой интерфейс? Набор методов. (Определение в интерфейсах констант мы сейчас не рассматриваем,
подробнее об этом <a href="http://www.skipy.ru/philosophy/constantsUsage.html">тут</a>.) А что есть метод? А метод, по своей сути, определяет <em>поведение
</em> объекта. Не случайно в названии практически каждого метода содержится действие – <em>getXXX</em>, <em>drawXXX</em>,
<em>countXXX</em>, и т.д. А поскольку интерфейс – это совокупность методов, то <em>интерфейс представляет собой</em>,
фактически, <em>определитель <b>поведения</b></em>. </p>

<p>Другой вариант применения интерфейса – определитель роли объекта. <em>Наблюдатель</em>, <em>Слушатель</em> и т.п. В
этом случае метод фактически является воплощением реакции на какое-то внешнее событие. Т.е., опять-таки, поведением.</p>

<p>Объект, безусловно, может иметь несколько различных поведений. Если ему нужно отрисоваться – он отрисовывается.
Если ему нужно сохраниться – он сохраняется. Ну и т.д. Соответственно, возможность наследования от классов, определяющих
поведение – весьма и весьма полезна. Точно так же объект может иметь несколько различных ролей. Однако <em>реализация</em>
поведения – целиком и полностью на совести дочернего класса. Наследование от интерфейса (его реализация) говорит, что объект
этого класса должен уметь делать то-то и то-то. А КАК он это делает – каждый реализующий интерфейс класс определяет
самостоятельно.</p>

<p>Вернемся к ошибкам при наследовании. Мой опыт разработки различных систем показывает, что имея наследование от
интерфейсов, можно реализовать любую систему, при этом не используя множественного наследования реализации. И потому, когда
я встречаюсь с сетованиями на отсутствие множественного наследования в том виде, в котором оно есть в С++, для меня это
верный признак неправильного дизайна.</p>

<p>Чаще всего совершается ошибка, о которой я уже упоминал – наследование путается с агрегированием. Иногда это происходит
из-за неверных предпосылок. Т.е. берется, например, спидометр, утверждается, что измерить скорость можно только измерив
расстояние и время, после чего спидометр благополучно наследуется от линейки и часов, становясь, таким образом, линейкой
и часами, согласно определению наследования. (На мои просьбы измерить спидометром время обычно отвечали шутками. Или
вообще не отвечали.) А в чем тут ошибка? В предпосылке. Дело в том, что спидометр не измеряет времени. И расстояния, кстати,
тоже. Одометр, который есть в любом спидометре – это классический пример второго прибора в том же корпусе, т.е.
агрегирования. Для измерения скорости он не нужен. Его можно вообще убрать – на измерение скорости никак это не повлияет.
</p>

<p>Иногда такие ошибки совершают осознанно. Это гораздо хуже. "Да, я знаю, что так неправильно, но мне так удобнее". Во что
это может обернуться? А вот во что: унаследуем танк от пушки и пулемета. Удобнее так. В результате танк становится пушкой
и пулеметом. Дальше мы оборудуем самолет двумя пулеметами и пушкой. Что получаем? Самолет с подвесным вооружением в виде
трех танков! Потому что ОБЯЗАТЕЛЬНО найдется человек, который, не разобравшись, использует танк в качестве пулемета.
Исключительно согласно иерархии наследования. И будет абсолютно прав, потому что ошибку сделал тот, кто такую иерархию
спроектировал.</p>

<p class="off">Вообще, я не очень понимаю подход "<b>мне</b> так удобнее". Удобние писать как слышыца, а те, кто гаварит пра
граматнасть – казлы. Я утрирую, конечно, но основная мысль остается – кроме сиюминутного удобства есть такое понятие как
грамотность. Это понятие определено на основании очень большого опыта очень большого количества людей. Фактически, это то,
что в английском называется "best practice" – наилучшее решение. И чаще всего решения, которые кажутся более простыми,
приносят в дальнейшем немало проблем.</p>

<p>Пример этот, конечно, сильно утрирован и потому абсурден. Однако встречаются не столь явные случаи, приводящие тем не
менее к катастрофическим последствиям. Унаследовавшись от объекта, вместо того, чтобы его агрегировать, разработчик
дает любому возможность использования функциональности родительского объекта напрямую. Со всеми вытекающими из этого
последствиями.</p>

<p>Представьте что у вас есть класс, работающий с базой данных, <code>DBManager</code>. Вы создаете еще один класс,
который будет работать уже с вашими данными, используя <code>DBManager</code>, – <code>DataManager</code>. Этот класс
будет осуществлять контроль данных, преобразования, дополнительные действия и т.п. В общем, прослойка между бизнес-уровнем
и уровнем базы. Если унаследовать <code>DataManager</code> от <code>DBManager</code>, то всякий, использующий его, получит
доступ к базе напрямую. И, следовательно, сможет выполнить любые действия в обход контроля, преобразований и пр. Ладно,
предположим, что умышленного вреда никто наносить не хочет и прямые действия будут грамотными. Но! Допустим, что база
изменилась. В смысле, изменились какие-то принципы контроля или преобразований. <code>DataManager</code> изменили. Но
тот код, который раньше работал с базой напрямую – так и будет работать. Про него с большой вероятностью не вспомнят.
В результате появится ошибка такого класса, что те, кто ее будут искать, поседеют. Никому ведь в голову не придет, что с
базой работают в обход <code>DataManager</code>. Кстати, пример из реальной жизни. Ошибку искали ОЧЕНЬ долго.</p>

<p>Напоследок повторю еще раз. <b>Наследование необходимо применять ТОЛЬКО при наличии отношения <em>"является"</em></b>.
Потому как в этом заключается сама суть наследования – возможность использовать объекты дочернего класса как объекты
базового. Если же отношения <em>"является"</em> между классами нет – наследования быть НЕ ДОЛЖНО!!! Никогда и ни при
каких обстоятельствах. И тем более – только потому что так удобно.</p>

<hr style="margin-right:10pt">
<p class="footnote">
<span id="inh_def"><sup>1.</sup> Grady Booch, Object-Oriented Analysis and Design with Applications. Second edition.
ISBN 0-8053-5340-2, Page 112.</span>
</p>

<br><p class="top_link"><a href="#top">В начало</a></p></div></td></tr><tr><td><div id="copyright">
                    Copyright © 2004-2013 Евгений Матюшкин aka Skipy
                    (e-mail: skiрy<img src="skipy.ru:%20%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D0%BA%D0%B8%20%D1%82%D1%80%D0%B5%D0%B7%D0%B2%D0%BE%D0%B3%D0%BE%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B0%20-%3E%20%D0%A4%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B8%D1%8F%20-%3E%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%B0%D0%BA%20%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_files/at_sm.gif" alt="@">skipy.ru)<br><a href="http://www.skipy.ru/about_copying.html">Копирование и воспроизведение материалов</a> этого сайта возможно
                    только с согласия автора!
                </div></td></tr></tbody></table></body></html>