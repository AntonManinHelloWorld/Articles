<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-type" content="text/html; charset=UTF-8"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/main.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/header.css"><link rel="stylesheet" type="text/css" href="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/print.css" media="print"><link rel="icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="shortcut icon" href="http://www.skipy.ru/favicon.ico" type="image/vnd.microsoft.icon"><link rel="alternate" type="application/rss+xml" title="Новости сайта skipy.ru" href="http://www.skipy.ru/rss2.xml"><title>skipy.ru: Записки трезвого практика -&gt;
                Техника -&gt;
                Сериализация как она есть</title></head><body><script type="text/javascript">
            new Image().src = "//counter.yadro.ru/hit?r"+
            escape(document.referrer)+((typeof(screen)=="undefined")?"":
            ";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
            screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
            ";"+Math.random();</script><div id="counter"><a href="http://www.liveinternet.ru/click" target="_blank"><img class="pcfykmqlcrtplekulgcu" src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/logo.gif" title="LiveInternet" alt="" height="31" width="31" border="0"></a></div><table class="formatting" border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div id="header"><table class="head" cellpadding="0" cellspacing="0"><tbody><tr><td><img src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/head_left.jpg" alt="Заголовок страницы"></td><td align="right"><img src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/head_right.jpg" alt="Заголовок страницы"></td></tr></tbody></table><div id="headDelim"><span></span></div><div id="rootlink"><a href="http://www.skipy.ru/index.html" style="border: none;"><img src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/dot.gif" alt="" height="130" width="120"></a></div><div id="menu"><table bgcolor="#264A84"><tbody><tr><td><a href="http://www.skipy.ru/index.html">Главная</a></td><td><a href="http://www.skipy.ru/philosophy.html">Философия</a></td><td class="current"><a href="http://www.skipy.ru/technics.html">Техника</a></td><td><a href="http://www.skipy.ru/architecture.html">Архитектура</a></td><td><a href="http://www.skipy.ru/useful.html">Полезное</a></td></tr></tbody></table></div><div id="submenu"><table bgcolor="#F49B2E"><tbody><tr><td><a href="http://www.skipy.ru/technics.html#general">Общее</a></td><td><a href="http://www.skipy.ru/technics.html#gui">GUI</a></td><td><a href="http://www.skipy.ru/technics.html#lang">java.lang</a></td><td class="current"><a href="http://www.skipy.ru/technics.html#io">java.io</a></td><td><a href="http://www.skipy.ru/technics.html#dyk">Знаете ли вы?..</a></td></tr></tbody></table></div></div></td></tr><tr><td><div id="content"><br>
        <p class="lastChange">Последнее изменение: 19 апреля 2011г.</p>

<h2 id="top">Сериализация как она есть</h2>

<p>На первый взгляд, сериализация кажется тривиальным процессом. Действительно, что может быть проще? Объявил класс
реализующим интерфейс <code>java.io.Serializable</code> – и все дела. Можно сериализовать класс без проблем.</p>

<p>Теоретически это действительно так. Практически же – есть очень много тонкостей. Они связаны с производительностью,
с десериализацией, с безопасностью класса. И еще с очень многими аспектами. О таких тонкостях и пойдет разговор.</p>

<p>Статью эту можно разделить на следующие части:</p>

<ul>
    <li> <a href="#features">Тонкости механизмов</a></li>
    <li> <a href="#why_needed_ext">Зачем нужен <code>Externalizable</code></a></li>
    <li> <a href="#performance">Производительность</a></li>
    <li> <a href="#back_side">Обратная сторона медали</a></li>
    <li> <a href="#security">Безопасность данных</a></li>
    <li> <a href="#singleton">Сериализация объектов Singleton</a></li>
</ul>

<p>Приступим к первой части – </p>

<h3 id="features">Тонкости механизмов</h3>

<p>Прежде всего, вопрос на засыпку. А сколько существует способов сделать объект сериализуемым? Практика показывает, что
более 90% разработчиков отвечают на этот вопрос приблизительно одинаково (с точностью до формулировки) – такой способ один.
Между тем, их <b>два</b>. Про второй вспоминают далеко не все, не говоря уж о том, чтобы сказать что-то внятное о его
особенностях.</p>

<p>Итак, каковы же эти способы? Про первый помнят все. Это уже упомянутая реализация <code>java.io.Serializable</code>, не
требующая никаких усилий. Второй способ – это тоже реализация интерфейса, но уже другого: <code>
java.io.Externalizable</code>. В отличие от <code>java.io.Serializable</code>, он содержит два метода, которые необходимо
реализовать – <code>writeExternal(ObjectOutput)</code> и <code>readExternal(ObjectInput)</code>. В этих методах как раз и
находится логика сериализации/десериализации.</p>

<p class="off">Замечание. В дальнейшем сериализацию с реализацией <code>Serializable</code> я буду иногда называть
стандартной, а реализацию <code>Externalizable</code> – расширенной.</p>

<p class="off">Еще одно замечание. Я намеренно не затрагиваю сейчас такие возможности управления стандартной сериализацией,
как определение <code>readObject</code> и <code>writeObject</code>, т.к. считаю эти способы в некоторой степени
некорректными. Эти методы не определены в интерфейсе <code>Serializable</code> и являются, фактически, подпорками для обхода
ограничений и придания стандартной сериализации гибкости. В <code>Externalizable</code> же методы, обеспечивающие гибкость,
заложены изначально.</p>

<p>Зададимся еще одним вопросом. А как, собственно, работает стандартная сериализация, с использованием
<code>java.io.Serializable</code>? А работает она через Reflection API. Т.е. класс разбирается как набор полей, каждое из
которых пишется в выходной поток. Думаю, понятно, что операция эта неоптимальна по производительности. Насколько именно –
выясним позднее.</p>

<p>Между упомянутыми двумя способами сериализации существует еще одно серьезное отличие. А именно – в механизме
десериализации. При использовании <code>Serializable</code> десериализация происходит так: под объект выделяется память,
после чего его поля заполняются значениями из потока. Конструктор объекта при этом <em>не вызывается</em>.</p>

<p id="non_ser_par">Тут надо еще отдельно рассмотреть такую ситуацию. Хорошо, наш класс сериализуемый. А его родитель?  Совершенно
необязательно! Более того, если наследовать класс от <code>Object</code> – родитель уж точно НЕсериализуемый.
И пусть о полях <code>Object</code> мы ничего не знаем, но в наших собственных родительских классах они вполне могут
быть. Что будет с ними? В поток сериализации они не попадут. Какие значения они примут при десериализации?</p>

<p>Посмотрим на этот пример:</p>

<pre><span class="keyword">package</span> ru.skipy.tests.io;

<span class="keyword">import</span> java.io.*;

<span class="comment">/**
 * ParentDeserializationTest
 *
 * @author Eugene Matyushkin aka Skipy
 * @since 05.08.2010
 */</span>
<span class="keyword">public</span> <span class="keyword">class</span> ParentDeserializationTest {

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args){
        <span class="keyword">try</span> {
            System.<span class="static_final">out</span>.println(<span class="string">"Creating..."</span>);
            Child c = <span class="keyword">new</span> Child(1);
            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();
            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);
            c.field = 10;
            System.<span class="static_final">out</span>.println(<span class="string">"Serializing..."</span>);
            oos.writeObject(c);
            oos.flush();
            baos.flush();
            oos.close();
            baos.close();
            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());
            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);
            System.<span class="static_final">out</span>.println(<span class="string">"Deserializing..."</span>);
            Child c1 = (Child)ois.readObject();
            System.<span class="static_final">out</span>.println(<span class="string">"c1.i="</span>+c1.getI());
            System.<span class="static_final">out</span>.println(<span class="string">"c1.field="</span>+c1.getField());
        } <span class="keyword">catch</span> (IOException ex){
            ex.printStackTrace();
        } <span class="keyword">catch</span> (ClassNotFoundException ex){
            ex.printStackTrace();
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Parent {
        <span class="keyword">protected</span> <span class="keyword">int</span> field;
        <span class="keyword">protected</span> Parent(){
            field = 5;
            System.<span class="static_final">out</span>.println(<span class="string">"Parent::Constructor"</span>);
        }
        <span class="keyword">public</span> <span class="keyword">int</span> getField() {
            <span class="keyword">return</span> field;
        }
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> Child <span class="keyword">extends</span> Parent <span class="keyword">implements</span> Serializable{
        <span class="keyword">protected</span> <span class="keyword">int</span> i;
        <span class="keyword">public</span> Child(<span class="keyword">int</span> i){
            <span class="keyword">this</span>.i = i;
            System.<span class="static_final">out</span>.println(<span class="string">"Child::Constructor"</span>);
        }
        <span class="keyword">public</span> <span class="keyword">int</span> getI() {
            <span class="keyword">return</span> i;
        }
    }
}</pre>

<p>Он прозрачен – у нас есть несериализуемый родительский класс и сериализуемый дочерний. И вот что получается:</p>

<pre>Creating...
Parent::Constructor
Child::Constructor
Serializing...
Deserializing...
<strong>Parent::Constructor</strong>
c1.i=1
c1.field=5</pre>

<p>То есть <strong>при десериализации вызывается конструктор без параметров родительского НЕсериализуемого класса</strong>.
И если такого конструктора не будет – при десериализации возникнет ошибка. Конструктор же дочернего объекта, того,
который мы десериализуем, не вызывается, как и было сказано выше.</p>

<p>Так ведут себя стандартные механизмы при использовании <code>Serializable</code>. При использовании
же <code>Externalizable</code> ситуация иная. Сначала <em>вызывается конструктор без параметров</em>, а потом уже на
созданном объекте вызывается метод <code>readExternal</code>, который и вычитывает, собственно, все свои данные. Потому – <b>
любой реализующий интерфейс <code>Externalizable</code> класс обязан иметь <code>public</code> конструктор без
параметров!</b> Более того, поскольку все наследники такого класса тоже будут считаться реализующими интерфейс <code>
Externalizable</code>, у них тоже должен быть конструктор без параметров!</p>

<p>Пойдем дальше. Существует такой модификатор поля как <code>transient</code>. Он означает, что это поле <em>не должно</em>
быть сериализовано. Однако, как вы сами понимаете, указание это действует только на стандартный механизм сериализации. При
использовании <code>Externalizable</code> никто не мешает сериализовать это поле, равно как и вычитать его. Если поле
объявлено <code>transient</code>, то при десериализации объекта оно принимает значение по умолчанию.</p>

<p>Еще один достаточно тонкий момент. При стандартной сериализации поля, имеющие модификатор <code>static</code>, <em>не
сериализуются</em>. Соответственно, после десериализации это поле значения не меняет. Разумеется, при реализации <code>
Externalizable</code> сериализовать и десериализовать это поле никто не мешает, однако я крайне не рекомендую этого
делать, т.к. это может привести к трудноуловимым ошибкам.</p>

<p>Поля с модификатором <code>final</code> сериализуются как и обычные. За одним исключением – их невозможно десериализовать
при использовании <code>Externalizable</code>. Ибо <code>final</code>-поля должны быть инициализированы в конструкторе, а
после этого в <code>readExternal</code> изменить значение этого поля будет невозможно. Соответственно – если вам необходимо
сериализовать объект, имеющий <code>final</code>-поле, вам придется использовать только стандартную сериализацию.</p>

<p id="serialver">Еще один момент, который многие не знают. При стандартной сериализации учитывается порядок
объявления полей в классе. Во всяком случае, так было в ранних версиях, в JVM версии 1.6 реализации Oracle уже
порядок неважен, важны тип и имя поля. Состав же методов с очень большой вероятностью повлияет на стандартный механизм,
при том, что поля могут вообще остаться теми же. Чтобы этого избежать, есть следующий механизм. В каждый класс,
реализующий интерфейс <code>Serializable</code>, на стадии компиляции добавляется еще одно поле – <code><b>private
static final long</b> serialVersionUID</code>. Это поле содержит уникальный идентификатор версии сериализованного класса.
Оно вычисляется по содержимому класса – полям, их порядку объявления, методам, их порядку объявления. Соответственно,
при любом изменении в классе это поле поменяет свое значение.</p>

<p>Это поле записывается в поток при сериализации класса. Кстати, это, пожалуй, единственный известный мне случай, когда
<code>static</code>-поле сериализуется. При десериализации значение этого поля сравнивается с имеющимся у класса в
виртуальной машине. Если значения не совпадают – инициируется исключение наподобие этого:</p>

<pre>java.io.InvalidClassException: test.ser2.ChildExt;
    local class incompatible: stream classdesc serialVersionUID = 8218484765288926197,
                                   local class serialVersionUID = 1465687698753363969</pre>

<p>Есть, однако, способ эту проверку если не обойти, то обмануть. Это может оказаться полезным, если набор полей класса и их
порядок уже определен, а методы класса могут меняться. В этом случае сериализации ничего не угрожает, однако стандартный
механизм не даст десериализовать данные с использованием байткода измененого класса. Но, как я уже сказал, его можно
обмануть. А именно – вручную в классе определить поле <code><b>private static final long</b> serialVersionUID</code>.
В принципе, значение этого поля может быть абсолютно любым. Некоторые предпочитают ставить его равным дате модификации
кода. Некоторые вообще используют <code>1L</code>. Для получения стандартного значения (того, которое вычисляется
внутренним механизмом) можно использовать утилиту <code>serialver</code>, входящую в поставку SDK. После такого
определения значение поля будет фиксировано, следовательно, десериализация всегда будет разрешена. </p>

<p>Более того, в версии 5.0 в документации появилось приблизительно следующее: <em>крайне рекомендуется</em> всем
сериализуемым классам декларировать это поле в явном виде, ибо вычисление по умолчанию очень чувствительно к деталям
структуры класса, которые могут различаться в зависимости от реализации компилятора, и вызывать таким образом неожиданные
<code>InvalidClassException</code> при десериализации. Объявлять это поле лучше как <code>private</code>, т.к. оно
относится исключительно к классу, в котором объявляется. Хотя в спецификации модификатор не оговорен.</p>

<p>Рассмотрим теперь вот какой аспект. Пусть у нас есть такая структура классов:</p>

<pre><span class="keyword">public</span> <span class="keyword">class</span> A{
    <span class="keyword">public</span> <span class="keyword">int</span> iPublic;
    <span class="keyword">protected</span> <span class="keyword">int</span> iProtected;
    <span class="keyword">int</span> iPackage;
    <span class="keyword">private</span> <span class="keyword">int</span> iPrivate;
}

<span class="keyword">public</span> <span class="keyword">class</span> B <span class="keyword">extends</span> A <span class="keyword">implements</span> Serializable{}</pre>        

<p>Иначе говоря, у нас есть класс, унаследованный от несериализуемого родителя. Можно ли сериализовать этот класс, и что для
этого надо? Что будет с переменными родительского класса?</p>

<p>Ответ такой. Да, сериализовать экземпляр класса <code>B</code> можно. Что для этого нужно? А нужно, чтобы у класса
<code>A</code> был конструктор без параметров, <code>public</code> либо <code>protected</code>. Тогда при десериализации
все переменные класса <code>A</code> будут инициализированы с помощью этого конструктора. Переменные класса <code>B</code>
будут инициализированы значениями из потока сериализованных данных.</p>

<p class="off">Теоретически можно в классе B определить методы, о которых я говорил в начале – <code>readObject</code> и
<code>writeObject</code>, – в начале которых производить (де-)сериализацию переменных класса <code>B</code> через <code>
in.defaultReadObject</code>/<code>out.defaultWriteObject</code>, а потом – (де-)сериализацию доступных переменных из
класса <code>A</code> (в нашем случае это <code>iPublic</code>, <code>iProtected</code> и <code>iPackage</code>, если <code>
B</code> находится с том же пакете, что и <code>A</code>). Однако, на мой взгляд, для этого лучше использовать расширенную
сериализацию.</p>

<p>Следующий момент, которого я хотел бы коснуться – сериализация нескольких объектов. Пусть у нас есть следующая структура
классов:</p>

<img src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/class_struct.gif" alt="Структура классов" align="left">
<pre><span class="keyword">public</span> <span class="keyword">class</span> A <span class="keyword">implements</span> Serializable{
    <span class="keyword">private</span> C c;
    <span class="keyword">private</span> B b;
    <span class="keyword">public</span> <span class="keyword">void</span> setC(C c) {<span class="keyword">this</span>.c = c;}
    <span class="keyword">public</span> <span class="keyword">void</span> setB(B b) {<span class="keyword">this</span>.b = b;}
    <span class="keyword">public</span> C getC() {<span class="keyword">return</span> c;}
    <span class="keyword">public</span> B getB() {<span class="keyword">return</span> b;}
}
<span class="keyword">public</span> <span class="keyword">class</span> B <span class="keyword">implements</span> Serializable{
    <span class="keyword">private</span> C c;
    <span class="keyword">public</span> <span class="keyword">void</span> setC(C c) {<span class="keyword">this</span>.c = c;}
    <span class="keyword">public</span> C getC() {<span class="keyword">return</span> c;}
}
<span class="keyword">public</span> <span class="keyword">class</span> C <span class="keyword">implements</span> Serializable{
    <span class="keyword">private</span> A a;
    <span class="keyword">private</span> B b;
    <span class="keyword">public</span> <span class="keyword">void</span> setA(A a) {<span class="keyword">this</span>.a = a;}
    <span class="keyword">public</span> <span class="keyword">void</span> setB(B b) {<span class="keyword">this</span>.b = b;}
    <span class="keyword">public</span> B getB() {<span class="keyword">return</span> b;}
    <span class="keyword">public</span> A getA() {<span class="keyword">return</span> a;}
}</pre>        

<p>Что произойдет, если сериализовать экземпляр класса <code>A</code>? Он потащит за собой экземпляр класса <code>B</code>,
который, в свою очередь, потащит экземпляр <code>C</code>, который имеет ссылку на экземпляр <code>A</code>, тот же
самый, с которого все начиналось. Замкнутый круг и бесконечная рекурсия? К счастью, нет. Посмотрим на следующий тестовый
код:</p>

<pre><span class="comment">// initiaizing</span>
A a = <span class="keyword">new</span> A();
B b = <span class="keyword">new</span> B();
C c = <span class="keyword">new</span> C();
<span class="comment">// setting references</span>
a.setB(b);
a.setC(c);
b.setC(c);
c.setA(a);
c.setB(b);
<span class="comment">// serializing</span>
ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();
ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);
oos.writeObject(a);
oos.writeObject(b);
oos.writeObject(c);
oos.flush();
oos.close();
<span class="comment">// deserializing</span>
ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));
A a1 = (A)ois.readObject();
B b1 = (B)ois.readObject();
C c1 = (C)ois.readObject();
<span class="comment">// testing</span>
System.<span class="static_final">out</span>.println(<span class="string">"a==a1: "</span>+(a==a1));
System.<span class="static_final">out</span>.println(<span class="string">"b==b1: "</span>+(b==b1));
System.<span class="static_final">out</span>.println(<span class="string">"c==c1: "</span>+(c==c1));
System.<span class="static_final">out</span>.println(<span class="string">"a1.getB()==b1: "</span>+(a1.getB()==b1));
System.<span class="static_final">out</span>.println(<span class="string">"a1.getC()==c1: "</span>+(a1.getC()==c1));
System.<span class="static_final">out</span>.println(<span class="string">"b1.getC()==c1: "</span>+(b1.getC()==c1));
System.<span class="static_final">out</span>.println(<span class="string">"c1.getA()==a1: "</span>+(c1.getA()==a1));
System.<span class="static_final">out</span>.println(<span class="string">"c1.getB()==b1: "</span>+(c1.getB()==b1));</pre>

<p>Что мы делаем? Мы создаем по экземпляру классов <code>A</code>, <code>B</code> и <code>C</code>, ставим им ссылки друг на
друга, после чего сериализуем каждый из них. Потом мы десериализуем их обратно и проводим серию проверок. Что получится
в <span id="test_results">результате</span>:</p>

<pre>a==a1: false
b==b1: false
c==c1: false
a1.getB()==b1: true
a1.getC()==c1: true
b1.getC()==c1: true
c1.getA()==a1: true
c1.getB()==b1: true</pre>

<p>Итак, что можно извлечь из этого теста. Первое. Ссылки на объекты после десериализации отличаются от ссылок до нее. Иначе
говоря, при сериализации/десериализации объект <em>был скопирован</em>. Этот метод используется иногда для клонирования
объектов.</p>

<p>Второй вывод, более сущеcтвенный. При сериализации/десериализации нескольких объектов, имеющих перекрестные ссылки, эти
ссылки остаются действительными после десериализации. Иначе говоря, если до сериализации они указывали на один объект, то
после десериализации они тоже будут указывать на один объект.</p>

<p id="another_test">Еще один небольшой тест в подтверждение этого:</p>

<pre>B b = <span class="keyword">new</span> B();
C c = <span class="keyword">new</span> C();
b.setC(c);
ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();
ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);
oos.writeObject(b);
oos.writeObject(c);
oos.writeObject(c);
oos.writeObject(c);
oos.flush();
oos.close();
ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));
B b1 = (B)ois.readObject();
C c1 = (C)ois.readObject();
C c2 = (C)ois.readObject();
C c3 = (C)ois.readObject();
System.<span class="static_final">out</span>.println(<span class="string">"b1.getC()==c1: "</span>+(b1.getC()==c1));
System.<span class="static_final">out</span>.println(<span class="string">"c1==c2: "</span>+(c1==c2));
System.<span class="static_final">out</span>.println(<span class="string">"c1==c3: "</span>+(c1==c3));</pre>

<p>Объект класса <code>B</code> имеет ссылку на объект класса <code>C</code>. При сериализации <code>b</code> сериализуется
вместе с экземпляром класса <code>С</code>, после чего тот же экземпляр <code>c</code> сериализуется трижды. Что получается
после десериализации?</p>

<pre>b1.getC()==c1: true
c1==c2: true
c1==c3: true</pre>

<p>Как видим, все четыре десериализованных объекта на самом деле представляют собой один объект – ссылки на него равны.
Ровно как это и было до сериализации.</p>

<p>Еще один интересный момент – что будет, если одновременно реализовать у класса <code>Externalizable</code> и <code>
Serializable</code>? Как в том вопросе – слон против кита – кто кого поборет?</p>

<p>Поборет <code>Externalizable</code>. Механизм сериализации сначала проверяет его наличие, а уж потом – наличие
<code>Serializable</code> Так что если класс <code>B</code>, реализующий <code>Serializable</code>, наследуется от класса
<code>A</code>, реализующего <code>Externalizable</code>, поля класса <code>B</code> сериализованы не будут.</p>

<p>Последний момент – наследование. При наследовании от класса, реализующего <code>Serializable</code>, никаких
дополнительных действий предпринимать не надо. Сериализация будет распространяться и на дочерний класс. При наследовании от
класса, реализующего <code>Externalizable</code>, необходимо переопределить методы родительского класса
<code>readExternal</code> и <code>writeExternal</code>. Иначе поля дочернего класса сериализованы не будут. В этом
случае надо бы не забыть вызвать родительские методы, иначе не сериализованы будут уже родительские поля.</p>

<p class="delim">* * *</p>

<p>С деталями, пожалуй, закончили. Однако есть один вопрос, который мы не затронули, глобального характера. А именно –</p>

<h3 id="why_needed_ext">Зачем нужен Externalizable</h3>

<p>Зачем вообще нужна расширенная сериализация? Ответ прост. Во-первых, она дает гораздо большую гибкость. Во-вторых,
зачастую она может дать немалый выигрыш по объему сериализованных данных. В-третьих, существует такой аспект как
производительность, о котором мы <a href="#performance">поговорим ниже</a>.</p>

<p>С гибкостью вроде как понятно всё. Действительно, мы можем управлять процессами сериализации и десериализации как хотим,
что делает нас независимыми от любых изменений в классе (как я говорил <a href="#serialver">чуть выше</a>, изменения в
классе способны сильно повлиять на десериализацию). Потому хочу сказать пару слов о выигрыше по объему.</p>

<p>Допустим, у нас есть следующий класс:</p>

<pre><span class="keyword">public</span> <span class="keyword">class</span> DateAndTime{

  <span class="keyword">private</span> <span class="keyword">short</span> year;
  <span class="keyword">private</span> <span class="keyword">byte</span> month;
  <span class="keyword">private</span> <span class="keyword">byte</span> day;
  <span class="keyword">private</span> <span class="keyword">byte</span> hours;
  <span class="keyword">private</span> <span class="keyword">byte</span> minutes;
  <span class="keyword">private</span> <span class="keyword">byte</span> seconds;

}</pre>

<p>Остальное несущественно. Поля можно было бы сделать типа <code>int</code>, но это лишь усилило бы эффект примера. Хотя в
реальности поля могут быть типа <code>int</code> по соображениям производительности. В любом случае, суть понятна. Класс
представляет собой дату и время. Нам он интересен прежде всего с точки зрения сериализации.</p>

<p>Возможно, проще всего было бы хранить простейший timestamp. Он имеет тип <code>long</code>, т.е. при сериализации он
занял бы 8 байт. Кроме того, этот подход требует методов преобразования компонент в одно значение и обратно, т.е. – потеря
в производительности. Плюс такого подхода – совершенно сумасшедшая дата, которая может поместиться в 64 бита. Это огромный
запас прочности, чаще всего в реальности не нужный. Класс же, приведенный выше, займет 2 + 5*1 = 7 байт. Плюс служебные
издержки на класс и 6 полей.</p>

<p>Можно ли как-нибудь ужать эти данные? Наверняка. Секунды и минуты лежат в интервале 0-59, т.е. для их представления
достаточно 6 бит вместо 8. Часы – 0-23 (5 бит), дни – 0-30 (5 бит), месяцы – 0-11 (4 бита). Итого, всё без учета года – 26
бит. До размера <code>int</code> еще остается 6 бит. Теоретически, в некоторых случаях этого может хватить для года. Если
нет – добавление еще одного байта увеличивает размер поля данных до 14 бит, что дает промежуток 0-16383. Этого более чем
достаточно в реальных приложениях. Итого – мы ужали размер данных, необходимых для хранения нужной информации, до 5 байт.
Если не до 4.</p>

<p>Недостаток тот же, что и в предыдущем случае – если хранить дату упакованной, то нужны методы преобразования. А хочется
так – хранить в отдельных полях, а сериализовать в упакованном виде. Вот тут как раз целесообразно использовать <code>
Externalizable</code>:</p>

<pre><span class="comment">// data is packed into 5 bytes:</span>
<span class="comment">//  3         2         1</span>
<span class="comment">// 10987654321098765432109876543210</span>
<span class="comment">// hhhhhmmmmmmssssssdddddMMMMyyyyyy yyyyyyyy</span>
<span class="keyword">public</span> <span class="keyword">void</span> writeExternal(ObjectOutput out){
    <span class="keyword">int</span> packed = 0;
    packed += ((<span class="keyword">int</span>)hours) &lt;&lt; 27;
    packed += ((<span class="keyword">int</span>)minutes) &lt;&lt; 21;
    packed += ((<span class="keyword">int</span>)seconds) &lt;&lt; 15;
    packed += ((<span class="keyword">int</span>)day) &lt;&lt; 10;
    packed += ((<span class="keyword">int</span>)month) &lt;&lt; 6;
    packed += (((<span class="keyword">int</span>)year) &gt;&gt; 8) &amp; 0x3F;
    out.writeInt(packed);
    out.writeByte((<span class="keyword">byte</span>)year);
}

<span class="keyword">public</span> <span class="keyword">void</span> readExternal(ObjectInput in){
    <span class="keyword">int</span> packed = in.readInt();
    year = in.readByte() &amp; 0xFF;
    year += (packed &amp; 0x3F) &lt;&lt; 8;
    month = (packed &gt;&gt; 6) &amp; 0x0F;
    day = (packed &gt;&gt; 10) &amp; 0x1F;
    seconds = (packed &gt;&gt; 15) &amp; 0x3F;
    minutes = (packed &gt;&gt; 21) &amp; 0x3F;
    hours = (packed &gt;&gt; 27);
}</pre>

<p>Собственно, это все. После сериализации мы получаем служебные издержки на класс, два поля (вместо 6) и 5 байт данных.
Что уже существенно лучше. Дальшейшую упаковку можно оставить специализированным библиотекам.</p>

<p>Приведенный пример весьма прост. Его основное предназначение – показать, как можно применять расширенную сериализацию.
Хотя возможный выигрыш в объеме сериализованных данных – далеко не основное преимущество, на мой взгляд. Основное же
преимущество, помимо гибкости... (плавно переходим к следующему разделу...) </p>

<h3 id="performance">Производительность</h3>

<p>Как я уже говорил, стандартная сериализация работает через Reflection API. Что означает, что для сериализации берется
класс сериализуемого объекта, у него берется список полей, по всем полям в цикле проверяются различные условия (<code>
transient</code> или нет, если объект, то Externalizable или Serializable), значения пишутся в поток, причем достаются из
полей тоже через reflection... В общем, ситуация ясна. В противоположность этому методу, вся процедура при использовании
расширенной сериализации контролируется самим разработчиком. Осталось выяснить, какие преимущества это дает по скорости.</p>

<p>Итак, условия теста. Объект произвольной структуры. Два варианта – один <code>Serializable</code>, второй <code>
Externalizable</code>. Некоторое количество объектов обоих вариантов инициализируется произвольными (идентичными для
каждой пары объектов) данными, после чего помещается в контейнер. Контейнер тоже в одном случае <code>Serializable</code>,
в другом <code>Externalizable</code>. Далее контейнеры будут сериализованы и десериализованы с замерами времени.</p>

<p>Полный код теста вместе с build-файлом для <code>ant</code> можно найти тут – <a href="http://www.skipy.ru/technics/serialization.zip">
serialization.zip</a>. В тексте я буду приводить только отрывки.</p>

<p>Сериализуемый объект содержит следующий набор полей:</p>

<pre><span class="keyword">private</span> <span class="keyword">int</span> fieldInt;
<span class="keyword">private</span> <span class="keyword">boolean</span> fieldBoolean;
<span class="keyword">private</span> <span class="keyword">long</span> fieldLong;
<span class="keyword">private</span> <span class="keyword">float</span> fieldFloat;
<span class="keyword">private</span> <span class="keyword">double</span> fieldDouble;
<span class="keyword">private</span> String fieldString;</pre>

<p>Тест содержит три реализации <code>Externalizable</code> контейнеров. <span id="first">Первая</span> из них,
<code>ContainerExt1</code>, простейшая. Это просто сериализация содержащего объекты <code>java.util.List</code>:</p>

<pre><span class="keyword">public</span> <span class="keyword">void</span> writeExternal(ObjectOutput out) <span class="keyword">throws</span> IOException {
    out.writeObject(items);
}
<span class="keyword">public</span> <span class="keyword">void</span> readExternal(ObjectInput in) <span class="keyword">throws</span> IOException, ClassNotFoundException {
    items = (List&lt;ItemExt&gt;)in.readObject();
}</pre>

<p id="second">Вторая реализация, <code>ContainerExt2</code>, сериализует последовательно все имеющиеся объекты,
предваряя их количеством объектов:</p>

<pre><span class="keyword">public</span> <span class="keyword">void</span> writeExternal(ObjectOutput out) <span class="keyword">throws</span> IOException {
    out.writeInt(items.size());
    <span class="keyword">for</span>(Externalizable ext : items)
        out.writeObject(ext);
}
<span class="keyword">public</span> <span class="keyword">void</span> readExternal(ObjectInput in) <span class="keyword">throws</span> IOException, ClassNotFoundException {
    <span class="keyword">int</span> count = in.readInt();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=0; i&lt;count; i++){
        ItemExt ext = (ItemExt)in.readObject();
        items.add(ext);
    }
}</pre>

<p id="third">Третья реализация, <code>ContainerExt3</code>, использует <code>externalizable</code>-методы
объектов:</p>

<pre><span class="keyword">public</span> <span class="keyword">void</span> writeExternal(ObjectOutput out) <span class="keyword">throws</span> IOException {
    out.writeInt(items.size());
    <span class="keyword">for</span>(Externalizable ext : items)
        ext.writeExternal(out);
}
<span class="keyword">public</span> <span class="keyword">void</span> readExternal(ObjectInput in) <span class="keyword">throws</span> IOException, ClassNotFoundException {
    <span class="keyword">int</span> count = in.readInt();
    <span class="keyword">for</span>(<span class="keyword">int</span> i=0; i&lt;count; i++){
        ItemExt ext = <span class="keyword">new</span> ItemExt();
        ext.readExternal(in);
        items.add(ext);
    }
}</pre>

<p>Запускается тест с помощью команды <code>ant</code> (поскольку задача <code>run</code> запускается по умолчанию). В
<code>build</code>-файле задано количество создаваемых объектов – <code>100000</code>. Другое количество может быть задано
с помощью параметра командной строки <code>-Dobjcount=&lt;value&gt;</code>.</p>

<p>Итак, каковы результаты выполнения теста? На 100000 создаваемых объектов (результаты могут незначительно отличаться
от запуска к запуску):</p>

<pre>Creating 100000 objects
Serializable: written in 3516ms, readed in 3235
Externalizable1: written in 4046ms, readed in 3234
Externalizable2: written in 3875ms, readed in 2985
Externalizable3: written in 235ms, readed in 297</pre>

<p>И размеры сериализованных данных (размеры файлов на диске):</p>

<pre>cont.ser        5&nbsp;547&nbsp;955
contExt1.ser    5&nbsp;747&nbsp;884
contExt2.ser    5&nbsp;747&nbsp;846
contExt3.ser    4&nbsp;871&nbsp;461</pre>

<p>Что мы видим? <a href="#first">Первый</a> способ реализации <code>Externalizable</code> даже несколько хуже стандартной
сериализации. Сериализация занимает немного больше времени, десериализация сравнима. Размеры файлов тоже немного в пользу
стандартной сериализации. Вывод – простейшая сериализация контейнера преимуществ не дает: +15% при сериализации,
десериализация отличается на доли процента, причем как в одну, так и в другую сторону.</p>

<p><a href="#second">Второй</a> способ реализации <code>Externalizable</code> по характеристикам практически идентичен
первому. Чуть быстрее сериализация, но все равно проигрывает стандартной, десериализация чуть выигрывает. Размер файла
практически идентичен первому способу (разница – 38 байт). Выигрыша по сравнению со стандартной сериализацией нет – +10%
при сериализации, -8% при десериализации.</p>

<p><a href="#third">Третий</a> способ реализации <code>Externalizable</code>. Вот тут есть на что посмотреть! Сериализация
быстрее в 15 раз! Естественно, плюс-минус, но тем не менее – разница на порядок! Десериализация быстрее практически в 11 раз!
Разница тоже на порядок! Опять же плюс-минус, но мне не удавалось получить разницу меньше, нежели в 5 раз. Ну и разница
в размере файла -13%. Как маленькое, но приятное дополнение.</p>

<p>Думаю, комментарии излишни. Получаемые от <b>грамотной</b> реализации <code>Externalizable</code> преимущества в скорости
с лихвой компенсируют затраты на эту самую реализацию. Грамотной – в смысле, целиком и полностью реализованной
самостоятельно, без использования имеющихся механизмов сериализации целых объектов (в основном это методы <code>
writeObject/readObject</code>). Использование же имеющихся механизмов и/или смешивание со стандартной сериализацией способно
свести скоростные преимущества <code>Externalizable</code> на нет.</p>

<p>Однако есть и ...</p>

<h3 id="back_side">Обратная сторона медали</h3>

<p>И прежде всего это <b>нарушение целостности графа</b>. Поскольку протокол сериализации не используется – контроль
целостности остается на самом разработчике. И об этом следует помнить, ибо в некоторых случаях можно легко убить все
преимущества. Если, к примеру, необходимо сериализовать очень много экземпляров класса <code>A</code>, каждый из которых
ссылается на единственный экземпляр класса <code>B</code>, то при неумелом использовании <code>Externalizable</code> может
получиться так, что экземпляр <code>B</code> будет сериализован по разу на каждый экземпляр <code>A</code>, что даст потерю
как в скорости, так и в объеме сериализованных данных. А при десериализации мы вообще получим кучу экземпляров
<code>B</code> вместо одного! Что намного хуже.</p>

<p>Поэтому, да и не только, <code>Externalizable</code> следует использовать обдуманно. Как, впрочем, и любую другую
возможность. Если необходимо сериализовать достаточно сложные графы – пожалуй, лучше все-таки воспользоваться имеющимися
механизмами. Если же объемы данных большие, но сложность невелика – можно немного поработать и получить солидный выигрыш
в скорости. В любом случае лучше написать небольшой прототип и уже на нем оценивать реальную скорость и сложность реализации
целостности.</p>

<p>Перейдем к следующему вопросу, связанному с сериализацией.</p>

<h3 id="security">Безопасность данных</h3>

<p>Есть такое правило: проверять входящие данные (входные параметры функций и т.п.) на "правильность" – соответствие
определенным требованиям. Причем это не столько правило хорошего тона, сколько правило выживания приложения. Ибо если этого
не сделать, то при передаче неверных параметров в лучшем случае (<b>действительно</b> – в <b>лучшем</b>!) приложение просто
"упадет". В худшем случае оно тихо примет предложенные данные и может нанести значительно больший урон.</p>

<p>Про это правило худо-бедно, но помнят. Однако конструкторы и открытые методы – не единственный способ поставки данных
объекту. Точно так же объект может быть создан с помощью десериализации. И вот тут о контроле внутреннего состояния
полученного объекта, как правило, забывают. Между тем, создать поток для получения из него объекта с неверным внутренним
состоянием не легко, а очень легко.</p>

<p>Пример номер один. Объект с двумя полями типа <code>java.util.Date</code>. Одно поле – начало интервала времени, другое –
конец. Следовательно, между ними должно существовать определенное соотношение (конец должен быть не раньше начала). Однако
любой человек, знающий байткод, сумеет отредактировать сериализованный объект так, что после десериализации конец интервала
будет раньше начала. К чему приведет появление в системе такого объекта – предугадать сложно. В любом случае, ничего хорошего
ждать не приходится. Потому, примите для себя...</p>

<p class="important">Правило 1. После десериализации объекта необходимо проверить его внутреннее состояние (инварианты) на
правильность, точно так же, как и при создании с помощью конструктора. Если объект не прошел такую проверку, необходимо
инициировать исключение <code>java.io.InvalidObjectException</code>.</p>

<p>Пример номер два. Объект класса <code>A</code> содержит в себе <code>private</code>-поле типа <code>java.util.Date</code>.
Для изменения снаружи объекта это поле недоступно. Однако возможна следующая операция: к потоку дописывается некоторая
информация. Потом, после десериализации из этого потока объекта класса <code>A</code> производится десериализация еще одного
объекта, но уже типа <code>Date</code>. Как мы уже <a href="#another_test">видели</a> в примере ранее, можно
создать такой поток (в примере он создавался легально), что при десериализации этот второй объект в действительности будет
лишь ссылкой на экземпляр <code>Date</code>, казалось бы так надежно спрятанный внутри объекта класса <code>A</code>.
Соответственно, с этим экземпляром можно делать все, что заблагорасудится.
</p>

<p class="off">
Не буду вдаваться в подробности. Описание этого приема есть в книге
<a href="http://www.skipy.ru/useful/books.html#ISBN-5-85582-169-2">Джошуа Блох. Java. Эффективное программирование</a>, в статье 56. Скажу
только, что достаточно к потоку дописать 5 байт, чтобы добиться желаемого.</p>

<p>Чтобы этого избежать, необходимо следовать следующему правилу:</p>

<p class="important">Правило 2. Если в составе класса <code>A</code> присутствуют объекты, которые не должны быть доступными
для изменения извне, то при десериализации экземпляра класса <code>A</code> необходимо вместо этих объектов создать и
сохранить их копии.</p>

<p>Приведенные выше примеры показывают возможные "дыры" в безопасности. Следование упомянутым правилам, разумеется, не
спасает от проблем, но может существенно снизить их количество. Советую по этому поводу почитать книгу
<a href="http://www.skipy.ru/useful/books.html#ISBN-5-85582-169-2">Джошуа Блох. Java. Эффективное программирование</a>, статью 56.</p>

<p>Ну и последняя тема, которой я хотел бы коснуться – </p>

<h3 id="singleton">Сериализация объектов Singleton</h3>

<p>Тех, кто не в курсе, что такое <code>Singleton</code>, отсылаю к <a href="http://www.skipy.ru/technics/singleton.html">отдельной статье</a>.</p>

<p>В чем проблема сериализации <code>Singleton</code>-ов? А проблема в уже упомянутом мной факте – после десериализации мы
получим другой объект. Это <a href="#test_results">видно в результатах</a> первого из тестов в этой статье – ссылки на
исходный и десериализованный объекты не совпадают. Таким образом, сериализация дает возможность создать <code>Singleton
</code> еще раз, что нам совсем не нужно. Можно, конечно, запретить сериализовать <code>Singleton</code>-ы, но это,
фактически, уход от проблемы, а не ее решение.</p>

<p>Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой</p>

<pre>ANY-ACCESS-MODIFIER Object readResolve() <span class="keyword">throws</span> ObjectStreamException</pre>

<p>Модификатор доступа может быть <code>private</code>, <code>protected</code> и по умолчанию (<code>default</code>).
Можно, наверное, сделать его и <code>public</code>, но смысла я в этом не вижу. Назначение этого метода – возвращать
замещающий объект вместо объекта, на котором он вызван. Приведу простой пример:</p>

<pre><span class="keyword">public</span> <span class="keyword">class</span> Answer <span class="keyword">implements</span> Serializable{

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="static_final">STR_YES</span> = <span class="string">"Yes"</span>;
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="static_final">STR_NO</span> = <span class="string">"No"</span>;

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Answer <span class="static_final">YES</span> = <span class="keyword">new</span> Answer(<span class="static_final">STR_YES</span>);
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Answer <span class="static_final">NO</span> = <span class="keyword">new</span> Answer(<span class="static_final">STR_NO</span>);

    <span class="keyword">private</span> String answer = <span class="keyword">null</span>;

    <span class="keyword">private</span> Answer(String answer){
        <span class="keyword">this</span>.answer = answer;
    }

    <span class="keyword">private</span> Object readResolve() <span class="keyword">throws</span> ObjectStreamException{
        <span class="keyword">if</span> (<span class="static_final">STR_YES</span>.equals(answer))
            <span class="keyword">return</span> <span class="static_final">YES</span>;
        <span class="keyword">if</span> (<span class="static_final">STR_NO</span>.equals(answer))
            <span class="keyword">return</span> <span class="static_final">NO</span>;
        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Unknown value: "</span> + answer);
    }
}</pre>

<p>Класс, приведенный выше – простейший перечислимый тип. Всего два значения – <code>Answer.YES</code> и <code>
Answer.NO</code>. Соответственно, именно эти два значения и должны фигурировать после десериализации. Что делается в
методе <code>readResolve</code>? Он вызывается на десериализованном объекте. И возвращать он должен уже существующий
экземпляр класса, соответствующий внутреннему состоянию десериализованного объекта. В данном примере – проверяется значение
поля <code>answer</code>. Если объект, соответствующий внутреннему состоянию, не найден... На мой взгляд, это зависит от
ситуации. В приведенном примере стоит инициировать исключение. Возможно, в каких-то ситуациях будет полезно вернуть
<code>this</code>. Примером этого, например, является реализация <code>java.util.logging.Level</code>.
</p>

<p>Существует и обратный метод – <code>writeReplace</code>, который, как вы, наверное, уже догадались, позволяет выдать
замещающий объект вместо текущего, для сериализации. Мне, честно сказать, трудно представить себе ситуации, в которых это
может понадобиться. Хотя в недрах кода Sun он как-то используется.</p>

<p>Оба метода, как <code>readResolve</code>, так и <code>writeReplace</code>, вызываются при использовании стандартных
средств сериализации (методов <code>readObject</code> и <code>writeObject</code>), вне зависимости от того, объявлен ли
сериализуемый класс как <code>Serializable</code> или <code>Externalizable</code>.</p>

<p>Самое интересное, что, похоже, из этих методов можно возвращать не только экземпляр класса, в котором этот метод
определен, но и экземпляр другого класса. Я видел подобные примеры в глубинах библиотек Sun, во всяком случае, для <code>
writeReplace</code> – точно видел. Но по каким принципам можно это делать – не берусь пока судить. Вообще, советую
интересующимся просмотреть исходники J2SE 5.0, причем полные. Они доступны по лицензии JRL. Там есть много интересных
примеров использования этих методов. Исходники можно взять тут – <a href="http://java.sun.com/j2se/jrl_download.html" target="_blank">http://java.sun.com/j2se/jrl_download.html</a>. Правда, требуется регистрация, но она, естественно,
бесплатна.</p>

<p id="enum_ser">Отдельно хочу коснуться сериализации перечислений (<code>enum</code>), появившихся в Java 5.0.
Поскольку при сериализации в поток пишется имя элемента и его порядковый номер в определении в классе, можно было бы ожидать
проблем при десериализации в случае изменения порядкового номера (что может случиться очень легко – достаточно поменять
элементы местами). Однако, к счастью, таких проблем нет. Десериализация объектов типа <code>enum</code> контролируется для
обеспечения соответствия десериализуемых экземпляров уже имеющимся у виртуальной машины. Фактически, это то, что делает
обычно метод <code> readResolve</code>, но реализовано где-то существенно глубже. Сопоставление объектов осуществляется по
имени. Разработчикам версии 5.0 – респект!
</p>

<p class="delim">* * *</p>

<p>Наверное, на текущий момент это все, что я хотел рассказать о сериализации. Думаю, теперь она не кажется такой простой,
какой казалась до прочтения этой статьи. И хорошо. Пребывание в блаженном неведении к добру не приводит.</p>
    <br><p class="top_link"><a href="#top">В начало</a></p></div></td></tr><tr><td><div id="copyright">
                    Copyright © 2004-2013 Евгений Матюшкин aka Skipy
                    (e-mail: skiрy<img src="skipy.ru:%20%D0%A1%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%B0%D0%BA%20%D0%BE%D0%BD%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C_files/at_sm.gif" alt="@">skipy.ru)<br><a href="http://www.skipy.ru/about_copying.html">Копирование и воспроизведение материалов</a> этого сайта возможно
                    только с согласия автора!
                </div></td></tr></tbody></table></body></html>